/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({
  "node_modules/before-after-hook/lib/register.js"(exports, module2) {
    module2.exports = register;
    function register(state, name, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name)) {
        return name.reverse().reduce(function(callback, name2) {
          return register.bind(null, state, name2, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name]) {
          return method(options);
        }
        return state.registry[name].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "node_modules/before-after-hook/lib/add.js"(exports, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name, hook2) {
      var orig = hook2;
      if (!state.registry[name]) {
        state.registry[name] = [];
      }
      if (kind === "before") {
        hook2 = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook2 = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook2 = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
            return orig(error, options);
          });
        };
      }
      state.registry[name].push({
        hook: hook2,
        orig
      });
    }
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "node_modules/before-after-hook/lib/remove.js"(exports, module2) {
    module2.exports = removeHook;
    function removeHook(state, name, method) {
      if (!state.registry[name]) {
        return;
      }
      var index = state.registry[name].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index === -1) {
        return;
      }
      state.registry[name].splice(index, 1);
    }
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "node_modules/before-after-hook/index.js"(exports, module2) {
    var register = require_register();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook2, state, name) {
      var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
      hook2.api = { remove: removeHookRef };
      hook2.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name ? [state, kind, name] : [state, kind];
        hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook2 = register.bind(null, state);
      bindApi(hook2, state);
      return hook2;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global2 !== "undefined") {
        return global2;
      }
      throw new Error("unable to locate global object");
    };
    var global2 = getGlobal();
    module2.exports = exports = global2.fetch;
    if (global2.fetch) {
      exports.default = global2.fetch.bind(global2);
    }
    exports.Headers = global2.Headers;
    exports.Request = global2.Request;
    exports.Response = global2.Response;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module2) {
    "use strict";
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/lodash.deburr/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.deburr/index.js"(exports, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol = root.Symbol;
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module2.exports = deburr;
  }
});

// node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js"(exports, module2) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/@sindresorhus/transliterate/replacements.js
var require_replacements = __commonJS({
  "node_modules/@sindresorhus/transliterate/replacements.js"(exports, module2) {
    "use strict";
    module2.exports = [
      ["\xDF", "ss"],
      ["\xE4", "ae"],
      ["\xC4", "Ae"],
      ["\xF6", "oe"],
      ["\xD6", "Oe"],
      ["\xFC", "ue"],
      ["\xDC", "Ue"],
      ["\xC0", "A"],
      ["\xC1", "A"],
      ["\xC2", "A"],
      ["\xC3", "A"],
      ["\xC4", "Ae"],
      ["\xC5", "A"],
      ["\xC6", "AE"],
      ["\xC7", "C"],
      ["\xC8", "E"],
      ["\xC9", "E"],
      ["\xCA", "E"],
      ["\xCB", "E"],
      ["\xCC", "I"],
      ["\xCD", "I"],
      ["\xCE", "I"],
      ["\xCF", "I"],
      ["\xD0", "D"],
      ["\xD1", "N"],
      ["\xD2", "O"],
      ["\xD3", "O"],
      ["\xD4", "O"],
      ["\xD5", "O"],
      ["\xD6", "Oe"],
      ["\u0150", "O"],
      ["\xD8", "O"],
      ["\xD9", "U"],
      ["\xDA", "U"],
      ["\xDB", "U"],
      ["\xDC", "Ue"],
      ["\u0170", "U"],
      ["\xDD", "Y"],
      ["\xDE", "TH"],
      ["\xDF", "ss"],
      ["\xE0", "a"],
      ["\xE1", "a"],
      ["\xE2", "a"],
      ["\xE3", "a"],
      ["\xE4", "ae"],
      ["\xE5", "a"],
      ["\xE6", "ae"],
      ["\xE7", "c"],
      ["\xE8", "e"],
      ["\xE9", "e"],
      ["\xEA", "e"],
      ["\xEB", "e"],
      ["\xEC", "i"],
      ["\xED", "i"],
      ["\xEE", "i"],
      ["\xEF", "i"],
      ["\xF0", "d"],
      ["\xF1", "n"],
      ["\xF2", "o"],
      ["\xF3", "o"],
      ["\xF4", "o"],
      ["\xF5", "o"],
      ["\xF6", "oe"],
      ["\u0151", "o"],
      ["\xF8", "o"],
      ["\xF9", "u"],
      ["\xFA", "u"],
      ["\xFB", "u"],
      ["\xFC", "ue"],
      ["\u0171", "u"],
      ["\xFD", "y"],
      ["\xFE", "th"],
      ["\xFF", "y"],
      ["\u1E9E", "SS"],
      ["\xE0", "a"],
      ["\xC0", "A"],
      ["\xE1", "a"],
      ["\xC1", "A"],
      ["\xE2", "a"],
      ["\xC2", "A"],
      ["\xE3", "a"],
      ["\xC3", "A"],
      ["\xE8", "e"],
      ["\xC8", "E"],
      ["\xE9", "e"],
      ["\xC9", "E"],
      ["\xEA", "e"],
      ["\xCA", "E"],
      ["\xEC", "i"],
      ["\xCC", "I"],
      ["\xED", "i"],
      ["\xCD", "I"],
      ["\xF2", "o"],
      ["\xD2", "O"],
      ["\xF3", "o"],
      ["\xD3", "O"],
      ["\xF4", "o"],
      ["\xD4", "O"],
      ["\xF5", "o"],
      ["\xD5", "O"],
      ["\xF9", "u"],
      ["\xD9", "U"],
      ["\xFA", "u"],
      ["\xDA", "U"],
      ["\xFD", "y"],
      ["\xDD", "Y"],
      ["\u0103", "a"],
      ["\u0102", "A"],
      ["\u0110", "D"],
      ["\u0111", "d"],
      ["\u0129", "i"],
      ["\u0128", "I"],
      ["\u0169", "u"],
      ["\u0168", "U"],
      ["\u01A1", "o"],
      ["\u01A0", "O"],
      ["\u01B0", "u"],
      ["\u01AF", "U"],
      ["\u1EA1", "a"],
      ["\u1EA0", "A"],
      ["\u1EA3", "a"],
      ["\u1EA2", "A"],
      ["\u1EA5", "a"],
      ["\u1EA4", "A"],
      ["\u1EA7", "a"],
      ["\u1EA6", "A"],
      ["\u1EA9", "a"],
      ["\u1EA8", "A"],
      ["\u1EAB", "a"],
      ["\u1EAA", "A"],
      ["\u1EAD", "a"],
      ["\u1EAC", "A"],
      ["\u1EAF", "a"],
      ["\u1EAE", "A"],
      ["\u1EB1", "a"],
      ["\u1EB0", "A"],
      ["\u1EB3", "a"],
      ["\u1EB2", "A"],
      ["\u1EB5", "a"],
      ["\u1EB4", "A"],
      ["\u1EB7", "a"],
      ["\u1EB6", "A"],
      ["\u1EB9", "e"],
      ["\u1EB8", "E"],
      ["\u1EBB", "e"],
      ["\u1EBA", "E"],
      ["\u1EBD", "e"],
      ["\u1EBC", "E"],
      ["\u1EBF", "e"],
      ["\u1EBE", "E"],
      ["\u1EC1", "e"],
      ["\u1EC0", "E"],
      ["\u1EC3", "e"],
      ["\u1EC2", "E"],
      ["\u1EC5", "e"],
      ["\u1EC4", "E"],
      ["\u1EC7", "e"],
      ["\u1EC6", "E"],
      ["\u1EC9", "i"],
      ["\u1EC8", "I"],
      ["\u1ECB", "i"],
      ["\u1ECA", "I"],
      ["\u1ECD", "o"],
      ["\u1ECC", "O"],
      ["\u1ECF", "o"],
      ["\u1ECE", "O"],
      ["\u1ED1", "o"],
      ["\u1ED0", "O"],
      ["\u1ED3", "o"],
      ["\u1ED2", "O"],
      ["\u1ED5", "o"],
      ["\u1ED4", "O"],
      ["\u1ED7", "o"],
      ["\u1ED6", "O"],
      ["\u1ED9", "o"],
      ["\u1ED8", "O"],
      ["\u1EDB", "o"],
      ["\u1EDA", "O"],
      ["\u1EDD", "o"],
      ["\u1EDC", "O"],
      ["\u1EDF", "o"],
      ["\u1EDE", "O"],
      ["\u1EE1", "o"],
      ["\u1EE0", "O"],
      ["\u1EE3", "o"],
      ["\u1EE2", "O"],
      ["\u1EE5", "u"],
      ["\u1EE4", "U"],
      ["\u1EE7", "u"],
      ["\u1EE6", "U"],
      ["\u1EE9", "u"],
      ["\u1EE8", "U"],
      ["\u1EEB", "u"],
      ["\u1EEA", "U"],
      ["\u1EED", "u"],
      ["\u1EEC", "U"],
      ["\u1EEF", "u"],
      ["\u1EEE", "U"],
      ["\u1EF1", "u"],
      ["\u1EF0", "U"],
      ["\u1EF3", "y"],
      ["\u1EF2", "Y"],
      ["\u1EF5", "y"],
      ["\u1EF4", "Y"],
      ["\u1EF7", "y"],
      ["\u1EF6", "Y"],
      ["\u1EF9", "y"],
      ["\u1EF8", "Y"],
      ["\u0621", "e"],
      ["\u0622", "a"],
      ["\u0623", "a"],
      ["\u0624", "w"],
      ["\u0625", "i"],
      ["\u0626", "y"],
      ["\u0627", "a"],
      ["\u0628", "b"],
      ["\u0629", "t"],
      ["\u062A", "t"],
      ["\u062B", "th"],
      ["\u062C", "j"],
      ["\u062D", "h"],
      ["\u062E", "kh"],
      ["\u062F", "d"],
      ["\u0630", "dh"],
      ["\u0631", "r"],
      ["\u0632", "z"],
      ["\u0633", "s"],
      ["\u0634", "sh"],
      ["\u0635", "s"],
      ["\u0636", "d"],
      ["\u0637", "t"],
      ["\u0638", "z"],
      ["\u0639", "e"],
      ["\u063A", "gh"],
      ["\u0640", "_"],
      ["\u0641", "f"],
      ["\u0642", "q"],
      ["\u0643", "k"],
      ["\u0644", "l"],
      ["\u0645", "m"],
      ["\u0646", "n"],
      ["\u0647", "h"],
      ["\u0648", "w"],
      ["\u0649", "a"],
      ["\u064A", "y"],
      ["\u064E\u200E", "a"],
      ["\u064F", "u"],
      ["\u0650\u200E", "i"],
      ["\u0660", "0"],
      ["\u0661", "1"],
      ["\u0662", "2"],
      ["\u0663", "3"],
      ["\u0664", "4"],
      ["\u0665", "5"],
      ["\u0666", "6"],
      ["\u0667", "7"],
      ["\u0668", "8"],
      ["\u0669", "9"],
      ["\u0686", "ch"],
      ["\u06A9", "k"],
      ["\u06AF", "g"],
      ["\u067E", "p"],
      ["\u0698", "zh"],
      ["\u06CC", "y"],
      ["\u06F0", "0"],
      ["\u06F1", "1"],
      ["\u06F2", "2"],
      ["\u06F3", "3"],
      ["\u06F4", "4"],
      ["\u06F5", "5"],
      ["\u06F6", "6"],
      ["\u06F7", "7"],
      ["\u06F8", "8"],
      ["\u06F9", "9"],
      ["\u067C", "p"],
      ["\u0681", "z"],
      ["\u0685", "c"],
      ["\u0689", "d"],
      ["\uFEAB", "d"],
      ["\uFEAD", "r"],
      ["\u0693", "r"],
      ["\uFEAF", "z"],
      ["\u0696", "g"],
      ["\u069A", "x"],
      ["\u06AB", "g"],
      ["\u06BC", "n"],
      ["\u06C0", "e"],
      ["\u06D0", "e"],
      ["\u06CD", "ai"],
      ["\u0679", "t"],
      ["\u0688", "d"],
      ["\u0691", "r"],
      ["\u06BA", "n"],
      ["\u06C1", "h"],
      ["\u06BE", "h"],
      ["\u06D2", "e"],
      ["\u0410", "A"],
      ["\u0430", "a"],
      ["\u0411", "B"],
      ["\u0431", "b"],
      ["\u0412", "V"],
      ["\u0432", "v"],
      ["\u0413", "G"],
      ["\u0433", "g"],
      ["\u0414", "D"],
      ["\u0434", "d"],
      ["\u0415", "E"],
      ["\u0435", "e"],
      ["\u0416", "Zh"],
      ["\u0436", "zh"],
      ["\u0417", "Z"],
      ["\u0437", "z"],
      ["\u0418", "I"],
      ["\u0438", "i"],
      ["\u0419", "J"],
      ["\u0439", "j"],
      ["\u041A", "K"],
      ["\u043A", "k"],
      ["\u041B", "L"],
      ["\u043B", "l"],
      ["\u041C", "M"],
      ["\u043C", "m"],
      ["\u041D", "N"],
      ["\u043D", "n"],
      ["\u041E", "O"],
      ["\u043E", "o"],
      ["\u041F", "P"],
      ["\u043F", "p"],
      ["\u0420", "R"],
      ["\u0440", "r"],
      ["\u0421", "S"],
      ["\u0441", "s"],
      ["\u0422", "T"],
      ["\u0442", "t"],
      ["\u0423", "U"],
      ["\u0443", "u"],
      ["\u0424", "F"],
      ["\u0444", "f"],
      ["\u0425", "H"],
      ["\u0445", "h"],
      ["\u0426", "Cz"],
      ["\u0446", "cz"],
      ["\u0427", "Ch"],
      ["\u0447", "ch"],
      ["\u0428", "Sh"],
      ["\u0448", "sh"],
      ["\u0429", "Shh"],
      ["\u0449", "shh"],
      ["\u042A", ""],
      ["\u044A", ""],
      ["\u042B", "Y"],
      ["\u044B", "y"],
      ["\u042C", ""],
      ["\u044C", ""],
      ["\u042D", "E"],
      ["\u044D", "e"],
      ["\u042E", "Yu"],
      ["\u044E", "yu"],
      ["\u042F", "Ya"],
      ["\u044F", "ya"],
      ["\u0401", "Yo"],
      ["\u0451", "yo"],
      ["\u0103", "a"],
      ["\u0102", "A"],
      ["\u0219", "s"],
      ["\u0218", "S"],
      ["\u021B", "t"],
      ["\u021A", "T"],
      ["\u0163", "t"],
      ["\u0162", "T"],
      ["\u015F", "s"],
      ["\u015E", "S"],
      ["\xE7", "c"],
      ["\xC7", "C"],
      ["\u011F", "g"],
      ["\u011E", "G"],
      ["\u0131", "i"],
      ["\u0130", "I"],
      ["\u0561", "a"],
      ["\u0531", "A"],
      ["\u0562", "b"],
      ["\u0532", "B"],
      ["\u0563", "g"],
      ["\u0533", "G"],
      ["\u0564", "d"],
      ["\u0534", "D"],
      ["\u0565", "ye"],
      ["\u0535", "Ye"],
      ["\u0566", "z"],
      ["\u0536", "Z"],
      ["\u0567", "e"],
      ["\u0537", "E"],
      ["\u0568", "y"],
      ["\u0538", "Y"],
      ["\u0569", "t"],
      ["\u0539", "T"],
      ["\u056A", "zh"],
      ["\u053A", "Zh"],
      ["\u056B", "i"],
      ["\u053B", "I"],
      ["\u056C", "l"],
      ["\u053C", "L"],
      ["\u056D", "kh"],
      ["\u053D", "Kh"],
      ["\u056E", "ts"],
      ["\u053E", "Ts"],
      ["\u056F", "k"],
      ["\u053F", "K"],
      ["\u0570", "h"],
      ["\u0540", "H"],
      ["\u0571", "dz"],
      ["\u0541", "Dz"],
      ["\u0572", "gh"],
      ["\u0542", "Gh"],
      ["\u0573", "tch"],
      ["\u0543", "Tch"],
      ["\u0574", "m"],
      ["\u0544", "M"],
      ["\u0575", "y"],
      ["\u0545", "Y"],
      ["\u0576", "n"],
      ["\u0546", "N"],
      ["\u0577", "sh"],
      ["\u0547", "Sh"],
      ["\u0578", "vo"],
      ["\u0548", "Vo"],
      ["\u0579", "ch"],
      ["\u0549", "Ch"],
      ["\u057A", "p"],
      ["\u054A", "P"],
      ["\u057B", "j"],
      ["\u054B", "J"],
      ["\u057C", "r"],
      ["\u054C", "R"],
      ["\u057D", "s"],
      ["\u054D", "S"],
      ["\u057E", "v"],
      ["\u054E", "V"],
      ["\u057F", "t"],
      ["\u054F", "T"],
      ["\u0580", "r"],
      ["\u0550", "R"],
      ["\u0581", "c"],
      ["\u0551", "C"],
      ["\u0578\u0582", "u"],
      ["\u0548\u0552", "U"],
      ["\u0548\u0582", "U"],
      ["\u0583", "p"],
      ["\u0553", "P"],
      ["\u0584", "q"],
      ["\u0554", "Q"],
      ["\u0585", "o"],
      ["\u0555", "O"],
      ["\u0586", "f"],
      ["\u0556", "F"],
      ["\u0587", "yev"],
      ["\u10D0", "a"],
      ["\u10D1", "b"],
      ["\u10D2", "g"],
      ["\u10D3", "d"],
      ["\u10D4", "e"],
      ["\u10D5", "v"],
      ["\u10D6", "z"],
      ["\u10D7", "t"],
      ["\u10D8", "i"],
      ["\u10D9", "k"],
      ["\u10DA", "l"],
      ["\u10DB", "m"],
      ["\u10DC", "n"],
      ["\u10DD", "o"],
      ["\u10DE", "p"],
      ["\u10DF", "zh"],
      ["\u10E0", "r"],
      ["\u10E1", "s"],
      ["\u10E2", "t"],
      ["\u10E3", "u"],
      ["\u10E4", "ph"],
      ["\u10E5", "q"],
      ["\u10E6", "gh"],
      ["\u10E7", "k"],
      ["\u10E8", "sh"],
      ["\u10E9", "ch"],
      ["\u10EA", "ts"],
      ["\u10EB", "dz"],
      ["\u10EC", "ts"],
      ["\u10ED", "tch"],
      ["\u10EE", "kh"],
      ["\u10EF", "j"],
      ["\u10F0", "h"],
      ["\u010D", "c"],
      ["\u010F", "d"],
      ["\u011B", "e"],
      ["\u0148", "n"],
      ["\u0159", "r"],
      ["\u0161", "s"],
      ["\u0165", "t"],
      ["\u016F", "u"],
      ["\u017E", "z"],
      ["\u010C", "C"],
      ["\u010E", "D"],
      ["\u011A", "E"],
      ["\u0147", "N"],
      ["\u0158", "R"],
      ["\u0160", "S"],
      ["\u0164", "T"],
      ["\u016E", "U"],
      ["\u017D", "Z"],
      ["\u0780", "h"],
      ["\u0781", "sh"],
      ["\u0782", "n"],
      ["\u0783", "r"],
      ["\u0784", "b"],
      ["\u0785", "lh"],
      ["\u0786", "k"],
      ["\u0787", "a"],
      ["\u0788", "v"],
      ["\u0789", "m"],
      ["\u078A", "f"],
      ["\u078B", "dh"],
      ["\u078C", "th"],
      ["\u078D", "l"],
      ["\u078E", "g"],
      ["\u078F", "gn"],
      ["\u0790", "s"],
      ["\u0791", "d"],
      ["\u0792", "z"],
      ["\u0793", "t"],
      ["\u0794", "y"],
      ["\u0795", "p"],
      ["\u0796", "j"],
      ["\u0797", "ch"],
      ["\u0798", "tt"],
      ["\u0799", "hh"],
      ["\u079A", "kh"],
      ["\u079B", "th"],
      ["\u079C", "z"],
      ["\u079D", "sh"],
      ["\u079E", "s"],
      ["\u079F", "d"],
      ["\u07A0", "t"],
      ["\u07A1", "z"],
      ["\u07A2", "a"],
      ["\u07A3", "gh"],
      ["\u07A4", "q"],
      ["\u07A5", "w"],
      ["\u07A6", "a"],
      ["\u07A7", "aa"],
      ["\u07A8", "i"],
      ["\u07A9", "ee"],
      ["\u07AA", "u"],
      ["\u07AB", "oo"],
      ["\u07AC", "e"],
      ["\u07AD", "ey"],
      ["\u07AE", "o"],
      ["\u07AF", "oa"],
      ["\u07B0", ""],
      ["\u03B1", "a"],
      ["\u03B2", "v"],
      ["\u03B3", "g"],
      ["\u03B4", "d"],
      ["\u03B5", "e"],
      ["\u03B6", "z"],
      ["\u03B7", "i"],
      ["\u03B8", "th"],
      ["\u03B9", "i"],
      ["\u03BA", "k"],
      ["\u03BB", "l"],
      ["\u03BC", "m"],
      ["\u03BD", "n"],
      ["\u03BE", "ks"],
      ["\u03BF", "o"],
      ["\u03C0", "p"],
      ["\u03C1", "r"],
      ["\u03C3", "s"],
      ["\u03C4", "t"],
      ["\u03C5", "y"],
      ["\u03C6", "f"],
      ["\u03C7", "x"],
      ["\u03C8", "ps"],
      ["\u03C9", "o"],
      ["\u03AC", "a"],
      ["\u03AD", "e"],
      ["\u03AF", "i"],
      ["\u03CC", "o"],
      ["\u03CD", "y"],
      ["\u03AE", "i"],
      ["\u03CE", "o"],
      ["\u03C2", "s"],
      ["\u03CA", "i"],
      ["\u03B0", "y"],
      ["\u03CB", "y"],
      ["\u0390", "i"],
      ["\u0391", "A"],
      ["\u0392", "B"],
      ["\u0393", "G"],
      ["\u0394", "D"],
      ["\u0395", "E"],
      ["\u0396", "Z"],
      ["\u0397", "I"],
      ["\u0398", "TH"],
      ["\u0399", "I"],
      ["\u039A", "K"],
      ["\u039B", "L"],
      ["\u039C", "M"],
      ["\u039D", "N"],
      ["\u039E", "KS"],
      ["\u039F", "O"],
      ["\u03A0", "P"],
      ["\u03A1", "R"],
      ["\u03A3", "S"],
      ["\u03A4", "T"],
      ["\u03A5", "Y"],
      ["\u03A6", "F"],
      ["\u03A7", "X"],
      ["\u03A8", "PS"],
      ["\u03A9", "O"],
      ["\u0386", "A"],
      ["\u0388", "E"],
      ["\u038A", "I"],
      ["\u038C", "O"],
      ["\u038E", "Y"],
      ["\u0389", "I"],
      ["\u038F", "O"],
      ["\u03AA", "I"],
      ["\u03AB", "Y"],
      ["\u0101", "a"],
      ["\u0113", "e"],
      ["\u0123", "g"],
      ["\u012B", "i"],
      ["\u0137", "k"],
      ["\u013C", "l"],
      ["\u0146", "n"],
      ["\u016B", "u"],
      ["\u0100", "A"],
      ["\u0112", "E"],
      ["\u0122", "G"],
      ["\u012A", "I"],
      ["\u0136", "K"],
      ["\u013B", "L"],
      ["\u0145", "N"],
      ["\u016A", "U"],
      ["\u010D", "c"],
      ["\u0161", "s"],
      ["\u017E", "z"],
      ["\u010C", "C"],
      ["\u0160", "S"],
      ["\u017D", "Z"],
      ["\u0105", "a"],
      ["\u010D", "c"],
      ["\u0119", "e"],
      ["\u0117", "e"],
      ["\u012F", "i"],
      ["\u0161", "s"],
      ["\u0173", "u"],
      ["\u016B", "u"],
      ["\u017E", "z"],
      ["\u0104", "A"],
      ["\u010C", "C"],
      ["\u0118", "E"],
      ["\u0116", "E"],
      ["\u012E", "I"],
      ["\u0160", "S"],
      ["\u0172", "U"],
      ["\u016A", "U"],
      ["\u040C", "Kj"],
      ["\u045C", "kj"],
      ["\u0409", "Lj"],
      ["\u0459", "lj"],
      ["\u040A", "Nj"],
      ["\u045A", "nj"],
      ["\u0422\u0441", "Ts"],
      ["\u0442\u0441", "ts"],
      ["\u0105", "a"],
      ["\u0107", "c"],
      ["\u0119", "e"],
      ["\u0142", "l"],
      ["\u0144", "n"],
      ["\u015B", "s"],
      ["\u017A", "z"],
      ["\u017C", "z"],
      ["\u0104", "A"],
      ["\u0106", "C"],
      ["\u0118", "E"],
      ["\u0141", "L"],
      ["\u0143", "N"],
      ["\u015A", "S"],
      ["\u0179", "Z"],
      ["\u017B", "Z"],
      ["\u0404", "Ye"],
      ["\u0406", "I"],
      ["\u0407", "Yi"],
      ["\u0490", "G"],
      ["\u0454", "ye"],
      ["\u0456", "i"],
      ["\u0457", "yi"],
      ["\u0491", "g"]
    ];
  }
});

// node_modules/@sindresorhus/transliterate/index.js
var require_transliterate = __commonJS({
  "node_modules/@sindresorhus/transliterate/index.js"(exports, module2) {
    "use strict";
    var deburr = require_lodash();
    var escapeStringRegexp = require_escape_string_regexp2();
    var builtinReplacements = require_replacements();
    var doCustomReplacements = (string, replacements) => {
      for (const [key, value] of replacements) {
        string = string.replace(new RegExp(escapeStringRegexp(key), "g"), value);
      }
      return string;
    };
    module2.exports = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = __spreadValues({
        customReplacements: []
      }, options);
      const customReplacements = new Map([
        ...builtinReplacements,
        ...options.customReplacements
      ]);
      string = string.normalize();
      string = doCustomReplacements(string, customReplacements);
      string = deburr(string);
      return string;
    };
  }
});

// node_modules/@sindresorhus/slugify/overridable-replacements.js
var require_overridable_replacements = __commonJS({
  "node_modules/@sindresorhus/slugify/overridable-replacements.js"(exports, module2) {
    "use strict";
    module2.exports = [
      ["&", " and "],
      ["\u{1F984}", " unicorn "],
      ["\u2665", " love "]
    ];
  }
});

// node_modules/@sindresorhus/slugify/index.js
var require_slugify = __commonJS({
  "node_modules/@sindresorhus/slugify/index.js"(exports, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var transliterate = require_transliterate();
    var builtinOverridableReplacements = require_overridable_replacements();
    var decamelize = (string) => {
      return string.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2");
    };
    var removeMootSeparators = (string, separator) => {
      const escapedSeparator = escapeStringRegexp(separator);
      return string.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
    };
    var slugify2 = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = __spreadValues({
        separator: "-",
        lowercase: true,
        decamelize: true,
        customReplacements: [],
        preserveLeadingUnderscore: false
      }, options);
      const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith("_");
      const customReplacements = new Map([
        ...builtinOverridableReplacements,
        ...options.customReplacements
      ]);
      string = transliterate(string, { customReplacements });
      if (options.decamelize) {
        string = decamelize(string);
      }
      let patternSlug = /[^a-zA-Z\d]+/g;
      if (options.lowercase) {
        string = string.toLowerCase();
        patternSlug = /[^a-z\d]+/g;
      }
      string = string.replace(patternSlug, options.separator);
      string = string.replace(/\\/g, "");
      if (options.separator) {
        string = removeMootSeparators(string, options.separator);
      }
      if (shouldPrependUnderscore) {
        string = `_${string}`;
      }
      return string;
    };
    var counter = () => {
      const occurrences = new Map();
      const countable = (string, options) => {
        string = slugify2(string, options);
        if (!string) {
          return "";
        }
        const stringLower = string.toLowerCase();
        const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, "")) || 0;
        const counter2 = occurrences.get(stringLower);
        occurrences.set(stringLower, typeof counter2 === "number" ? counter2 + 1 : 1);
        const newCounter = occurrences.get(stringLower) || 2;
        if (newCounter >= 2 || numberless > 2) {
          string = `${string}-${newCounter}`;
        }
        return string;
      };
      countable.reset = () => {
        occurrences.clear();
      };
      return countable;
    };
    module2.exports = slugify2;
    module2.exports.counter = counter;
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof require === "function") {
          try {
            crypto = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var getAPI2 = (app) => {
      var _a;
      if (app)
        return (_a = app.plugins.plugins.dataview) === null || _a === void 0 ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled;
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject2(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge2() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge2(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge2({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject: isObject2,
      isPlainObject: isPlainObject2,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge: merge2,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function encode2(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode2(key) + "=" + encode2(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request2, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request2;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/axios/lib/defaults/transitional.js"(exports, module2) {
    "use strict";
    module2.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request2, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request2, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var transitionalDefaults = require_transitional();
    var Cancel = require_Cancel();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request2 = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request2.timeout = config.timeout;
        function onloadend() {
          if (!request2) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders(request2.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
          var response = {
            data: responseData,
            status: request2.status,
            statusText: request2.statusText,
            headers: responseHeaders,
            config,
            request: request2
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request2 = null;
        }
        if ("onloadend" in request2) {
          request2.onloadend = onloadend;
        } else {
          request2.onreadystatechange = function handleLoad() {
            if (!request2 || request2.readyState !== 4) {
              return;
            }
            if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request2.onabort = function handleAbort() {
          if (!request2) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request2));
          request2 = null;
        };
        request2.onerror = function handleError() {
          reject(createError("Network Error", config, null, request2));
          request2 = null;
        };
        request2.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request2));
          request2 = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request2) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request2.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request2.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request2.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request2.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request2.upload) {
          request2.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request2) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request2.abort();
            request2 = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request2.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults/index.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var transitionalDefaults = require_transitional();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge2 = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge2(prop);
        utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module2) {
    module2.exports = {
      "version": "0.26.1"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module2) {
    "use strict";
    var VERSION6 = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION6 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request2(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module2.exports = axios2;
    module2.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module2) {
    module2.exports = require_axios();
  }
});

// main.ts
__export(exports, {
  default: () => DigitalGarden
});
var import_obsidian5 = __toModule(require("obsidian"));

// src/Publisher.ts
var import_obsidian2 = __toModule(require("obsidian"));

// node_modules/js-base64/base64.mjs
var version = "3.7.2";
var VERSION = version;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI2 = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a), (c) => c.charCodeAt(0));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// node_modules/universal-user-agent/dist-web/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/core/dist-web/index.js
var import_before_after_hook = __toModule(require_before_after_hook());

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false)
    return false;
  ctor = o.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/@octokit/endpoint/dist-web/index.js
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (defaults && defaults.mediaType.previews.length) {
    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
  }
  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
}
function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (options.mediaType.previews.length) {
      const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
        const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
        return `application/vnd.github.${preview}-preview${format}`;
      }).join(",");
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      } else {
        headers["content-length"] = 0;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var VERSION2 = "6.0.12";
var userAgent = `octokit-endpoint.js/${VERSION2} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: "",
    previews: []
  }
};
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/dist-web/index.js
var import_node_fetch = __toModule(require_browser());

// node_modules/deprecation/dist-web/index.js
var Deprecation = class extends Error {
  constructor(message) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "Deprecation";
  }
};

// node_modules/@octokit/request-error/dist-web/index.js
var import_once = __toModule(require_once());
var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(new Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(new Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
        return headers || {};
      }
    });
  }
};

// node_modules/@octokit/request/dist-web/index.js
var VERSION3 = "5.6.3";
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  const fetch = requestOptions.request && requestOptions.request.fetch || import_node_fetch.default;
  return fetch(requestOptions.url, Object.assign({
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    redirect: requestOptions.redirect
  }, requestOptions.request)).then((response) => __async(this, null, function* () {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: yield getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = yield getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return getResponseData(response);
  })).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    throw new RequestError(error.message, 500, {
      request: requestOptions
    });
  });
}
function getResponseData(response) {
  return __async(this, null, function* () {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
      return response.json();
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }
    return getBufferResponse(response);
  });
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
    }
    return data.message;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION3} ${getUserAgent()}`
  }
});

// node_modules/@octokit/graphql/dist-web/index.js
var VERSION4 = "4.8.0";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError";
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request$1, newDefaults) {
  const newRequest = request$1.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: request.endpoint
  });
}
var graphql$1 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION4} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-web/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
function auth(token) {
  return __async(this, null, function* () {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
      type: "token",
      token,
      tokenType
    };
  });
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
function hook(token, request2, route, parameters) {
  return __async(this, null, function* () {
    const endpoint2 = request2.endpoint.merge(route, parameters);
    endpoint2.headers.authorization = withAuthorizationPrefix(token);
    return request2(endpoint2);
  });
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-web/index.js
var VERSION5 = "3.6.0";
var Octokit = class {
  constructor(options = {}) {
    const hook2 = new import_before_after_hook.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = [
      options.userAgent,
      `octokit-core.js/${VERSION5} ${getUserAgent()}`
    ].filter(Boolean).join(" ");
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: () => {
      },
      info: () => {
      },
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    }, options.log);
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = () => __async(this, null, function* () {
          return {
            type: "unauthenticated"
          };
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const _a = options, { authStrategy } = _a, otherOptions = __objRest(_a, ["authStrategy"]);
      const auth2 = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth));
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    classConstructor.plugins.forEach((plugin) => {
      Object.assign(this, plugin(this, options));
    });
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }
    };
    return OctokitWithDefaults;
  }
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))), _a);
    return NewOctokit;
  }
};
Octokit.VERSION = VERSION5;
Octokit.plugins = [];

// src/utils.ts
var import_slugify = __toModule(require_slugify());
var import_sha1 = __toModule(require_sha1());
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return gBase64.btoa(binary);
}
function extractBaseUrl(url) {
  return url && url.replace("https://", "").replace("http://", "").replace(/\/$/, "");
}
function generateUrlPath(filePath) {
  if (!filePath) {
    return filePath;
  }
  const extensionLess = filePath.substring(0, filePath.lastIndexOf("."));
  const noteUrlPath = extensionLess.split("/").map((x) => (0, import_slugify.default)(x)).join("/") + "/";
  return noteUrlPath;
}
function generateBlobHash(content) {
  const byteLength = new TextEncoder().encode(content).byteLength;
  const header = `blob ${byteLength}\0`;
  const gitBlob = header + content;
  return (0, import_sha1.default)(gitBlob).toString();
}
function kebabize(str) {
  return str.split("").map((letter, idx) => {
    return letter.toUpperCase() === letter ? `${idx !== 0 ? "-" : ""}${letter.toLowerCase()}` : letter;
  }).join("");
}

// src/Validator.ts
var import_obsidian = __toModule(require("obsidian"));
function vallidatePublishFrontmatter(frontMatter) {
  if (!frontMatter || !frontMatter["dg-publish"]) {
    new import_obsidian.Notice("Note does not have the dg-publish: true set. Please add this and try again.");
    return false;
  }
  return true;
}

// src/constants.ts
var seedling = `<g style="pointer-events:all"><title style="pointer-events: none" opacity="0.33">Layer 1</title><g id="hair" style="pointer-events: none" opacity="0.33"></g><g id="skin" style="pointer-events: none" opacity="0.33"></g><g id="skin-shadow" style="pointer-events: none" opacity="0.33"></g><g id="line"><path fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2" d="M47.71119,35.9247" id="svg_3"></path><polyline fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" points="49.813106536865234,93.05191133916378 49.813106536865234,69.57996462285519 40.03312683105469,26.548054680228233 " id="svg_4"></polyline><line x1="49.81311" x2="59.59309" y1="69.57996" y2="50.02" fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" id="svg_5"></line><path fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M27.99666,14.21103C35.9517,16.94766 39.92393,26.36911 39.92393,26.36911S30.99696,31.3526 23.04075,28.61655S11.11348,16.45847 11.11348,16.45847S20.04456,11.4789 27.99666,14.21103z" id="svg_6"></path><path fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M76.46266698455811,45.61669603088379 C84.67706698455811,47.43146603088379 89.6945869845581,56.34024603088379 89.6945869845581,56.34024603088379 S81.3917769845581,62.30603603088379 73.17639698455811,60.492046030883785 S59.94447698455811,49.768496030883796 59.94447698455811,49.768496030883796 S68.2515869845581,43.80622603088379 76.46266698455811,45.61669603088379 z" id="svg_7"></path></g></g>`;
var excaliDrawBundle = `<style>
.container {font-family: sans-serif; text-align: center;}
.button-wrapper button {z-index: 1;height: 40px; width: 100px; margin: 10px;padding: 5px;}
.excalidraw .App-menu_top .buttonList { display: flex;}
.excalidraw-wrapper { height: 800px; margin: 50px; position: relative;}
:root[dir="ltr"] .excalidraw .layer-ui__wrapper .zen-mode-transition.App-menu_bottom--transition-left {transform: none;}
</style><script src="https://unpkg.com/react@17/umd/react.production.min.js"><\/script><script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"><\/script><script type="text/javascript" src="https://unpkg.com/@excalidraw/excalidraw@0.12.0/dist/excalidraw.production.min.js"><\/script>`;
var excalidraw = (excaliDrawJson, drawingId) => `<div id="${drawingId}"></div><script>(function(){const InitialData=${excaliDrawJson};InitialData.scrollToContent=true;App=()=>{const e=React.useRef(null),t=React.useRef(null),[n,i]=React.useState({width:void 0,height:void 0});return React.useEffect(()=>{i({width:t.current.getBoundingClientRect().width,height:t.current.getBoundingClientRect().height});const e=()=>{i({width:t.current.getBoundingClientRect().width,height:t.current.getBoundingClientRect().height})};return window.addEventListener("resize",e),()=>window.removeEventListener("resize",e)},[t]),React.createElement(React.Fragment,null,React.createElement("div",{className:"excalidraw-wrapper",ref:t},React.createElement(ExcalidrawLib.Excalidraw,{ref:e,width:n.width,height:n.height,initialData:InitialData,viewModeEnabled:!0,zenModeEnabled:!0,gridModeEnabled:!1})))},excalidrawWrapper=document.getElementById("${drawingId}");ReactDOM.render(React.createElement(App),excalidrawWrapper);})();<\/script>`;

// src/Publisher.ts
var import_obsidian_dataview = __toModule(require_lib());
var Publisher = class {
  constructor(vault, metadataCache, settings) {
    this.frontmatterRegex = /^\s*?---\n([\s\S]*?)\n---/g;
    this.codeFenceRegex = /`(.*?)`/g;
    this.codeBlockRegex = /```.*?\n[\s\S]+?```/g;
    this.excaliDrawRegex = /:\[\[(\d*?,\d*?)\],.*?\]\]/g;
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.settings = settings;
  }
  getFilesMarkedForPublishing() {
    return __async(this, null, function* () {
      const files = this.vault.getMarkdownFiles();
      const filesToPublish = [];
      for (const file of files) {
        try {
          const frontMatter = this.metadataCache.getCache(file.path).frontmatter;
          if (frontMatter && frontMatter["dg-publish"] === true) {
            filesToPublish.push(file);
          }
        } catch (e) {
        }
      }
      return filesToPublish;
    });
  }
  delete(vaultFilePath) {
    return __async(this, null, function* () {
      if (!this.settings.githubRepo) {
        new import_obsidian2.Notice("Config error: You need to define a GitHub repo in the plugin settings");
        throw {};
      }
      if (!this.settings.githubUserName) {
        new import_obsidian2.Notice("Config error: You need to define a GitHub Username in the plugin settings");
        throw {};
      }
      if (!this.settings.githubToken) {
        new import_obsidian2.Notice("Config error: You need to define a GitHub Token in the plugin settings");
        throw {};
      }
      const octokit = new Octokit({ auth: this.settings.githubToken });
      const path = `src/site/notes/${vaultFilePath}`;
      const payload = {
        owner: this.settings.githubUserName,
        repo: this.settings.githubRepo,
        path,
        message: `Delete note ${vaultFilePath}`,
        sha: ""
      };
      try {
        const response = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: this.settings.githubUserName,
          repo: this.settings.githubRepo,
          path
        });
        if (response.status === 200 && response.data.type === "file") {
          payload.sha = response.data.sha;
        }
      } catch (e) {
        console.log(e);
        return false;
      }
      try {
        const response = yield octokit.request("DELETE /repos/{owner}/{repo}/contents/{path}", payload);
      } catch (e) {
        console.log(e);
        return false;
      }
      return true;
    });
  }
  publish(file) {
    return __async(this, null, function* () {
      if (!vallidatePublishFrontmatter(this.metadataCache.getCache(file.path).frontmatter)) {
        return false;
      }
      try {
        const text = yield this.generateMarkdown(file);
        yield this.uploadText(file.path, text);
        return true;
      } catch (e) {
        return false;
      }
    });
  }
  generateMarkdown(file) {
    return __async(this, null, function* () {
      if (file.name.endsWith(".excalidraw.md")) {
        return yield this.generateExcalidrawMarkdown(file, true);
      }
      let text = yield this.vault.cachedRead(file);
      text = yield this.convertFrontMatter(text, file.path);
      text = yield this.createTranscludedText(text, file.path, 0);
      text = yield this.convertDataViews(text, file.path);
      text = yield this.convertLinksToFullPath(text, file.path);
      text = yield this.removeObsidianComments(text);
      text = yield this.createSvgEmbeds(text, file.path);
      text = yield this.createBase64Images(text, file.path);
      return text;
    });
  }
  uploadText(filePath, content) {
    return __async(this, null, function* () {
      if (!this.settings.githubRepo) {
        new import_obsidian2.Notice("Config error: You need to define a GitHub repo in the plugin settings");
        throw {};
      }
      if (!this.settings.githubUserName) {
        new import_obsidian2.Notice("Config error: You need to define a GitHub Username in the plugin settings");
        throw {};
      }
      if (!this.settings.githubToken) {
        new import_obsidian2.Notice("Config error: You need to define a GitHub Token in the plugin settings");
        throw {};
      }
      const octokit = new Octokit({ auth: this.settings.githubToken });
      const base64Content = gBase64.encode(content);
      const path = `src/site/notes/${filePath}`;
      const payload = {
        owner: this.settings.githubUserName,
        repo: this.settings.githubRepo,
        path,
        message: `Add note ${filePath}`,
        content: base64Content,
        sha: ""
      };
      try {
        const response = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: this.settings.githubUserName,
          repo: this.settings.githubRepo,
          path
        });
        if (response.status === 200 && response.data.type === "file") {
          payload.sha = response.data.sha;
        }
      } catch (e) {
        console.log(e);
      }
      payload.message = `Update note ${filePath}`;
      yield octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", payload);
    });
  }
  stripAwayCodeFences(text) {
    let textToBeProcessed = text;
    textToBeProcessed = textToBeProcessed.replace(this.excaliDrawRegex, "");
    textToBeProcessed = textToBeProcessed.replace(this.codeBlockRegex, "");
    textToBeProcessed = textToBeProcessed.replace(this.codeFenceRegex, "");
    return textToBeProcessed;
  }
  removeObsidianComments(text) {
    return __async(this, null, function* () {
      const textToBeProcessed = this.stripAwayCodeFences(text);
      const obsidianCommentsRegex = /%%.+?%%/gms;
      const obsidianCommentsMatches = textToBeProcessed.match(obsidianCommentsRegex);
      if (obsidianCommentsMatches) {
        for (const commentMatch of obsidianCommentsMatches) {
          text = text.replace(commentMatch, "");
        }
      }
      return text;
    });
  }
  convertFrontMatter(text, path) {
    return __async(this, null, function* () {
      const publishedFrontMatter = this.getProcessedFrontMatter(path);
      const replaced = text.replace(this.frontmatterRegex, (match, p1) => {
        return publishedFrontMatter;
      });
      return replaced;
    });
  }
  convertDataViews(text, path) {
    return __async(this, null, function* () {
      let replacedText = text;
      const dataViewRegex = /```dataview(.+?)```/gsm;
      const dvApi = (0, import_obsidian_dataview.getAPI)();
      const matches = text.matchAll(dataViewRegex);
      if (!matches)
        return;
      for (const queryBlock of matches) {
        try {
          const block = queryBlock[0];
          const query = queryBlock[1];
          const markdown = yield dvApi.tryQueryMarkdown(query, path);
          replacedText = replacedText.replace(block, markdown);
        } catch (e) {
          console.log(e);
          new import_obsidian2.Notice("Unable to render dataview query. Please update the dataview plugin to the latest version.");
          return queryBlock[0];
        }
      }
      return replacedText;
    });
  }
  getProcessedFrontMatter(filePath) {
    const fileFrontMatter = __spreadValues({}, this.metadataCache.getCache(filePath).frontmatter);
    delete fileFrontMatter["position"];
    let publishedFrontMatter = { "dg-publish": true };
    publishedFrontMatter = this.addPermalink(fileFrontMatter, publishedFrontMatter, filePath);
    publishedFrontMatter = this.addHomePageTag(fileFrontMatter, publishedFrontMatter);
    publishedFrontMatter = this.addFrontMatterSettings(fileFrontMatter, publishedFrontMatter);
    const fullFrontMatter = (publishedFrontMatter == null ? void 0 : publishedFrontMatter.dgPassFrontmatter) ? __spreadValues(__spreadValues({}, fileFrontMatter), publishedFrontMatter) : publishedFrontMatter;
    const frontMatterString = JSON.stringify(fullFrontMatter);
    return `---
${frontMatterString}
---
`;
  }
  addPermalink(baseFrontMatter, newFrontMatter, filePath) {
    let publishedFrontMatter = __spreadValues({}, newFrontMatter);
    if (baseFrontMatter && baseFrontMatter["dg-permalink"]) {
      publishedFrontMatter["dg-permalink"] = baseFrontMatter["dg-permalink"];
      publishedFrontMatter["permalink"] = baseFrontMatter["dg-permalink"];
      if (!publishedFrontMatter["permalink"].endsWith("/")) {
        publishedFrontMatter["permalink"] += "/";
      }
      if (!publishedFrontMatter["permalink"].startsWith("/")) {
        publishedFrontMatter["permalink"] = "/" + publishedFrontMatter["permalink"];
      }
    } else {
      const noteUrlPath = generateUrlPath(filePath);
      publishedFrontMatter["permalink"] = "/" + noteUrlPath;
    }
    return publishedFrontMatter;
  }
  addHomePageTag(baseFrontMatter, newFrontMatter) {
    const publishedFrontMatter = __spreadValues({}, newFrontMatter);
    if (baseFrontMatter && baseFrontMatter["dg-home"]) {
      const tags = baseFrontMatter["tags"];
      if (tags) {
        if (typeof tags === "string") {
          publishedFrontMatter["tags"] = [tags, "gardenEntry"];
        } else {
          publishedFrontMatter["tags"] = [...tags, "gardenEntry"];
        }
      } else {
        publishedFrontMatter["tags"] = "gardenEntry";
      }
    }
    return publishedFrontMatter;
  }
  addFrontMatterSettings(baseFrontMatter, newFrontMatter) {
    if (!baseFrontMatter) {
      baseFrontMatter = {};
    }
    const publishedFrontMatter = __spreadValues({}, newFrontMatter);
    for (const key of Object.keys(this.settings.defaultNoteSettings)) {
      if (baseFrontMatter[kebabize(key)] !== void 0) {
        publishedFrontMatter[key] = baseFrontMatter[kebabize(key)];
      } else {
        publishedFrontMatter[key] = this.settings.defaultNoteSettings[key];
      }
    }
    return publishedFrontMatter;
  }
  convertLinksToFullPath(text, filePath) {
    return __async(this, null, function* () {
      let convertedText = text;
      const textToBeProcessed = this.stripAwayCodeFences(text);
      const linkedFileRegex = /\[\[(.*?)\]\]/g;
      const linkedFileMatches = textToBeProcessed.match(linkedFileRegex);
      if (linkedFileMatches) {
        for (const linkMatch of linkedFileMatches) {
          try {
            const textInsideBrackets = linkMatch.substring(linkMatch.indexOf("[") + 2, linkMatch.lastIndexOf("]") - 1);
            let [linkedFileName, prettyName] = textInsideBrackets.split("|");
            prettyName = prettyName || linkedFileName;
            let headerPath = "";
            if (linkedFileName.includes("#")) {
              const headerSplit = linkedFileName.split("#");
              linkedFileName = headerSplit[0];
              headerPath = headerSplit.length > 1 ? `#${headerSplit[1]}` : "";
            }
            const fullLinkedFilePath = (0, import_obsidian2.getLinkpath)(linkedFileName);
            const linkedFile = this.metadataCache.getFirstLinkpathDest(fullLinkedFilePath, filePath);
            if (!linkedFile) {
              convertedText = convertedText.replace(linkMatch, `[[${linkedFileName}${headerPath}|${prettyName}]]`);
            }
            if ((linkedFile == null ? void 0 : linkedFile.extension) === "md") {
              const extensionlessPath = linkedFile.path.substring(0, linkedFile.path.lastIndexOf("."));
              convertedText = convertedText.replace(linkMatch, `[[${extensionlessPath}${headerPath}|${prettyName}]]`);
            }
          } catch (e) {
            console.log(e);
            continue;
          }
        }
      }
      return convertedText;
    });
  }
  createTranscludedText(text, filePath, currentDepth) {
    return __async(this, null, function* () {
      if (currentDepth >= 4) {
        return text;
      }
      let transcludedText = text;
      const transcludedRegex = /!\[\[(.*?)\]\]/g;
      const transclusionMatches = text.match(transcludedRegex);
      let numberOfExcaliDraws = 0;
      if (transclusionMatches) {
        for (let i = 0; i < transclusionMatches.length; i++) {
          try {
            const transclusionMatch = transclusionMatches[i];
            let [tranclusionFileName, headerName] = transclusionMatch.substring(transclusionMatch.indexOf("[") + 2, transclusionMatch.indexOf("]")).split("|");
            const tranclusionFilePath = (0, import_obsidian2.getLinkpath)(tranclusionFileName);
            const linkedFile = this.metadataCache.getFirstLinkpathDest(tranclusionFilePath, filePath);
            if (linkedFile.name.endsWith(".excalidraw.md")) {
              let firstDrawing = ++numberOfExcaliDraws === 1;
              const excaliDrawCode = yield this.generateExcalidrawMarkdown(linkedFile, firstDrawing, `${numberOfExcaliDraws}`, false);
              transcludedText = transcludedText.replace(transclusionMatch, excaliDrawCode);
            } else if (linkedFile.extension === "md") {
              let fileText = yield this.vault.cachedRead(linkedFile);
              fileText = fileText.replace(this.frontmatterRegex, "");
              const header = this.generateTransclusionHeader(headerName, linkedFile);
              const headerSection = header ? `${header}
` : "";
              fileText = `
<div class="transclusion internal-embed is-loaded"><div class="markdown-embed">

<div class="markdown-embed-title">

${headerSection}

</div>

` + fileText + "\n\n</div></div>\n";
              if (fileText.match(transcludedRegex)) {
                fileText = yield this.createTranscludedText(fileText, linkedFile.path, currentDepth + 1);
              }
              transcludedText = transcludedText.replace(transclusionMatch, fileText);
            }
          } catch (e) {
            continue;
          }
        }
      }
      return transcludedText;
    });
  }
  createSvgEmbeds(text, filePath) {
    return __async(this, null, function* () {
      const transcludedSvgRegex = /!\[\[(.*?)(\.(svg))\|(.*?)\]\]|!\[\[(.*?)(\.(svg))\]\]/g;
      const transcludedSvgs = text.match(transcludedSvgRegex);
      if (transcludedSvgs) {
        for (const svg of transcludedSvgs) {
          try {
            let [imageName, size] = svg.substring(svg.indexOf("[") + 2, svg.indexOf("]")).split("|");
            const imagePath = (0, import_obsidian2.getLinkpath)(imageName);
            const linkedFile = this.metadataCache.getFirstLinkpathDest(imagePath, filePath);
            const svgText = yield this.vault.read(linkedFile);
            text = text.replace(svg, svgText);
          } catch (e) {
            continue;
          }
        }
      }
      const linkedSvgRegex = /!\[(.*?)\]\((.*?)(\.(svg))\)/g;
      const linkedSvgMatches = text.match(linkedSvgRegex);
      if (linkedSvgMatches) {
        for (const svg of linkedSvgMatches) {
          try {
            let pathStart = svg.lastIndexOf("(") + 1;
            let pathEnd = svg.lastIndexOf(")");
            let imagePath = svg.substring(pathStart, pathEnd);
            if (imagePath.startsWith("http")) {
              continue;
            }
            const linkedFile = this.metadataCache.getFirstLinkpathDest(imagePath, filePath);
            const svgText = yield this.vault.read(linkedFile);
            text = text.replace(svg, svgText);
          } catch (e) {
            continue;
          }
        }
      }
      return text;
    });
  }
  createBase64Images(text, filePath) {
    return __async(this, null, function* () {
      function getExtension(linkedFile) {
        if (linkedFile.extension === "jpg" || linkedFile.extension === "jpeg")
          return "png";
        return linkedFile.extension;
      }
      let imageText = text;
      const transcludedImageRegex = /!\[\[(.*?)(\.(png|jpg|jpeg|gif))\|(.*?)\]\]|!\[\[(.*?)(\.(png|jpg|jpeg|gif))\]\]/g;
      const transcludedImageMatches = text.match(transcludedImageRegex);
      if (transcludedImageMatches) {
        for (let i = 0; i < transcludedImageMatches.length; i++) {
          try {
            const imageMatch = transcludedImageMatches[i];
            let [imageName, size] = imageMatch.substring(imageMatch.indexOf("[") + 2, imageMatch.indexOf("]")).split("|");
            const imagePath = (0, import_obsidian2.getLinkpath)(imageName);
            const linkedFile = this.metadataCache.getFirstLinkpathDest(imagePath, filePath);
            const image = yield this.vault.readBinary(linkedFile);
            const imageBase64 = arrayBufferToBase64(image);
            const name = size ? `${imageName}|${size}` : imageName;
            const imageMarkdown = `![${name}](data:image/${getExtension(linkedFile)};base64,${imageBase64})`;
            imageText = imageText.replace(imageMatch, imageMarkdown);
          } catch (e) {
            continue;
          }
        }
      }
      const imageRegex = /!\[(.*?)\]\((.*?)(\.(png|jpg|jpeg|gif))\)/g;
      const imageMatches = text.match(imageRegex);
      if (imageMatches) {
        for (let i = 0; i < imageMatches.length; i++) {
          try {
            const imageMatch = imageMatches[i];
            let nameStart = imageMatch.indexOf("[") + 1;
            let nameEnd = imageMatch.indexOf("]");
            let imageName = imageMatch.substring(nameStart, nameEnd);
            let pathStart = imageMatch.lastIndexOf("(") + 1;
            let pathEnd = imageMatch.lastIndexOf(")");
            let imagePath = imageMatch.substring(pathStart, pathEnd);
            if (imagePath.startsWith("http")) {
              continue;
            }
            const linkedFile = this.metadataCache.getFirstLinkpathDest(imagePath, filePath);
            const image = yield this.vault.readBinary(linkedFile);
            const imageBase64 = arrayBufferToBase64(image);
            const imageMarkdown = `![${imageName}](data:image/${getExtension(linkedFile)};base64,${imageBase64})`;
            imageText = imageText.replace(imageMatch, imageMarkdown);
          } catch (e) {
            continue;
          }
        }
      }
      return imageText;
    });
  }
  generateTransclusionHeader(headerName, transcludedFile) {
    if (!headerName) {
      return headerName;
    }
    const titleVariable = "{{title}}";
    if (headerName && headerName.indexOf(titleVariable) > -1) {
      headerName = headerName.replace(titleVariable, transcludedFile.basename);
    }
    if (headerName && !headerName.startsWith("#")) {
      headerName = "# " + headerName;
    } else if (headerName) {
      const headerParts = headerName.split("#");
      if (!headerParts.last().startsWith(" ")) {
        headerName = headerName.replace(headerParts.last(), " " + headerParts.last());
      }
    }
    return headerName;
  }
  generateExcalidrawMarkdown(file, includeExcaliDrawJs, idAppendage = "", includeFrontMatter = true) {
    return __async(this, null, function* () {
      if (!file.name.endsWith(".excalidraw.md"))
        return "";
      const fileText = yield this.vault.cachedRead(file);
      const frontMatter = yield this.getProcessedFrontMatter(file.path);
      const start = fileText.indexOf("```json") + "```json".length;
      const end = fileText.lastIndexOf("```");
      const excaliDrawJson = JSON.parse(fileText.slice(start, end));
      const drawingId = file.name.split(" ").join("_").replace(".", "") + idAppendage;
      let excaliDrawCode = "";
      if (includeExcaliDrawJs) {
        excaliDrawCode += excaliDrawBundle;
      }
      excaliDrawCode += excalidraw(JSON.stringify(excaliDrawJson), drawingId);
      return `${includeFrontMatter ? frontMatter : ""}${excaliDrawCode}`;
    });
  }
};

// src/DigitalGardenSiteManager.ts
var DigitalGardenSiteManager = class {
  constructor(metadataCache, settings) {
    this.settings = settings;
    this.metadataCache = metadataCache;
  }
  getNoteUrl(file) {
    const baseUrl = this.settings.gardenBaseUrl ? `https://${extractBaseUrl(this.settings.gardenBaseUrl)}` : `https://${this.settings.githubRepo}.netlify.app`;
    const noteUrlPath = generateUrlPath(file.path);
    let urlPath = `/${noteUrlPath}`;
    const frontMatter = this.metadataCache.getCache(file.path).frontmatter;
    if (frontMatter && frontMatter["dg-home"] === true) {
      urlPath = "/";
    } else if (frontMatter && frontMatter.permalink) {
      urlPath = `/${frontMatter.permalink}`;
    } else if (frontMatter && frontMatter["dg-permalink"]) {
      urlPath = `/${frontMatter["dg-permalink"]}`;
    }
    return `${baseUrl}${urlPath}`;
  }
  getNoteHashes() {
    return __async(this, null, function* () {
      const octokit = new Octokit({ auth: this.settings.githubToken });
      const response = yield octokit.request(`GET /repos/{owner}/{repo}/git/trees/{tree_sha}?recursive=${Math.ceil(Math.random() * 1e3)}`, {
        owner: this.settings.githubUserName,
        repo: this.settings.githubRepo,
        tree_sha: "main"
      });
      const files = response.data.tree;
      const notes = files.filter((x) => x.path.startsWith("src/site/notes/") && x.type === "blob" && x.path !== "src/site/notes/notes.json");
      const hashes = {};
      for (const note of notes) {
        const vaultPath = note.path.replace("src/site/notes/", "");
        hashes[vaultPath] = note.sha;
      }
      return hashes;
    });
  }
  createPullRequestWithSiteChanges() {
    return __async(this, null, function* () {
      const octokit = new Octokit({ auth: this.settings.githubToken });
      const latestRelease = yield octokit.request("GET /repos/{owner}/{repo}/releases/latest", {
        owner: "oleeskild",
        repo: "digitalgarden"
      });
      const templateVersion = latestRelease.data.tag_name;
      const branchName = "update-template-to-v" + templateVersion;
      const latestCommit = yield octokit.request("GET /repos/{owner}/{repo}/commits/main", {
        owner: this.settings.githubUserName,
        repo: this.settings.githubRepo
      });
      yield this.createNewBranch(octokit, branchName, latestCommit.data.sha);
      yield this.deleteFiles(octokit, branchName);
      yield this.addFilesIfMissing(octokit, branchName);
      yield this.modifyFiles(octokit, branchName);
      const prUrl = yield this.createPullRequest(octokit, branchName, templateVersion);
      return prUrl;
    });
  }
  createPullRequest(octokit, branchName, templateVersion) {
    return __async(this, null, function* () {
      try {
        const pr = yield octokit.request("POST /repos/{owner}/{repo}/pulls", {
          owner: this.settings.githubUserName,
          repo: this.settings.githubRepo,
          title: `Update template to version ${templateVersion}`,
          head: branchName,
          base: "main",
          body: `Update to latest template version.
 [Release Notes](https://github.com/oleeskild/digitalgarden/releases/tag/${templateVersion})`
        });
        return pr.data.html_url;
      } catch (e) {
        return null;
      }
    });
  }
  deleteFiles(octokit, branchName) {
    return __async(this, null, function* () {
      const filesToDelete = [
        "src/site/styles/style.css"
      ];
      for (const file of filesToDelete) {
        try {
          const latestFile = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
            owner: this.settings.githubUserName,
            repo: this.settings.githubRepo,
            path: file,
            ref: branchName
          });
          yield octokit.request("DELETE /repos/{owner}/{repo}/contents/{path}", {
            owner: this.settings.githubUserName,
            repo: this.settings.githubRepo,
            path: file,
            sha: latestFile.data.sha,
            message: `Delete ${file}`,
            branch: branchName
          });
        } catch (e) {
        }
      }
    });
  }
  modifyFiles(octokit, branchName) {
    return __async(this, null, function* () {
      var _a;
      const filesToModify = [
        ".eleventy.js",
        "README.md",
        "netlify.toml",
        "package-lock.json",
        "package.json",
        "src/site/404.njk",
        "src/site/index.njk",
        "src/site/index.11tydata.js",
        "src/site/versionednote.njk",
        "src/site/styles/style.scss",
        "src/site/styles/digital-garden-base.scss",
        "src/site/styles/obsidian-base.scss",
        "src/site/notes/notes.json",
        "src/site/notes/notes.11tydata.js",
        "src/site/_includes/layouts/note.njk",
        "src/site/_includes/layouts/versionednote.njk",
        "src/site/_includes/components/notegrowthhistory.njk",
        "src/site/_includes/components/pageheader.njk",
        "src/site/_includes/components/sidebar.njk",
        "src/site/_includes/components/graphScript.njk",
        "src/site/_data/versionednotes.js",
        "src/site/_data/meta.js",
        "src/site/img/outgoing.svg"
      ];
      for (const file of filesToModify) {
        const latestFile = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: "oleeskild",
          repo: "digitalgarden",
          path: file
        });
        let currentFile = {};
        let fileExists = true;
        try {
          currentFile = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
            owner: this.settings.githubUserName,
            repo: this.settings.githubRepo,
            path: file,
            ref: branchName
          });
        } catch (error) {
          fileExists = false;
        }
        const fileHasChanged = latestFile.data.sha !== ((_a = currentFile == null ? void 0 : currentFile.data) == null ? void 0 : _a.sha);
        if (!fileExists || fileHasChanged) {
          yield octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", {
            owner: this.settings.githubUserName,
            repo: this.settings.githubRepo,
            path: file,
            branch: branchName,
            message: `Update file ${file}`,
            content: latestFile.data.content,
            sha: fileExists ? currentFile.data.sha : null
          });
        }
      }
    });
  }
  createNewBranch(octokit, branchName, sha) {
    return __async(this, null, function* () {
      try {
        const branch = yield octokit.request("POST /repos/{owner}/{repo}/git/refs", {
          owner: this.settings.githubUserName,
          repo: this.settings.githubRepo,
          ref: `refs/heads/${branchName}`,
          sha
        });
      } catch (e) {
      }
    });
  }
  addFilesIfMissing(octokit, branchName) {
    return __async(this, null, function* () {
      const filesToAdd = [
        "src/site/styles/custom-style.scss",
        ".env",
        "src/site/favicon.svg"
      ];
      for (const filePath of filesToAdd) {
        try {
          yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
            owner: this.settings.githubUserName,
            repo: this.settings.githubRepo,
            path: filePath,
            ref: branchName
          });
        } catch (e) {
          const initialFile = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
            owner: "oleeskild",
            repo: "digitalgarden",
            path: filePath
          });
          yield octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", {
            owner: this.settings.githubUserName,
            repo: this.settings.githubRepo,
            path: filePath,
            branch: branchName,
            message: "Update template file",
            content: initialFile.data.content
          });
        }
      }
    });
  }
};

// src/SettingView.ts
var import_obsidian3 = __toModule(require("obsidian"));
var import_axios = __toModule(require_axios2());
var SettingView = class {
  constructor(app, settingsRootElement, settings, saveSettings) {
    this.app = app;
    this.settingsRootElement = settingsRootElement;
    this.settings = settings;
    this.saveSettings = saveSettings;
  }
  initialize(prModal) {
    return __async(this, null, function* () {
      this.settingsRootElement.empty();
      this.settingsRootElement.createEl("h2", { text: "Settings " });
      this.settingsRootElement.createEl("span", { text: "Remember to read the setup guide if you haven't already. It can be found " });
      this.settingsRootElement.createEl("a", { text: "here.", href: "https://github.com/oleeskild/Obsidian-Digital-Garden" });
      this.initializeGitHubRepoSetting();
      this.initializeGitHubUserNameSetting();
      this.initializeGitHubTokenSetting();
      this.initializeGitHubBaseURLSetting();
      this.initializeRibbonIconSetting();
      this.initializeDefaultNoteSettings();
      this.initializeThemesSettings();
      prModal.titleEl.createEl("h1", "Site template settings");
    });
  }
  initializeDefaultNoteSettings() {
    return __async(this, null, function* () {
      const noteSettingsModal = new import_obsidian3.Modal(this.app);
      noteSettingsModal.titleEl.createEl("h1", { text: "Note Settings" });
      new import_obsidian3.Setting(this.settingsRootElement).setName("Note Settings").setDesc(`Default settings for each published note. These can be overwritten per note via frontmatter. 
            Note: After changing any of these settings, you must re-publish notes for it to take effect. They will appear in the "Changed" list in the publication center.`).addButton((cb) => {
        cb.setButtonText("Edit");
        cb.onClick(() => __async(this, null, function* () {
          noteSettingsModal.open();
        }));
      });
      new import_obsidian3.Setting(noteSettingsModal.contentEl).setName("Show home link (dg-home-link)").setDesc("Determines whether to show a link back to the homepage or not.").addToggle((t) => {
        t.setValue(this.settings.defaultNoteSettings.dgHomeLink);
        t.onChange((val) => {
          this.settings.defaultNoteSettings.dgHomeLink = val;
          this.saveSettings();
        });
      });
      new import_obsidian3.Setting(noteSettingsModal.contentEl).setName("Let all frontmatter through (dg-pass-frontmatter)").setDesc("Determines whether to let all frontmatter data through to the site template. Be aware that this could break your site if you have data in a format not recognized by the template engine, 11ty.").addToggle((t) => {
        t.setValue(this.settings.defaultNoteSettings.dgPassFrontmatter);
        t.onChange((val) => {
          this.settings.defaultNoteSettings.dgPassFrontmatter = val;
          this.saveSettings();
        });
      });
      new import_obsidian3.Setting(noteSettingsModal.contentEl).setName("Show backlinks for notes (dg-show-backlinks)").setDesc("When turned on, notes will show backlinks in a sidebar on desktop and at the bottom of the page on mobile.").addToggle((t) => {
        t.setValue(this.settings.defaultNoteSettings.dgShowBacklinks);
        t.onChange((val) => {
          this.settings.defaultNoteSettings.dgShowBacklinks = val;
          this.saveSettings();
        });
      });
      new import_obsidian3.Setting(noteSettingsModal.contentEl).setName("Show local graph for notes (dg-show-local-graph)").setDesc("When turned on, notes will show its local graph on desktop. It will not be shown on mobile devices.").addToggle((t) => {
        t.setValue(this.settings.defaultNoteSettings.dgShowLocalGraph);
        t.onChange((val) => {
          this.settings.defaultNoteSettings.dgShowLocalGraph = val;
          this.saveSettings();
        });
      });
      new import_obsidian3.Setting(noteSettingsModal.contentEl).setName("Show inline title (dg-show-inline-title)").setDesc("When turned on, the title of the note will show on top of the page.").addToggle((t) => {
        t.setValue(this.settings.defaultNoteSettings.dgShowInlineTitle);
        t.onChange((val) => {
          this.settings.defaultNoteSettings.dgShowInlineTitle = val;
          this.saveSettings();
        });
      });
    });
  }
  initializeThemesSettings() {
    return __async(this, null, function* () {
      const themeModal = new import_obsidian3.Modal(this.app);
      themeModal.titleEl.createEl("h1", { text: "Appearance Settings" });
      new import_obsidian3.Setting(this.settingsRootElement).setName("Appearance").setDesc("Manage themes and favicons on your site").addButton((cb) => {
        cb.setButtonText("Manage");
        cb.onClick(() => __async(this, null, function* () {
          themeModal.open();
        }));
      });
      const themesListResponse = yield import_axios.default.get("https://raw.githubusercontent.com/obsidianmd/obsidian-releases/master/community-css-themes.json");
      new import_obsidian3.Setting(themeModal.contentEl).setName("Theme").addDropdown((dd) => {
        dd.addOption('{"name": "default", "modes": ["dark"]}', "Default");
        const sortedThemes = themesListResponse.data.sort((a, b) => a.name.localeCompare(b.name));
        sortedThemes.map((x) => {
          dd.addOption(JSON.stringify(__spreadProps(__spreadValues({}, x), { cssUrl: `https://raw.githubusercontent.com/${x.repo}/${x.branch || "master"}/obsidian.css` })), x.name);
          dd.setValue(this.settings.theme);
          dd.onChange((val) => __async(this, null, function* () {
            this.settings.theme = val;
            yield this.saveSettings();
          }));
        });
      });
      new import_obsidian3.Setting(themeModal.contentEl).setName("Base theme").addDropdown((dd) => {
        dd.addOption("dark", "Dark");
        dd.addOption("light", "Light");
        dd.setValue(this.settings.baseTheme);
        dd.onChange((val) => __async(this, null, function* () {
          this.settings.baseTheme = val;
          yield this.saveSettings();
        }));
      });
      new import_obsidian3.Setting(themeModal.contentEl).setName("Favicon").setDesc("Path to an svg in your vault you wish to use as a favicon. Leave blank to use default.").addText((tc) => {
        tc.setPlaceholder("myfavicon.svg");
        tc.setValue(this.settings.faviconPath);
        tc.onChange((val) => __async(this, null, function* () {
          this.settings.faviconPath = val;
          yield this.saveSettings();
        }));
      });
      new import_obsidian3.Setting(themeModal.contentEl).addButton((cb) => {
        cb.setButtonText("Apply settings to site");
        cb.onClick((ev) => __async(this, null, function* () {
          const octokit = new Octokit({ auth: this.settings.githubToken });
          yield this.updateEnv(octokit);
          yield this.addFavicon(octokit);
        }));
      });
    });
  }
  updateEnv(octokit) {
    return __async(this, null, function* () {
      const theme = JSON.parse(this.settings.theme);
      const baseTheme = this.settings.baseTheme;
      if (theme.modes.indexOf(baseTheme) < 0) {
        new import_obsidian3.Notice(`The ${theme.name} theme doesn't support ${baseTheme} mode.`);
        return;
      }
      let envSettings = "";
      if (theme.name !== "default") {
        envSettings = `THEME=${theme.cssUrl}
BASE_THEME=${baseTheme}`;
      }
      const base64Settings = gBase64.encode(envSettings);
      let fileExists = true;
      let currentFile = null;
      try {
        currentFile = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: this.settings.githubUserName,
          repo: this.settings.githubRepo,
          path: ".env"
        });
      } catch (error) {
        fileExists = false;
      }
      yield octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", {
        owner: this.settings.githubUserName,
        repo: this.settings.githubRepo,
        path: ".env",
        message: `Update theme`,
        content: base64Settings,
        sha: fileExists ? currentFile.data.sha : null
      });
      new import_obsidian3.Notice("Successfully applied theme");
    });
  }
  addFavicon(octokit) {
    return __async(this, null, function* () {
      let base64SettingsFaviconContent = "";
      if (this.settings.faviconPath) {
        const faviconFile = this.app.vault.getAbstractFileByPath(this.settings.faviconPath);
        if (!(faviconFile instanceof import_obsidian3.TFile)) {
          new import_obsidian3.Notice(`${this.settings.faviconPath} is not a valid file.`);
          return;
        }
        const faviconContent = yield this.app.vault.readBinary(faviconFile);
        base64SettingsFaviconContent = arrayBufferToBase64(faviconContent);
      } else {
        const defaultFavicon = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: "oleeskild",
          repo: "digitalgarden",
          path: "src/site/favicon.svg"
        });
        base64SettingsFaviconContent = defaultFavicon.data.content;
      }
      let faviconExists = true;
      let faviconsAreIdentical = false;
      let currentFaviconOnSite = null;
      try {
        currentFaviconOnSite = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: this.settings.githubUserName,
          repo: this.settings.githubRepo,
          path: "src/site/favicon.svg"
        });
        faviconsAreIdentical = currentFaviconOnSite.data.content.replaceAll("\n", "").replaceAll(" ", "") === base64SettingsFaviconContent;
      } catch (error) {
        faviconExists = false;
      }
      if (!faviconExists || !faviconsAreIdentical) {
        yield octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", {
          owner: this.settings.githubUserName,
          repo: this.settings.githubRepo,
          path: "src/site/favicon.svg",
          message: `Update favicon.svg`,
          content: base64SettingsFaviconContent,
          sha: faviconExists ? currentFaviconOnSite.data.sha : null
        });
        new import_obsidian3.Notice(`Successfully set new favicon`);
      }
    });
  }
  initializeGitHubRepoSetting() {
    new import_obsidian3.Setting(this.settingsRootElement).setName("GitHub repo name").setDesc("The name of the GitHub repository").addText((text) => text.setPlaceholder("mydigitalgarden").setValue(this.settings.githubRepo).onChange((value) => __async(this, null, function* () {
      this.settings.githubRepo = value;
      yield this.saveSettings();
    })));
  }
  initializeGitHubUserNameSetting() {
    new import_obsidian3.Setting(this.settingsRootElement).setName("GitHub Username").setDesc("Your GitHub Username").addText((text) => text.setPlaceholder("myusername").setValue(this.settings.githubUserName).onChange((value) => __async(this, null, function* () {
      this.settings.githubUserName = value;
      yield this.saveSettings();
    })));
  }
  initializeGitHubTokenSetting() {
    const desc = document.createDocumentFragment();
    desc.createEl("span", null, (span) => {
      span.innerText = "A GitHub token with repo permissions. You can generate it ";
      span.createEl("a", null, (link) => {
        link.href = "https://github.com/settings/tokens/new?scopes=repo";
        link.innerText = "here!";
      });
    });
    new import_obsidian3.Setting(this.settingsRootElement).setName("GitHub token").setDesc(desc).addText((text) => text.setPlaceholder("Secret Token").setValue(this.settings.githubToken).onChange((value) => __async(this, null, function* () {
      this.settings.githubToken = value;
      yield this.saveSettings();
    })));
  }
  initializeGitHubBaseURLSetting() {
    new import_obsidian3.Setting(this.settingsRootElement).setName("Base URL").setDesc(`
            This is used for the "Copy Note URL" command and is optional. 
            If you leave it blank, the plugin will try to guess it from the repo name.
            `).addText((text) => text.setPlaceholder("my-garden.netlify.app").setValue(this.settings.gardenBaseUrl).onChange((value) => __async(this, null, function* () {
      this.settings.gardenBaseUrl = value;
      yield this.saveSettings();
    })));
  }
  initializeRibbonIconSetting() {
    new import_obsidian3.Setting(this.settingsRootElement).setName("Show ribbon icon").setDesc("Show ribbon icon in the Obsidian sidebar. You need to reload Obsdian for changes to take effect.").addToggle((toggle) => toggle.setValue(this.settings.showRibbonIcon).onChange((value) => __async(this, null, function* () {
      this.settings.showRibbonIcon = value;
      yield this.saveSettings();
    })));
  }
  renderCreatePr(modal, handlePR) {
    new import_obsidian3.Setting(this.settingsRootElement).setName("Site Template").setDesc("Manage updates to the base template. You should try updating the template when you update the plugin to make sure your garden support all features.").addButton((button) => {
      button.setButtonText("Manage site template");
      button.onClick(() => {
        modal.open();
      });
    });
    new import_obsidian3.Setting(modal.contentEl).setName("Update site to latest template").setDesc(`
				This will create a pull request with the latest template changes, which you'll need to use all plugin features. 
				It will not publish any changes before you approve them.
				You can even test the changes first as Netlify will automatically provide you with a test URL.
			`).addButton((button) => button.setButtonText("Create PR").onClick(() => handlePR(button)));
    if (!this.progressViewTop) {
      this.progressViewTop = modal.contentEl.createEl("div", {});
    }
    if (!this.loading) {
      this.loading = modal.contentEl.createEl("div", {});
      this.loading.hide();
    }
  }
  renderPullRequestHistory(modal, previousPrUrls) {
    if (previousPrUrls.length === 0) {
      return;
    }
    const header = modal.contentEl.createEl("h2", { text: "\u2795 Recent Pull Request History" });
    const prsContainer = modal.contentEl.createEl("ul", {});
    prsContainer.hide();
    header.onClickEvent(() => {
      if (prsContainer.isShown()) {
        prsContainer.hide();
        header.textContent = "\u2795  Recent Pull Request History";
      } else {
        prsContainer.show();
        header.textContent = "\u2796 Recent Pull Request History";
      }
    });
    previousPrUrls.map((prUrl) => {
      const li = prsContainer.createEl("li", { attr: { "style": "margin-bottom: 10px" } });
      const prUrlElement = document.createElement("a");
      prUrlElement.href = prUrl;
      prUrlElement.textContent = prUrl;
      li.appendChild(prUrlElement);
    });
  }
  renderLoading() {
    this.loading.show();
    const text = "Creating PR. This should take less than 1 minute";
    const loadingText = this.loading.createEl("h2", { text });
    this.loadingInterval = setInterval(() => {
      if (loadingText.innerText === `${text}`) {
        loadingText.innerText = `${text}.`;
      } else if (loadingText.innerText === `${text}.`) {
        loadingText.innerText = `${text}..`;
      } else if (loadingText.innerText === `${text}..`) {
        loadingText.innerText = `${text}...`;
      } else {
        loadingText.innerText = `${text}`;
      }
    }, 400);
  }
  renderSuccess(prUrl) {
    this.loading.remove();
    clearInterval(this.loadingInterval);
    const successmessage = prUrl ? { text: `\u{1F389} Done! Approve your PR to make the changes go live.` } : { text: "You already have the latest template \u{1F389} No need to create a PR.", attr: {} };
    const linkText = { text: `${prUrl}`, href: prUrl };
    this.progressViewTop.createEl("h2", successmessage);
    if (prUrl) {
      this.progressViewTop.createEl("a", linkText);
    }
    this.progressViewTop.createEl("br");
  }
  renderError() {
    this.loading.remove();
    clearInterval(this.loadingInterval);
    const errorMsg = { text: "\u274C Something went wrong. Try deleting the branch in GitHub.", attr: {} };
    this.progressViewTop.createEl("p", errorMsg);
  }
};

// src/PublishStatusBar.ts
var PublishStatusBar = class {
  constructor(statusBarItem, numberOfNotesToPublish) {
    this.statusBarItem = statusBarItem;
    this.counter = 0;
    this.numberOfNotesToPublish = numberOfNotesToPublish;
    this.statusBarItem.createEl("span", { text: "Digital Garden: " });
    this.status = this.statusBarItem.createEl("span", { text: `${this.numberOfNotesToPublish} files marked for publishing` });
  }
  increment() {
    this.status.innerText = `\u231BPublishing Notes: ${++this.counter}/${this.numberOfNotesToPublish}`;
  }
  finish(displayDurationMillisec) {
    this.status.innerText = `\u2705 Published Notes: ${this.counter}/${this.numberOfNotesToPublish}`;
    setTimeout(() => {
      this.statusBarItem.remove();
    }, displayDurationMillisec);
  }
  error() {
    this.statusBarItem.remove();
  }
};

// src/PublishModal.ts
var import_obsidian4 = __toModule(require("obsidian"));
var PublishModal = class {
  constructor(app, publishStatusManager, publisher, settings) {
    this.modal = new import_obsidian4.Modal(app);
    this.settings = settings;
    this.publishStatusManager = publishStatusManager;
    this.publisher = publisher;
    this.initialize();
  }
  createCollapsable(title, buttonText, buttonCallback) {
    const headerContainer = this.modal.contentEl.createEl("div", { attr: { style: "display: flex; justify-content: space-between; margin-bottom: 10px; align-items:center" } });
    const toggleHeader = headerContainer.createEl("h3", { text: `\u2795\uFE0F ${title}`, attr: { class: "collapsable collapsed" } });
    if (buttonText && buttonCallback) {
      const button = new import_obsidian4.ButtonComponent(headerContainer).setButtonText(buttonText).onClick(() => __async(this, null, function* () {
        button.setDisabled(true);
        yield buttonCallback();
        button.setDisabled(false);
      }));
    }
    const toggledList = this.modal.contentEl.createEl("ul");
    toggledList.hide();
    headerContainer.onClickEvent(() => {
      if (toggledList.isShown()) {
        toggleHeader.textContent = `\u2795\uFE0F ${title}`;
        toggledList.hide();
        toggleHeader.removeClass("open");
        toggleHeader.addClass("collapsed");
      } else {
        toggleHeader.textContent = `\u2796 ${title}`;
        toggledList.show();
        toggleHeader.removeClass("collapsed");
        toggleHeader.addClass("open");
      }
    });
    return toggledList;
  }
  initialize() {
    return __async(this, null, function* () {
      this.modal.titleEl.innerText = "\u{1F331} Digital Garden";
      this.modal.contentEl.addClass("digital-garden-publish-status-view");
      this.modal.contentEl.createEl("h2", { text: "Publication Status" });
      this.progressContainer = this.modal.contentEl.createEl("div", { attr: { style: "height: 30px;" } });
      this.publishedContainer = this.createCollapsable("Published", null, null);
      this.changedContainer = this.createCollapsable("Changed", "Update changed files", () => __async(this, null, function* () {
        const publishStatus = yield this.publishStatusManager.getPublishStatus();
        const changed = publishStatus.changedNotes;
        let counter = 0;
        for (const note of changed) {
          this.progressContainer.innerText = `\u231BPublishing changed notes: ${++counter}/${changed.length}`;
          yield this.publisher.publish(note);
        }
        const publishedText = `\u2705 Published all changed notes: ${counter}/${changed.length}`;
        this.progressContainer.innerText = publishedText;
        setTimeout(() => {
          if (this.progressContainer.innerText === publishedText) {
            this.progressContainer.innerText = "";
          }
        }, 5e3);
        yield this.refreshView();
      }));
      this.deletedContainer = this.createCollapsable("Deleted from vault", "Delete notes from garden", () => __async(this, null, function* () {
        const deletedNotes = yield this.publishStatusManager.getDeletedNotePaths();
        let counter = 0;
        for (const note of deletedNotes) {
          this.progressContainer.innerText = `\u231BDeleting Notes: ${++counter}/${deletedNotes.length}`;
          yield this.publisher.delete(note);
        }
        const deleteDoneText = `\u2705 Deleted all notes: ${counter}/${deletedNotes.length}`;
        this.progressContainer.innerText = deleteDoneText;
        setTimeout(() => {
          if (this.progressContainer.innerText === deleteDoneText) {
            this.progressContainer.innerText = "";
          }
        }, 5e3);
        yield this.refreshView();
      }));
      this.unpublishedContainer = this.createCollapsable("Unpublished", "Publish unpublished notes", () => __async(this, null, function* () {
        const publishStatus = yield this.publishStatusManager.getPublishStatus();
        const unpublished = publishStatus.unpublishedNotes;
        let counter = 0;
        for (const note of unpublished) {
          this.progressContainer.innerText = `\u231BPublishing unpublished notes: ${++counter}/${unpublished.length}`;
          yield this.publisher.publish(note);
        }
        const publishDoneText = `\u2705 Published all unpublished notes: ${counter}/${unpublished.length}`;
        this.progressContainer.innerText = publishDoneText;
        setTimeout(() => {
          if (this.progressContainer.innerText === publishDoneText) {
            this.progressContainer.innerText = "";
          }
        }, 5e3);
        yield this.refreshView();
      }));
      this.modal.onOpen = () => this.refreshView();
      this.modal.onClose = () => this.clearView();
    });
  }
  clearView() {
    return __async(this, null, function* () {
      while (this.publishedContainer.lastElementChild) {
        this.publishedContainer.removeChild(this.publishedContainer.lastElementChild);
      }
      while (this.changedContainer.lastElementChild) {
        this.changedContainer.removeChild(this.changedContainer.lastElementChild);
      }
      while (this.deletedContainer.lastElementChild) {
        this.deletedContainer.removeChild(this.deletedContainer.lastElementChild);
      }
      while (this.unpublishedContainer.lastElementChild) {
        this.unpublishedContainer.removeChild(this.unpublishedContainer.lastElementChild);
      }
    });
  }
  populateWithNotes() {
    return __async(this, null, function* () {
      const publishStatus = yield this.publishStatusManager.getPublishStatus();
      publishStatus.publishedNotes.map((file) => this.publishedContainer.createEl("li", { text: file.path }));
      publishStatus.unpublishedNotes.map((file) => this.unpublishedContainer.createEl("li", { text: file.path }));
      publishStatus.changedNotes.map((file) => this.changedContainer.createEl("li", { text: file.path }));
      publishStatus.deletedNotePaths.map((path) => this.deletedContainer.createEl("li", { text: path }));
    });
  }
  refreshView() {
    return __async(this, null, function* () {
      this.clearView();
      yield this.populateWithNotes();
    });
  }
  open() {
    this.modal.open();
  }
};

// src/PublishStatusManager.ts
var PublishStatusManager = class {
  constructor(siteManager, publisher) {
    this.siteManager = siteManager;
    this.publisher = publisher;
  }
  getDeletedNotePaths() {
    return __async(this, null, function* () {
      const remoteNoteHashes = yield this.siteManager.getNoteHashes();
      const marked = yield this.publisher.getFilesMarkedForPublishing();
      return this.generateDeletedNotePaths(remoteNoteHashes, marked);
    });
  }
  generateDeletedNotePaths(remoteNoteHashes, marked) {
    const deletedNotePaths = [];
    Object.keys(remoteNoteHashes).forEach((key) => {
      if (!marked.find((f) => f.path === key)) {
        if (!key.endsWith(".js")) {
          deletedNotePaths.push(key);
        }
      }
    });
    return deletedNotePaths;
  }
  getPublishStatus() {
    return __async(this, null, function* () {
      const unpublishedNotes = [];
      const publishedNotes = [];
      const changedNotes = [];
      const remoteNoteHashes = yield this.siteManager.getNoteHashes();
      const marked = yield this.publisher.getFilesMarkedForPublishing();
      for (const file of marked) {
        const content = yield this.publisher.generateMarkdown(file);
        const localHash = generateBlobHash(content);
        const remoteHash = remoteNoteHashes[file.path];
        if (!remoteHash) {
          unpublishedNotes.push(file);
        } else if (remoteHash === localHash) {
          publishedNotes.push(file);
        } else {
          changedNotes.push(file);
        }
      }
      const deletedNotePaths = this.generateDeletedNotePaths(remoteNoteHashes, marked);
      unpublishedNotes.sort((a, b) => a.path > b.path ? 1 : -1);
      publishedNotes.sort((a, b) => a.path > b.path ? 1 : -1);
      changedNotes.sort((a, b) => a.path > b.path ? 1 : -1);
      deletedNotePaths.sort((a, b) => a > b ? 1 : -1);
      return { unpublishedNotes, publishedNotes, changedNotes, deletedNotePaths };
    });
  }
};

// src/ObsidianFrontMatterEngine.ts
var ObsidianFrontMatterEngine = class {
  constructor(vault, metadataCache, file) {
    this.generatedFrontMatter = {};
    this.metadataCache = metadataCache;
    this.vault = vault;
    this.file = file;
  }
  set(key, value) {
    this.generatedFrontMatter[key] = value;
    return this;
  }
  remove(key) {
    this.generatedFrontMatter[key] = void 0;
    return this;
  }
  get(key) {
    return this.getFrontMatterSnapshot()[key];
  }
  apply() {
    return __async(this, null, function* () {
      const newFrontMatter = this.getFrontMatterSnapshot();
      const content = yield this.vault.cachedRead(this.file);
      const frontmatterRegex = /^\s*?---\n([\s\S]*?)\n---/g;
      const yaml = this.frontMatterToYaml(newFrontMatter);
      let newContent = "";
      if (content.match(frontmatterRegex)) {
        newContent = content.replace(frontmatterRegex, (match) => {
          return yaml;
        });
      } else {
        newContent = `${yaml}
${content}`;
      }
      yield this.vault.modify(this.file, newContent);
    });
  }
  frontMatterToYaml(frontMatter) {
    for (const key of Object.keys(frontMatter)) {
      if (frontMatter[key] === void 0) {
        delete frontMatter[key];
      }
    }
    if (Object.keys(frontMatter).length === 0) {
      return "";
    }
    let yaml = "---\n";
    for (const key of Object.keys(frontMatter)) {
      yaml += `${key}: ${frontMatter[key]}
`;
    }
    yaml += "---";
    return yaml;
  }
  getFrontMatterSnapshot() {
    var _a, _b;
    const cachedFrontMatter = __spreadValues({}, (_b = this.metadataCache.getCache((_a = this.file) == null ? void 0 : _a.path)) == null ? void 0 : _b.frontmatter);
    delete cachedFrontMatter["position"];
    return __spreadValues(__spreadValues({}, cachedFrontMatter), this.generatedFrontMatter);
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  githubRepo: "",
  githubToken: "",
  githubUserName: "",
  gardenBaseUrl: "",
  prHistory: [],
  theme: "dark",
  baseTheme: '{"name": "default", "modes": ["dark"]}',
  faviconPath: "",
  showRibbonIcon: true,
  defaultNoteSettings: {
    dgHomeLink: true,
    dgPassFrontmatter: false,
    dgShowBacklinks: false,
    dgShowLocalGraph: false,
    dgShowInlineTitle: false
  }
};
var DigitalGarden = class extends import_obsidian5.Plugin {
  onload() {
    return __async(this, null, function* () {
      this.appVersion = this.manifest.version;
      console.log("Initializing DigitalGarden plugin v" + this.appVersion);
      yield this.loadSettings();
      this.addSettingTab(new DigitalGardenSettingTab(this.app, this));
      yield this.addCommands();
      (0, import_obsidian5.addIcon)("digital-garden-icon", seedling);
      if (this.settings.showRibbonIcon) {
        this.addRibbonIcon("digital-garden-icon", "Digital Garden Publication Center", () => __async(this, null, function* () {
          this.openPublishModal();
        }));
      }
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  addCommands() {
    return __async(this, null, function* () {
      this.addCommand({
        id: "publish-note",
        name: "Publish Single Note",
        callback: () => __async(this, null, function* () {
          try {
            const { vault, workspace, metadataCache } = this.app;
            const currentFile = workspace.getActiveFile();
            if (!currentFile) {
              new import_obsidian5.Notice("No file is open/active. Please open a file and try again.");
              return;
            }
            if (currentFile.extension !== "md") {
              new import_obsidian5.Notice("The current file is not a markdown file. Please open a markdown file and try again.");
              return;
            }
            new import_obsidian5.Notice("Publishing note...");
            const publisher = new Publisher(vault, metadataCache, this.settings);
            const publishSuccessful = yield publisher.publish(currentFile);
            if (publishSuccessful) {
              new import_obsidian5.Notice(`Successfully published note to your garden.`);
            }
          } catch (e) {
            console.error(e);
            new import_obsidian5.Notice("Unable to publish note, something went wrong.");
          }
        })
      });
      this.addCommand({
        id: "publish-multiple-notes",
        name: "Publish Multiple Notes",
        callback: () => __async(this, null, function* () {
          const statusBarItem = this.addStatusBarItem();
          try {
            const { vault, metadataCache } = this.app;
            const publisher = new Publisher(vault, metadataCache, this.settings);
            const siteManager = new DigitalGardenSiteManager(metadataCache, this.settings);
            const publishStatusManager = new PublishStatusManager(siteManager, publisher);
            const publishStatus = yield publishStatusManager.getPublishStatus();
            const filesToPublish = publishStatus.changedNotes.concat(publishStatus.unpublishedNotes);
            const filesToDelete = publishStatus.deletedNotePaths;
            const statusBar = new PublishStatusBar(statusBarItem, filesToPublish.length + filesToDelete.length);
            let errorFiles = 0;
            let errorDeleteFiles = 0;
            for (const file of filesToPublish) {
              try {
                statusBar.increment();
                yield publisher.publish(file);
              } catch (e) {
                errorFiles++;
                new import_obsidian5.Notice(`Unable to publish note ${file.name}, skipping it.`);
              }
            }
            for (const filePath of filesToDelete) {
              try {
                statusBar.increment();
                yield publisher.delete(filePath);
              } catch (e) {
                errorDeleteFiles++;
                new import_obsidian5.Notice(`Unable to delete note ${filePath}, skipping it.`);
              }
            }
            statusBar.finish(8e3);
            new import_obsidian5.Notice(`Successfully published ${filesToPublish.length - errorFiles} notes to your garden.`);
            if (filesToDelete.length > 0) {
              new import_obsidian5.Notice(`Successfully deleted ${filesToDelete.length - errorDeleteFiles} notes from your garden.`);
            }
          } catch (e) {
            statusBarItem.remove();
            console.error(e);
            new import_obsidian5.Notice("Unable to publish multiple notes, something went wrong.");
          }
        })
      });
      this.addCommand({
        id: "copy-garden-url",
        name: "Copy Garden URL",
        callback: () => __async(this, null, function* () {
          try {
            const { metadataCache, workspace } = this.app;
            const currentFile = workspace.getActiveFile();
            if (!currentFile) {
              new import_obsidian5.Notice("No file is open/active. Please open a file and try again.");
              return;
            }
            const siteManager = new DigitalGardenSiteManager(metadataCache, this.settings);
            const fullUrl = siteManager.getNoteUrl(currentFile);
            yield navigator.clipboard.writeText(fullUrl);
            new import_obsidian5.Notice(`Note URL copied to clipboard`);
          } catch (e) {
            console.log(e);
            new import_obsidian5.Notice("Unable to copy note URL to clipboard, something went wrong.");
          }
        })
      });
      this.addCommand({
        id: "dg-open-publish-modal",
        name: "Open Publication Center",
        callback: () => __async(this, null, function* () {
          this.openPublishModal();
        })
      });
      this.addCommand({
        id: "dg-mark-note-for-publish",
        name: "Add publish flag",
        callback: () => __async(this, null, function* () {
          const engine = new ObsidianFrontMatterEngine(this.app.vault, this.app.metadataCache, this.app.workspace.getActiveFile());
          engine.set("dg-publish", true).apply();
        })
      });
    });
  }
  openPublishModal() {
    if (!this.publishModal) {
      const siteManager = new DigitalGardenSiteManager(this.app.metadataCache, this.settings);
      const publisher = new Publisher(this.app.vault, this.app.metadataCache, this.settings);
      const publishStatusManager = new PublishStatusManager(siteManager, publisher);
      this.publishModal = new PublishModal(this.app, publishStatusManager, publisher, this.settings);
    }
    this.publishModal.open();
  }
};
var DigitalGardenSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    return __async(this, null, function* () {
      const { containerEl } = this;
      const settingView = new SettingView(this.app, containerEl, this.plugin.settings, () => __async(this, null, function* () {
        return yield this.plugin.saveData(this.plugin.settings);
      }));
      const prModal = new import_obsidian5.Modal(this.app);
      yield settingView.initialize(prModal);
      const handlePR = (button) => __async(this, null, function* () {
        settingView.renderLoading();
        button.setDisabled(true);
        try {
          const siteManager = new DigitalGardenSiteManager(this.plugin.app.metadataCache, this.plugin.settings);
          const prUrl = yield siteManager.createPullRequestWithSiteChanges();
          if (prUrl) {
            this.plugin.settings.prHistory.push(prUrl);
            yield this.plugin.saveSettings();
          }
          settingView.renderSuccess(prUrl);
          button.setDisabled(false);
        } catch (e) {
          settingView.renderError();
        }
      });
      settingView.renderCreatePr(prModal, handlePR);
      settingView.renderPullRequestHistory(prModal, this.plugin.settings.prHistory.reverse().slice(0, 10));
    });
  }
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
//!()[image.svg]
//![[image.png]]
//![[image.svg]]
//![](image.png)
