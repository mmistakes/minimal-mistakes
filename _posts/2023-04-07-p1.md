---
layout: single
title:  "Intro."
categories : Infra
toc: true
typora-root-url: ../
tag: [Python, Connected_car]
#search : false 검색 원치 않을 때
---

# Why Autonomous Driving?

[TOC]



## Intro.

*구글, 애플,E 테슬라, BMW, 현대자동차.* 
전 세계에서 내놓으라 하는 글로벌 기업들은 지난 몇 년 간 왜 그토록 자율주행 시장에 열광해 왔을까?
**주행보조기능(ADAS; Advance Driver Assistance System)** 이 상용화된지 10여년 가까이 되는 현 시점에서 '완전 자율주행(Level 5)'을막고있는 것은 대체 무엇일까?

나의 앞선 질문들에 대해 **자율주행(AD; Autonomous Driving)**  개발자들은 '모리벡의 역설(Moravec’s paradox)'로 답한다. 

> ‘어려운 일은 쉽고 쉬운 일은 어렵다(Hard problems are easy and easy problems are hard).’ - '모리벡의 역설(Moravec’s paradox)'

'컴퓨터가 복잡한 퍼즐이나 체커게임에서 어른 이상의 성능을 발휘하도록 하긴 쉽지만 한 살짜리 아이의 환경 인지와 신체 움직임을 재현하긴 어렵다.'라는 의미로 인간에게는 당연하다 여겨지는 것들이 컴퓨터에게는 절대로 당연하지 않다는 말이다.
운전대를 한 번이라도 잡아본 사람은 알 것이다. 깜빡이를 켜지 않고 차선을 변경하는 차량, 도로 수리를 위해 차선이 표시되지 않은 임시 도로 등 어쩌면 세상에서 변수가 가장 많은 곳이 도로라는 말이 있듯이 기껏해야 카메라, 카메라에서 조금 더 발전해 빛의 전파를 이용한 **라이다(LiDAR: Light Detection and Ranging)**가 장착된 지금의 자율주행차들의 능력은 한 살짜리 아이의 인지 능력보다도 부족하다 생각한다. 

아무리 센서가 많아지고 소프트웨어적인 기능을 탑재한다고 해도 자동차의 근본적인 역할은 주행이다. 그저 잘 달리고 잘 멈추는 것이다.  하지만 자율주행에 있어 앞선 주장은 달라진다. 조금 더 자세히 이야기해보자면 운전자는 다른 차량의 운전자 혹은 교통경찰의 손짓, 몸짓을 보고 '아, 저렇게 하라는 거구나?' 하고 소통하며 주행하기도한다. 하지만 운전에 있어 필수적인 정보, 예를 들어 주행 경로, 앞차와의 거리, 교통 신호  등과 같은 데이터 처리만으로도 지금의 ADAS(여기서는 자율주행 데이터 처리를 위한 서버를 의미)는 벅차 보이는 것이 사실이다. 나 역시 자율주행의 불확실성에 대해 생각하며 글을 쓰다보니 차량 내부와 외부의 센서들 간의 데이터 통신으로 궁극적으로 도로 위의 차량과 차량 사이에서 소통하고자 하는 **커넥티드 카(Connected Car)**는 동화 속 이야기 같기도 하다. 

하지만 그럼에도 불구하고, 나는 세상에 결국 언젠가는 완전한 자율주행 자동차(Level 5)가 나타날 거라 생각한다.
도로 위의 변수들을 제어할 수 있는 소프트웨어, 어쩌면 인간처럼 사고하는 알고리즘 기반의 Mobility SW가 그 해답이 될 것이고 센서로 수집된 데이터를 얼마나 빠르게 효과적으로 사용하느냐 역시 또 하나의 변곡점이 될 듯 싶다. 이에 지금부터 내가 포스팅하고자 하는 블로그의 전반적인 내용은 다음과 같다.

### About.

현재 계획하고 있는 포스팅의 카테고리는 크게 세가지로 분류할 수 있다. 첫번째 자율주행 알고리즘, 두번째 라즈베리파이, 세번째 차량 데이터 처리로 향후 세부적인 내용은 유동적일 수 있지만 앞선 카테고리에서 크게 벗어나진 않을 것 같다.

1.자율주행 알고리즘(Algorithms for Autonomous Driving)

2.라즈베리 파이를 이용한 자율주행 RC카 제작(Building a Self-Driving RC Car with Raspberry Pi)

- 라즈베리파이?
- 파이썬(데이터, GPIO)
- LiDAR, 초음파 센서 활용
- 모터 제어
- 영상 처리 위한 Opencv 라이브러리 활용
- 딥러닝을 활용한 RC카 모델링
- 라즈베리파이를 이용한 서버 구축(FTP, SSH, VPN)
- GCP

3.차량 데이터 처리(Vehicle data processing)



## Outro.

자율주행이라는 주제가 어떻게 보면 친숙하지만 또 어떻게 보면 꽤 낯선 주제라고 생각한다. 그래서 나는 이번 블로그를 통해 자율주행에 관해 아무것도 모르는 사람들이 '아? 그거?' 하고 공감할 수 있는 그런 글들을 쓰려고 한다. 그래서 포스팅 간간히 자동차 하드웨어 구조나 "Car and Driver" 메거진에서 재미있는 내용도 정리해보려고 한다.  

<img src="https://geospatialmedia.s3.amazonaws.com/wp-content/uploads/2018/02/bi-graphics_autonomous-cars.png" alt="Did you know what are the five levels of autonomous cars?" style="zoom: 67%;" />



다음 포스팅에서는 자율주행 경로탐색 알고리즘 중에 하나인 **Quick Sort Algorithm**에 대해 설명하려고 한다. 다음 포스팅에서 자세히 다루겠지만 Quick Sort 알고리즘이 자율주행 경로탐색에서 직접적으로 사용되는 것은 아니다. 하지만 이 알고리즘을 기반으로 다른 정렬 알고리즘과 함께 사용되기에 자율주행 알고리즘에서는 가장 기본이다. 나 역시 공부를 하면서 pivot을 좌,우,중간 어느 지점으로 선택하느냐에 따라 수행속도가 달라진다는 점이 꽤 재미있게 느껴졌는데 관련된 내용과 논문에 대해서는 다음 포스팅에서 더 자세히 다루도록 하며 다음 포스팅 이해도를 높이기 위해 Quick Sort 알고리즘 기본형식(Pivot 중간값) 코드를 끝으로 글을 마치고자 한다.

`Quick Sort Algorithm`

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr 

pivot = arr[len(arr) // 2]  # Pivot MIDDLE
L = []
R = []
M = []

# 피벗을 기준으로 왼쪽, 오른쪽, 같은 값 리스트로 분할
for num in arr:
    if num < pivot:
        L.append(num)
    elif num > pivot:
        R.append(num)
    else:
        M.append(num)

# 왼쪽, 오른쪽 리스트를 재귀적으로 정렬하고, 각각을 합쳐서 반환
return quick_sort(L) + M + quick_sort(R)
```







## Reference.

[Hyundai_Tech](https://tech.hyundaimotorgroup.com/kr/developers-blog/level-4-self-driving-technology-development-machine-for-tactics-into-the-self-driving-car-world/)
