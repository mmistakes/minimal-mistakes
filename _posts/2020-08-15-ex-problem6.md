---
title: "COS Pro 1급 (C) 시험문제 (6)"
categories:
  - Study
tags:
  - COS Pro
toc: true
toc_sticky: true
---

**NOTICE:** 본 포스트는 YBMIT 사이트에서 제공하는 COS Pro 1급 C언어 시험문제 지문입니다. 원본 지문 파일 및 문제, 정답 파일은 다음의 링크에서 다운로드 가능하며 (https://www.ybmit.com/cos_pro/cos_pro_r_test.jsp), 저작권 또한 `(주)와이비엠넷` 에 있음을 사전에 공지합니다.
{: .notice}

---
# 문제1
n x n 크기 격자 모양 정원에 칸마다 핀 꽃 또는 피지 않은 꽃을 심었습니다. 이 정원의 꽃이 모두 피는 데 며칠이 걸리는지 알고 싶습니다. 핀 꽃은 하루가 지나면 앞, 뒤, 양옆 네 방향에 있는 꽃을 피웁니다. 
정원 크기 n과 현재 정원의 상태를 담은 2차원 배열 garden이 주어졌을 때, 모든 꽃이 피는데 며칠이 걸리는지 return 하도록 solution 함수를 작성해주세요.

---
## 1.1 매개변수 설명
정원 크기 n과 현재 정원 상태를 담은 2차원 배열 garden이 solution 함수의 매개변수로 주어집니다.
* 정원 크기 n은 1보다 크고 100 보다 작거나 같은 자연수입니다.
* 정원 상태를 담은 2차원 배열 garden의 원소는 0 또는 1 입니다.
* 이미 핀 꽃은 1로 아직 피지 않은 꽃은 0으로 표현합니다.
* 정원에 최소 꽃 한 개는 피어 있습니다.

---
## 1.2 return 값 설명
꽃이 모두 피는데 며칠이 걸리는지 return 합니다.

---
## 1.3 예시

| n | garden                        	| return |
|---|-----------------------------------|--------|
| 3 | [[0, 0, 0], [0, 1, 0], [0, 0, 0]] | 2  	|
| 2 | [[1, 1], [1, 1]]              	| 0  	|

---
## 1.4 예시 설명
예시 #1
첫 날 정원은 아래와 같습니다.
  ![ex1-1.jpg](https://grepp-programmers.s3.amazonaws.com/files/ybm/37bda7d9f3/31e62cd8-a1f4-4b48-bc9f-77760bab6d95.jpg)

1일이 지난 정원의 상태는 아래와 같습니다.
  ![ex1-2.jpg](https://grepp-programmers.s3.amazonaws.com/files/ybm/ecc95dcb73/92fc1442-9e02-4cc9-9283-a268e5b17c95.jpg)

2일이 지난 정원의 상태는 아래와 같습니다.
  ![ex1-3.jpg](https://grepp-programmers.s3.amazonaws.com/files/ybm/d5956891e7/e51e8c3b-2658-46f5-a339-7dba4f2e5aa1.jpg)

따라서, 2일이 지나면 정원의 모든 꽃이 핍니다.

예시 #2
첫 날 화단의 상태는 아래와 같습니다.
  ![ex2-1.jpg](https://grepp-programmers.s3.amazonaws.com/files/ybm/9911040aaf/db95217b-f1b7-4ab3-b932-d15133431346.jpg)

따라서, 0일이 지나면 정원의 모든 꽃이 핍니다.


---
# 문제2
한 줄에 K자를 적을 수 있는 메모장에 영어 단어들을 적으려 합니다. 영어 단어는 정해진 순서로 적어야 하며, 단어와 단어 사이는 공백 하나로 구분합니다. 단, 한 줄의 끝에 단어 하나를 완전히 적지 못한다면, 그 줄의 나머지 부분을 모두 공백으로 채우고 다음 줄부터 다시 단어를 적습니다.

예를 들어 한 줄에 10자를 적을 수 있고, 주어진 단어가 순서대로 `["nice", "happy", "hello", "world", "hi"]` 인 경우 각 줄에 다음과 같이 적을 수 있습니다.('_'는 공백을 나타냅니다.)

* 첫째 줄 : `"nice_happy"`
* 둘째 줄 : `"hello_____"`
* 셋째 줄 : `"world_hi"`

이때, 둘째 줄에 `"hello"`를 적으면 단어를 적을 수 있는 남은 칸은 5칸이며, `"world"`를 이어서 적으려면 공백 하나를 포함하여 총 6칸이 필요합니다. 따라서 단어가 잘리게 되므로 남은 칸을 모두 공백으로 채운 후, 다음 줄에 `"world"`부터 다시 단어를 적어 나갑니다.

한 줄에 적을 수 있는 글자 수 K와 적을 단어가 순서대로 담긴 배열 words, words의 길이 words_len이 매개변수로 주어질 때, 단어를 모두 적으면 몇 줄이 되는지 return 하도록 solution 함수를 완성해주세요.

---
## 2.1 매개변수 설명
한 줄에 적을 수 있는 글자 수 K와 적을 단어가 순서대로 담긴 배열 words, words의 길이 words_len이 solution 함수의 매개변수로 주어집니다.

* K는 5 이상 30 이하인 자연수입니다.
* words_len은 1 이상 100 이하입니다.
* words 배열에 담겨있는 모든 단어는 알파벳 소문자로만 이루어져 있으며, 각 단어의 길이는 K 이하입니다.

---
## 2.2 return값 설명
단어를 모두 적으면 몇 줄이 되는지 return해주세요.

---
## 2.3 예제

| K  | words                                     | words_len | return |
|----|-------------------------------------------|-----------|--------|
| 10 | ["nice", "happy", "hello", "world", "hi"] | 5         | 3      |

---
## 2.4예제 설명
예제#1
문제의 예시와 같으며, 단어를 모두 적으면 3줄이 됩니다.


---
# 문제3
자연수가 들어있는 배열에서 숫자 K개를 선택하려 합니다. 이때, 선택한 숫자 중 가장 큰 수와 가장 작은 수의 차이가 최소가 되도록 해야합니다.

예를 들어 배열에 들어있는 숫자가 [9, 11, 9, 6, 4, 19] 이고, K = 4 라면

* 숫자 4개를 [9, 11, 9, 6]로 뽑으면 (가장 큰 수 - 가장 작은 수) = (11 - 6) = 5가 됩니다.
* [9, 9, 6, 4] 와 같이 숫자를 뽑아도  (가장 큰 수 - 가장 작은 수) = (9 - 4) = 5가 됩니다.

그러나 가장 큰 수와 가장 작은 수의 차이가 5보다 작아지도록 숫자 4개를 선택하는 방법은 없습니다.

자연수가 들어있는 배열 arr, arr의 길이 arr_len, 선택해야 하는 숫자 개수 K가 매개변수로 주어질 때, 선택한 숫자중 가장 큰 수와 가장 작은 수의 차이가 최소가 되록 arr에서 숫자 K개를 선택했을 때, 그때의  가장 큰 수와 가장 작은 수의 차이를 return 하도록 solution 함수를 완성해주세요.

---
## 3.1 매개변수 설명
자연수가 들어있는 배열 arr, arr의 길이 arr_len, 선택해야 하는 숫자 개수 K가 solution 함수의 매개변수로 주어집니다.

* arr_len은 5 이상 1,000 이하입니다.
* arr의 원소는 1 이상 10,000 이하인 자연수입니다.
* K 는 4 이상 50 이하인 자연수입니다.

---
## 3.2 return값 설명
선택한 숫자중 가장 큰 수와 가장 작은 수의 차이가 최소가 되도록 arr에서 숫자 K개를 선택했을 때, 그때의  가장 큰 수와 가장 작은 수의 차이를 return 해주세요.

---
## 3.3 예시

| arr                  | arr_len | K | return |
|----------------------|---------|---|--------|
| [9, 11, 9, 6, 4, 19] | 6       | 4 | 5      |

---
## 3.4 예시 설명

예시 #1
문제의 예시와 같습니다.

---
# 문제4
1부터 n까지 숫자가 적힌 카드 뭉치를 다음 규칙에 따라 카드 뭉치를 섞었을 때, 아래에서부터 k번째에 있는 카드에 적힌 숫자를 알아내려합니다. 카드 뭉치 가장 아래에는 1이 쓰여있으며, 위로 갈수록 숫자가 커집니다. 카드 뭉치를 섞는 규칙은 다음과 같습니다.

```
1. 카드 뭉치를 정확히 반으로 나눕니다.
2. 두 개로 나뉜 카드 뭉치를 교차로 섞어서 카드 뭉치 하나를 만듭니다. 이때, 항상 1이 적힌 카드가 있는 뭉치를 아래로 놓고 섞습니다.
3. 위 과정을 반복합니다.
```

예를 들어, 1부터 6까지 숫자가 적힌 카드 뭉치를 3번 섞는다면 과정별로 아래에서부터 적힌 숫자는 다음과 같습니다.

| 횟수 | 카드 뭉치          |
|------|--------------------|
| 1    | [1, 4, 2, 5, 3, 6] |
| 2    | [1, 5, 4, 3, 2, 6] |
| 3    | [1, 3, 5, 2, 4, 6] |

이때, 아래에서 3번째에 있는 카드에 적힌 숫자는 5입니다.

처음에 가장 위에 있는 카드에 적힌 숫자 n, 섞는 횟수 mix, 알고 싶은 카드의 위치 k가 매개변수로 주어질 때, 아래에서부터 k번째에 있는 카드에 적힌 숫자를 return 하도록 solution 함수를 작성했습니다. 그러나, 코드 일부분이 잘못되어있기 때문에, 몇몇 입력에 대해서는 올바르게 동작하지 않습니다. 주어진 코드에서 _**한 줄**_만 변경해서 모든 입력에 대해 올바르게 동작하도록 수정하세요.

---
## 4.1 매개변수 설명
처음에 가장 위에 있는 카드에 적힌 숫자 n, 섞는 횟수 mix, 알고 싶은 카드의 위치 k가 solution 함수의 매개변수로 주어집니다.
* n은 10 이상 50 이하인 짝수입니다.
* 카드는 0회 이상 10회 이하로 섞습니다.
* k는 1 이상 n 이하인 자연수입니다.

---
## 4.2 return 값 설명
아래에서 k번째에 있는 카드에 적힌 숫자를 return 해주세요.

---
## 4.3 예시

| n  | mix | k | return |
|----|-----|---|--------|
| 6 | 3   | 3 | 5  	|

---
## 4.4 예시 설명
문제에 나온 예와 같습니다.

---
# 문제5
A 게임은 4x4 격자 모양의 보드의 가장 왼쪽 위에서 가장 오른쪽 아래로 말을 이동시키면서 각 구역에 있는 코인을 획득하는 게임입니다. 이때, 말은 오른쪽 또는 아래쪽으로만 이동할 수 있습니다.

예를 들어, 보드가 아래와 같다면

  ![스크린샷 2018-11-14 오후 6.09.57.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/66edaada7d/0ac1c4be-5e0c-459a-9b83-b7fccefb70cc.png)

아래의 경우가 코인을 최대로 획득할 수 있는 경우이고 이때 획득하는 코인은 38입니다.

  ![스크린샷 2018-11-14 오후 6.09.52.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/1858f83a13/df5c905b-fbd4-40cf-a11b-587f6858932e.png)


각 구역에서 획득할 수 있는 코인 양을 담은 2차원 배열 board, board의 길이 board_len이 매개변수로 주어질 때, 최대로 획득할 수 있는 코인의 양을 return 하도록 solution 함수를 작성했습니다. 그러나, 코드 일부분이 잘못되어있기 때문에, 몇몇 입력에 대해서는 올바르게 동작하지 않습니다. 주어진 코드에서 _**한 줄**_만 변경해서 모든 입력에 대해 올바르게 동작하도록 수정하세요.

---

## 5.1 매개변수 설명
각 구역에서 획득할 수 있는 코인 양을 담은 2차원 배열 board, board의 길이 board_len이 solution 함수의 매개변수로 주어집니다.

* board는 4x4 크기인 2차원 배열입니다.
* board_len은 항상 4 입니다.
* 각 구역에서 획득할 수 있는 코인의 양은 1 이상 9 이하인 자연수입니다.

---

## 5.2 return 값 설명
최대로 획득할 수 있는 코인의 양을 return 합니다.

---

## 5.3 예제

| board                                                    | board_len | return |
|----------------------------------------------------------|-----------|--------|
| [[6, 7, 1, 2], [3, 5, 3, 9], [6, 4, 5, 2], [7, 3, 2, 6]] | 4         | 38     |

---
## 5.4 예제 설명
문제에 나온 예와 같습니다.


---
# 문제6
4 x 4 크기인 정사각형 종이가 1 x 1 크기인 격자 칸으로 나누어져 있습니다. 이 종이를 가로축 혹은 세로축에 평행한 격자 선을 따라 한 번 접었을 때, 만나는 격자 칸에 적힌 숫자의 합이 최대가 되도록 하려 합니다. 종이를 접을 때는 만나는 격자 칸이 정확히 일치하도록 해야 합니다.

예를 들어 다음과 같이 4 x 4 크기인 종이가 있을 때,

  ![grid_sum_3.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/3ea85370be/5116d961-6f8b-4b1b-a01c-c8ffc722755b.png)

종이는 점선 중 하나를 따라서 접을 수 있습니다. 이때, 붉은색 점선을 따라 종이를 접으면 36과 19가 적힌 칸이 정확히 만납니다. 두 숫자의 합은 55이며, 이때가 최댓값입니다.

4 x 4 크기인 정사각형 종이의 각 격자 칸에 적힌 숫자가 담긴 배열 grid, grid의 길이 grid_len이 매개변수로 주어질 때, 종이를 접었을 때 만나게 되는 격자 칸에 적힌 숫자의 합 중 최댓값을 return 하도록 solution 함수를 작성했습니다. 그러나, 코드 일부분이 잘못되어있기 때문에, 몇몇 입력에 대해서는 올바르게 동작하지 않습니다. 주어진 코드에서 _**한 줄**_만 변경해서 모든 입력에 대해 올바르게 동작하도록 수정하세요.

---
## 6.1 매개변수 설명
4 x 4 크기인 정사각형 종이의 각 격자 칸에 적힌 숫자가 담긴 배열 grid, grid의 길이 grid_len이 solution 함수의 매개변수로 주어집니다.

* 각 격자칸에 적힌 수는 1 이상 100 이하인 자연수입니다.
* grid_len은 항상 4입니다.

---
## 6.2 return 값 설명
격자 선을 따라 종이를 한 번 접었을 때 만나는 격자 칸에 적힌 숫자의 합 중 최댓값을 return 해주세요.

* 격자 선은 문제의 예시와같이 가로, 혹은 세로 방향으로 평행한 점선을 말합니다.

---
## 6.3 예시

| grid                                                              | grid_len | return |
|-------------------------------------------------------------------|----------|--------|
| [[1, 4, 16, 1], [20, 5, 15, 8], [6, 13, 36, 14], [20, 7, 19, 15]] | 4        | 55     |

---
## 6.4 예시 설명
문제의 예시와 같습니다.


---
# 문제7
UP AND DOWN 게임은 다음과 같은 규칙에 따라 진행하는 게임입니다.

* 먼저 출제자가 1 이상 ~ K 이하인 자연수 중 하나를 마음속으로 생각합니다.
* 게임 참가자는 1 이상 ~ K 이하인 자연수 중 아무거나 하나를 말합니다.
 * 만약, 참가자가 말한 숫자가 출제자가 생각한 숫자보다 작다면 출제자는 "UP"이라고 말합니다.
 * 만약, 참가자가 말한 숫자가 출제자가 생각한 숫자보다 크다면 출제자는 "DOWN"이라고 말합니다.
* 참가자는 출제자가 말하는 "UP", "DOWN" 힌트를 잘 활용해서 출제자가 처음에 생각한 숫자를 맞추면 됩니다.

출제자가 처음에 생각할 수 있는 자연수 범위 K, 게임 참가자가 말한 숫자가 순서대로 담긴 배열 numbers, numbers의 길이 numbers_len, 게임 출제자가 참가자가 말한 각 숫자에 대해 답한 내용이 순서대로 담긴 배열 up_down, up_down의 길이 up_down_len이 매개변수로 주어집니다. 배열에 주어진 순서대로 게임이 진행됐다고 했을 때, 현재 정답이 될 수 있는 숫자는 몇 개인지 return 하도록 solution 함수를 작성하려 합니다. 빈칸을 채워 전체 코드를 완성해주세요.

---
## 7.1 매개변수 설명

출제자가 처음에 생각할 수 있는 자연수 범위 K, 게임 참가자가 말한 숫자가 순서대로 담긴 배열 numbers, numbers의 길이 numbers_len, 게임 출제자가 참가자가 말한 각 숫자에 대해 답한 내용이 순서대로 담긴 배열 up_down, up_down의 길이 up_down_len이 solution 함수의 매개변수로 주어집니다.

* K는 1 이상 10,000 이하인 자연수입니다.
* numbers_len은 1 이상 10 이하입니다.
* numbers 배열의 원소는 1 이상 K 이하인 자연수입니다.
* up_down_len은 numbers_len과 같습니다.
* up_down 배열은 문자열 "UP", "DOWN", "RIGHT"으로만 이루어져 있습니다.
* "RIGHT"이 나오면 정답을 맞췄다는 것이며, 게임은 더는 진행되지 않습니다.
* 항상 올바르게 게임이 진행된 경우만 입력으로 주어집니다.

---
## 7.2 return 값 설명

배열에 주어진 순서대로 게임이 진행됐다고 했을 때, 현재 정답이 될 수 있는 숫자는 몇 개인지
return 해주세요.

* 출제자가 "RIGHT"을 말한 상태로 게임이 끝났다면 정답을 맞춘 것이므로 1을 return 하면 됩니다.

---
## 7.3 예제

| K   | numbers   | numbers_len | up_down              | up_down_len | return |
|-----|-----------|-------------|----------------------|-------------|--------|
| 10  | [4, 9, 6] | 3           | ["UP", "DOWN", "UP"] | 3           | 2      |
| 10  | [2, 1, 6] | 3           | ["UP", "UP", "DOWN"] | 3           | 3      |
| 100 | [97, 98]  | 2           | ["UP", "RIGHT"]      | 2           | 1      |

---
## 7.4 예제 설명

예제 #1

| 말한 숫자 | 출제자 대답 | 가능성 있는 숫자  |
|-----------|-------------|-------------------|
| 4         | "UP"        | 5, 6, 7, 8, 9, 10 |
| 9         | "DOWN"      | 5, 6, 7, 8        |
| 6         | "UP"        | 7, 8              |

따라서 현재 상황에서 가능성 있는 숫자는 2개입니다.

예제 #2

| 말한 숫자 | 출제자 대답 | 가능성 있는 숫자  |
|-----------|-------------|-------------------|
| 2         | "UP"        | 3, 4, 5, 6, 7, 8, 9, 10 |
| 1         | "UP"      | 3, 4, 5, 6, 7, 8, 9, 10        |
| 6         | "DOWN"        | 3, 4, 5              |

따라서 현재 상황에서 가능성 있는 숫자는 3개입니다.

예제 #3

| 말한 숫자 | 출제자 대답 | 가능성 있는 숫자  |
|-----------|-------------|-------------------|
| 97         | "UP"        | 98, 99, 100 |
| 98         | "RIGHT"      | 98        |

따라서 정답을 맞췄으므로 1을 return 하면 됩니다.

---
# 문제8
수열 S가 주어질 때, 이 수열의 연속된 부분 수열 중 지그재그 수열 길이의 최댓값을 구하려 합니다.

지그재그 수열이란 첫 번째 원소부터 인접한 원소의 차이가 증가 → 감소 → 증가 → 감소 ... 혹은 감소 → 증가 → 감소 → 증가 ... 순으로 나타나는 수열을 말합니다. 단, 수열의 길이는 3 이상이어야 합니다.

예를 들어 수열이 [ 2, 5, 7, 3, 4, 6, 1, 8, 9]인 경우, 연속된 부분 수열 [5, 7, 3, 4]가 부분 수열 중 가장 긴 지그재그 수열이 됩니다.

부분 수열 중 가장 긴 지그재그 수열의 길이를 구하기 위해 다음과 같이 프로그램 구조를 작성했습니다.

~~~
1. 각 숫자가 바로 이전 숫자보다 증가했는지, 혹은 감소했는지 표시한 배열을 만듭니다.
  1-1. "증가"는 "INC", "감소"는 "DEC"로 표시합니다.
  1-2. 첫 번째 숫자는 증가도, 감소도 하지 않았다는 의미에서 -1로 표시합니다.

2. 1단계에서 만든 증가, 감소 배열을 이용해 각 숫자를 마지막으로 하는 지그재그 수열 중 가장 긴 것의 길이를 담은 배열을 만듭니다.
  2-1. 바로 전 숫자가 "증가"이고 현재 숫자가 "감소"이거나, 전 숫자가 "감소"이고 현재 숫자가 "증가"이면,
       현재 숫자를 마지막으로 하는 지그재그 수열 중 가장 긴 것의 길이는 (바로 전 숫자를 마지막으로 하는 지그재그 수열중 가장 긴 것의 길이 + 1)입니다.
  2-2. 그렇지 않으면 현재 숫자를 마지막으로 하는 지그재그 수열 중 가장 긴 것의 길이는 2입니다.
  2-3. 단, 첫 번째 숫자의 길이는 1로 초기화합니다.

3. 2단계에서 구한 배열에 담긴 값 중 최댓값이 부분 수열 중 가장 긴 지그재그 수열의 길이입니다.
  3-1. 만약 최댓값이 2라면 0을 return 합니다.
  3-2. 그 외에는 최댓값을 return 합니다.
~~~

수열이 담긴 배열 S와 S의 길이 S_len이 매개변수로 주어질 때, 길이가 3 이상인 부분 수열 중 가장 긴 지그재그 수열의 길이를 return 하도록 solution 함수를 작성하려 합니다. 위 구조를 참고하여 코드가 올바르게 동작할 수 있도록 빈칸에 주어진 func_a, func_b, func_c 함수와 매개변수를 알맞게 채워주세요.

---
## 8.1 매개변수 설명
수열이 담긴 배열 S와 S의 길이 S_len이 solution 함수의 매개변수로 주어집니다.

* S_len은 3 이상 100 이하인 자연수입니다.
* S의 원소는 1 이상 100 이하인 자연수이며, 같은 숫자가 중복해서 나타나지 않습니다.

---
## 8.2 return 값 설명
길이가 3 이상인 부분 수열 중 가장 긴 지그재그 수열의 길이를 return 해주세요.

* 만약 지그재그 수열이 없다면 0을 return 해주세요.

---
## 8.3 예제

| S                            | S_len | return |
|------------------------------|---|--------|
| [2, 5, 7, 3, 4, 6, 1, 8, 9]  | 9 | 4      |
| [4, 3, 2, 1, 10, 6, 9, 7, 8] | 9 | 7      |
| [1, 2, 3, 4, 5]              | 5 | 0      |

---
## 8.4 예제 설명

예제 #1
문제 예시와 같습니다.

예제 #2
[2, 1, 10, 6, 9, 7, 8]이 부분 수열 중 가장 긴 지그재그 수열입니다.

예제 #3
부분 수열중 지그재그 수열이 없습니다.

---
# 문제9
스택 두개를 이용해 Queue 자료구조를 만들었을 때, Queue 자료 구조의 pop(또는 dequeue) 함수를 구현하려합니다. Queue란 먼저 삽입한 데이터를 먼저 빼내는 자료구조를 뜻합니다. pop 함수를 만들기 위해 다음과 같이 프로그램 구조를 작성했습니다.

```
1. 스택2가 비었다면 스택1에 아무것도 남지 않을때까지 스택1을 pop한 값을 스택2에 push 한다.
2. 스택2를 pop한 값을 리턴한다.
```

배열 stack1과 정수 stack1_idx, 배열 stack2과 정수 stack2_idx가 solution 함수의 매개변수로 주어집니다. 이때, stack1_idx는 stack1을 스택으로 이용했을 때 stack1의 top의 index를 의미하며, stack2_idx는 stack2를 스택으로 이용했을 때 stack2의 top의 index를 의미합니다. 

두 배열을 스택으로 이용해 Queue 자료 구조의 pop 함수를 구현하려합니다. 위 구조를 참고하여 코드가 올바르게 동작할 수 있도록 빈칸에 주어진 func_a, func_b, func_c 함수와 매개변수를 알맞게 채워주세요.

※ 배열 index가 0인 부분을 스택의 bottom으로 생각합니다.

---

## 9.1 매개변수 설명

배열 stack1과 정수 stack1_idx, 배열 stack2과 정수 stack2_idx가 solution 함수의 매개변수로 주어집니다. 이때, stack1_idx는 stack1을 스택으로 이용했을 때 stack1의 top의 index를 의미하며, stack2_idx는 stack2를 스택으로 이용했을 때 stack2의 top의 index를 의미합니다. 

* stack1과 stack2는 길이가 0 이상 10 이하입니다.
    * stack1과 stack2의 길이가 모두 0인 경우는 주어지지 않습니다.
* stack1과 stack2의 원소는 100 이하인 정수입니다.
* stack1_idx는 -1 이상 stack1의 길이 미만인 정수입니다.
* stack2_idx는 -1 이상 stack2의 길이 미만인 정수입니다.

---

## 9.2 return 값 설명

stack1과 stack2로 구현한 큐를 pop(또는 dequeue)한 값을 return 해주세요.

* 스택이 넘치는 일은 발생하지 않는다고 가정합니다.

---

## 9.3 예시

| stack1 | stack1_idx | stack2 | stack2_idx | result |
|--------|------------|--------|------------|--------|
| [1,2,0,0,0,0,0,0,0,0]  | 1          | [3,4,0,0,0,0,0,0,0,0]  | 1          | 4      |
| [1,2,3,0,0,0,0,0,0,0]  | 2          | [0,0,0,0,0,0,0,0,0,0]  | -1          | 1      |

---
## 9.4 예시 설명

예시 #1
stack2가 비지 않았으므로 stack2를 pop 한 결과인 4를 리턴합니다.

예시 #2

1. stack2가 비었으므로 stack1의 원소를 전부 pop해 stack2로 넣습니다. 이 결과 stack2는 [3,2,1,0,0,0,0,0,0,0]이 됩니다.
2. stack2를 pop한 결과인 1을 리턴합니다.

---
# 문제10
피자별 크기와 가격이 주어질 때, 가장 큰 피자의 크기와 가장 싼 피자의 가격을 찾으려 합니다(단, 크기가 같은 피자나 가격이 같은 피자는 없다고 가정합니다). 이를 위해 다음과 같이 구조체를 정의했습니다.

```
typedef struct Pizza {
    int size;
    int price;
}Pizza;
```

또한 다음과 같이 프로그램 구조를 작성했습니다.

```
1. 피자의 크기와 가격으로 구성된 구조체 배열을 생성 및 초기화합니다.
2. 생성한 구조체 배열을 크기의 내림차순으로 정렬합니다.
3. 정렬한 구조체 배열에서 1번째에 있는 피자의 크기를 answer 배열의 첫번째 원소에 담습니다.
4. 구조체 배열을 가격의 오름차순으로 정렬합니다.
5. 정렬한 구조체 배열에서 1번째에 있는 피자의 크기를 answer 배열의 두번째 원소에 담습니다.
```

피자별 크기를 담은 배열 size와 size의 길이 size_len, 피자별 가격을 담은 배열 price와 price의 길이 price_len이 매개변수로 주어질 때, 가장 큰 피자의 크기와 가장 싼 피자의 가격을 배열에 담아 return 하도록solution 함수를 작성하려 합니다. 위 구조를 참고하여 코드가 올바르게 동작할 수 있도록 빈칸을 채워 전체 코드를 완성해주세요.

---

## 10.1 매개변수 설명
피자별 크기를 담은 배열 size와 size의 길이 size_len, 피자별 가격을 담은 배열 price와 price의 길이 price_len가 solution 함수의 매개변수로 주어집니다.

* size_len과 price_len은 항상 같으며 3 이상 100 이하인 자연수입니다.
* 피자 크기는 1 이상 100 이하인 자연수입니다.
* 피자 가격은 1 이상 100 이하인 자연수입니다.
* 피자들의 크기와 가격은 서로 다릅니다.

---

## 10.2 return 값 설명
가장 큰 피자의 크기와 가장 싼 피자의 가격을 배열에 담아 return 합니다.

---

## 10.3 예제

| size         	| size_len | price    	| price_len | return  |
|------------------|----------|--------------|-----------|---------|
| [10, 20, 30, 40] | 4    	| [3, 1, 5, 4] | 4     	| [40, 1] |

---
## 10.4 예제 설명

크기를 기준으로 정렬하면 [40, 30, 20, 10] 이 됩니다.
가격을 기준으로 정렬하면 [1, 3, 4, 5] 가 됩니다.
따라서 [40, 1] 을 return 합니다.



