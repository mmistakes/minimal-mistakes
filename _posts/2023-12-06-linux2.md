---
layout: single
title:  "ch2. 디렉터리와 파일 사용하기"
---

# 1. 리눅스의 파일과 디렉터리
## 파일의 종류
### 파일: 관련 있는 정보들의 집합
1) 일반 파일 2) 디렉터리 3) 심벌릭 링크 4) 장치 파일
### 1) 일반 파일
데이터를 저장하는데 사용
- 텍스트 파일: 문서 편집기 사용
- 실행 파일, 이미지 파일: 바이너리 파일
- 이미지 파일: 해당 파일의 내용을  확인할 수 있는 특정 응용 프로그램 필요



### 2) 디렉터리

해당 디렉터리에 저장된 파일이나 하위 디렉터리 정보를 저장



### 3) 심벌릭 링크

윈도우의 바로가기 파일과 유사
- 원본 파일을 대신하여 다른 이름으로 파일명을 지정한 것



### 4) 장치파일 

- 리눅스에서는 하드디스크나 키보드 같은 각종 모든 장치도 파일(H/W)로 취급
- 리눅스 시스템에 부착된 장치를 관리하기 위한 특수 파일



## 디렉터리 계층 구조 (트리 구조의 계층 구조 이용)

- 리눅스에서는 파일을 효율적으로 관리하기 위해 디렉터리를 **계층적**으로 구성
- 모든 디렉터리의 출발점은 **루트(root, 뿌리) 디렉터리**이며, ``/`` 으로 표시

### 디렉터리 계층 구조 (트리 구조)
- 하위 디렉터리(서브 디렉터리): 현재 디렉터리 아래에 있는 디렉터리
ex) `/bin, /etc, /home` 
- 상위 디렉터리(부모 디렉터리): 현재 디렉터리 상위에 있는 디렉터리, '..' 으로 표시
ex) `cd ..`

### 작업 디렉터리
- 현재 사용 중인 디렉터리를 **작업 디렉터리 또는 현재 디렉토리** 라고 함
- 현재 디렉터리 `.` 기호로 표시
- 현재 디렉터리의 이름은 `pwd` 명령으로 확인 가능

### 홈 디렉터리
- 각 사용자에게 할당된 디렉터리로 처음 사용자 계정을 만들 때 저장(하나씩 할당)
- 사용자는 자신의 홈 디렉터리 하위에 새로운 파일이나 서브 디렉터리를 생성할 수 있음
- 홈 디렉터리는 `~` 기호로 표시할 수 있음

### 리눅스 주요 디렉터리 내용
`/bin`: 필수적인 실행명령어를 포함하는 디렉터리(ls, pwd, ln, cat, cp, mv, rm 등등)

`/boot`: **리눅스 부팅**에 필요한 커널 파일을 포함하는 디렉터리

`/dev`: 각종 **디바이스(장치) 파일**이 담긴 디렉터리( hda(IDE 하드디스크), sda(SCSI 하드디스크), cdrom(CD-ROM) 등 )

`/home`: 사용자들이 모든 **홈 디렉터리**를 포함하는 디렉터리

`/etc`: **리눅스 설정**을 위한 각종 파일로 포함, 시스템 백업시 이 디렉터리는 잘 저장되어야 함(passwd, group 등) 

`/usr`: 대부분의 **응용 프로그램**들이 이 디렉터리에 설치됨


### 경로명
- 디렉터리 계층 구조에 있는 특정 파일이나 디렉터리의 위치 표시
- 가장 앞에 있는 `/` 는 루트 디렉터리를 뜻하며 경로명 중간에 있는 `/` 는 디렉터리와 파일 사이의 구분자
ex) `/bin/ls` 에서 '맨 앞의 `/`' 는 루트 디렉터리 의미, '중간의  `/`' 는 디렉터리의 이름(bin)과 파일(ls)을 구분

### 절대 경로명
- 항상 루트 디렉터리부터 시작함 (반드시  `/`으로 시작함)
- 루트 디렉터리부터 특정 파일이나 디렉터리의 위치까지 이동하면서 거치게 되는 모든 중간 디렉터리의 이름을 표시
ex) `cd /usr/bin

### 상대 경로명
- 현재 디렉터리를 기준으로 시작함
- 현재 디렉터리를 기준으로 서브 디렉터리로 내려가면 서브 디렉터리 이름을 추가
ex) `cd ../../usr/bin`

### 파일과 디렉터리 이름 규칙
- 파일과 디렉터리 이름에  `/` 사용 불가
- 파일과 디렉터리 이름에 알파벳, 숫자, 붙임표(`-`), 밑줄(`__`), 마침표(`.`) 사용 가능
- 파일과 디렉터리 이름에 공백문자, `*, |, ", ', @, #, $, %, ^, &` 등 사용 불가
- 파일과 디렉터리 이름에 대문자와 소문자를 구별함 ex) hello, Hello
- 파일과 디렉터리 이름에 `.` (마침표)로 시작하면 숨김 파일로 간주

---

# 2. 디렉터리 관련 명령

### 현재 디렉터리 확인 (pwd: print working directory)
```
user1@myubuntu:~$ pwd
/home/user1
```
- 현재 디렉터리의 위치(절대 경로명)

### 디렉터리 이동 (cd: change directory)
- `cd [디렉터리]`
- [디렉터리]에 절대 경로명 또는 상대 경로명 이동할 디렉터리 지정
```
user1@myubuntu:~$ cd ..
user1@myubuntu:~$ cd /tmp        # 절대 경로명
user1@myubuntu:~$ cd ../usr/lib  # 상대 경로명
```

### 사용자(user1)의 홈(home) 디렉터리로 이동하는 방법
1) `cd /home/user1` (절대 경로명을 사용하여 홈 디렉터리로 이동)
2) `cd ~` (홈 디렉터리를 나타내는 기호인 ~를 사용하여 홈 디렉터리로 이동)
3) `cd ` (목적지를 지정하지 않고 cd 명령만 사용하여 홈 디렉터리 이동)


### 디렉터리 내용 확인 (ls: list)
- 가장 많이 사용하는 명령어, 옵션이 매우 많음
- `ls [옵션][디렉터리]`
- `user1@myubuntu:~$ ls`



>기능: 디렉터리 내용을 출력한다
>
>형식:  ls <옵션> <디렉터리(파일)>
>
>옵션:
>
>`-a`: 숨김 파일을 포함하여 모든 파일의 목록을 출력 
>
>`-d`: 디렉터리 자체의 정보 출력 
>
>`-i`: 첫 번째 행에 inode 번호 출력 
>
>`-l`: 파일의 상세 정보를 출력
>
>`-A`: . (마침표)와 ..(마침표 두개)를 제외한 모든 파일 목록을 출력
>
>`-F`: 파일의 종류를 표시(* : 실행파일, /: 디렉터리, @: 심벌릭 링크)
>
>`-L`: 심벌릭 링크 파일의 경우 원본 파일의 정보를 출력
>
>`-r`: 하위 디렉터리의 목록까지 출력
>
>`ls /tmp`: 지정한 디렉터리 내용 확인
>
>ex) `ls` , `ls -F`, `ls -al/tmp`


### 파일 존재 확인 (ls [파일 이름])
- ls 에서 인자로 지정한 파일이 없으면 없다는 메시지 출력


### 디렉터리 만들기 (mkdir: make directory)
- 디렉터리를 생성
- `mkdir [옵션] 디렉터리`
- `user1@myubuntu:~$ mkdir temp`



>기능: 디렉터리를 생성
>
>형식: `mkdir [옵션] 디렉터리`
>
>옵션:
>
>`-p`: 하위 디렉터리를 계층적으로 생성할 때 중간 단계의 디렉터리가 없다면,
>
>자동으로 중간 단계 디렉터리를 생성하면서 전체 디렉티를 생성      
>
>ex) `ls` , `ls -F`, `ls -al/tmp`


### 디렉터리 한 개 만들기
`user1@myubuntu:~$ mkdir temp`


### 동시에 디렉터리 여러개 만들기
`$ mkdir tmp1 tmp2 tmp3`
- 디렉터리 이름들은 공백문자로 구분


### 중간 디렉터리 자동으로 만들기: -p 옵션
`$ mkdir temp/mid/han`    X
`$ mkdir -p temp/mid/han`   O
`-p` 옵션: 중간 단계의 디렉터리가 없을 경우 자동으로 중간 단계 디렉터리를 생성한 후 최종 디렉터리를 생성

### 디렉터리 삭제하기 (rmdir: remove directory)
- `rmdir [옵션] 디렉터리`
- `user1@myubuntu:~$ rmdir temp`



>기능: 디렉터리를 삭제
>
>형식: rmdir [옵션] 디렉터리
>
>옵션:
>
>`-p`: 지정한 디렉터리를 삭제하며, 그 디렉터리의 부모 디렉터리가 빈 디렉터리일 경우 부모 디렉터리도 자동 삭제   
>
>, 하위에 디렉터리가 비어있지 않다면 삭제 X                 
>
>ex) `rmdir temp`


---

# 3. 파일 관련 명령

### 파일 내용 연속 출력 (cat: concatenate)
- 텍스트 파일 내용 확인 (-n 옵션: 출력할 때 행 번호를 붙임)
- `$ cat /etc/hosts`
- `$ cat -n /etc/hosts  # 출력할 떄 행 번호 붙여서 출력`



>기능: 파일 내용을 출력
>
>형식: `cat [옵션] 파일
>
>옵션:
>
>`-n`: 행 번호를 붙여서 출력한다       
>
>ex) `cat file1`  `cat -n file1`


### 화면 단위로 파일 내용 출력 (more)
- cat 명령에서 파일 내용이 많아 스크롤 되는 경우를 보완한 명령어 ( cat 보완 -> more(스크롤O) )
- `Space bar`: 다음 화면으로 이동(스크롤)
- `Enter`: 한 줄 씩 이동(스크롤)
- `/문자열`: 문자열 검색(현재 화면 이후부터 검색)
- `n`: 다음 문자열 검색
- `q`: more 명령 종료
- `$ more /etc/services`



>기능: 파일 내용을 화면 단위로 출력
>
>형식: `more [옵션] 파일
>
>옵션:
>
>`+행 번호`: 출력을 시작할 행 번호를 지정      
>
>ex) `more file1`


### 개선된 화면 단위 파일 내용 출력하기 (less)
- **스크롤 되어 지나간 내용도 확인 가능**
- `j`: 한 줄씩 다음 행 스크롤
- `k`: 한 줄씩 이전 행 스크롤
- `q`: less 명령 종료
- `/문자열`: 해당 문자열 검색(현재 화면부터 검색)
- `n`: 다음 문자열 검색
- `Space Bar` 또는 `Ctrl+f` : 다음 화면으로 이동
- `Ctrl+b` : 이전 화면으로 이동
`$ less /etc/services`



>기능: 파일 내용을 화면 단위로 출력
>
>형식: `less 파일`                 
>
>ex) `less file1`


### 파일 뒷부분 출력하기 (tail)
- 파일의 마지막 10행 출력 (옵션을 이용하여 출력되는 행의 수를 결정)
- `$ tail /etc/services`



>기능: 파일 뒷부분의 몇 행을 출력
>
>형식: `tail [옵션] 파일`
>
>옵션:
>`+행 번호`: 지정한 행부터 끝까지 출력
>`-숫자`: 화면에 출력할 행의 수를 지정(기본값 10)
>`-f`: 파일 출력을 종료하지 않고 주기적으로 계속 출력한다.
>
>ex) `tail /etc/services`

#### 파일 뒷부분 출력하기 (tail -숫자, tail -f)
- 지정한 숫자만큼 출력하기: `-숫자 옵션`
- 파일의 마지막 7행 출력(옵션을 이용하여 출력되는 행 수정 가능)
- `$ tail -7 /etc/services`

##### 파일 내용을 주기적으로 반복 출력하기: -f 옵션
- 파일 출력이 종료되지 않고 대기 상태가 되며 파일 내용이 주기적으로 반복 출력(파일 뒷부분에 내용 추가) 
 -> 자동 출력
- `$ tail -f /etc/services`
- 강제 종료 필요 (`Ctrl + c`)


### 파일(디렉터리) 복사하기 (cp)
- 파일(디렉터리)을 복사할 때 사용
- `cp [옵션] 파일1(디렉터리1) 파일2(디렉터리2)`
- `파일1(첫 번째 인자)`: 원본 파일명(디렉터리명)
- `파일2(두 번째 인자)`: 목적지 파일명(디렉터리명)



>기능: 파일이나 디렉터리를 복사한다
>
>형식: `cp [옵션] 파일1 (디렉터리1) 파일 2(디렉터리2)
>
>옵션:
>
>`-i` : 파일2가 존재하면 덮어쓸 것인지 물어본다
>
>`-r` : 디렉터리를 복사할 때 지정 (디렉터리 간 복사)
>
>ex) `cp file1 file2`  `cp f1 f2 f3 dir1`  `cp -r dir1 dir2`

**두 인자가 모두 파일인 경우** - 파일을 다른 파일로 복사한다.
`$ cp /etc/hosts text1`

- /etc/hosts 파일을 현재 디렉터리의 text1 파일로 복사

**두 번째 인자가 디렉터리인 경우** - 첫 번째 인자의 파일을 두 번째 인자의 디렉터리 아래에 복사
- temp 디렉터리에 text1 파일 복사
```
user1@myubuntu:~/lunux_ex/ch2$ mkdir temp
user1@myubuntu:~/lunux_ex/ch2$ cp text1 temp
user1@myubuntu:~/lunux_ex/ch2$ ls temp
text1
user1@myubuntu:~/lunux_ex/ch2$
```

- temp 디렉터리 내 원본 파일과 다른 이름과 복사

```
user1@myubuntu:~/lunux_ex/ch2$ cp text1 temp/text2
user1@myubuntu:~/lunux_ex/ch2$ ls temp
text1 text2
user1@myubuntu:~/lunux_ex/ch2$
```

- 쓰기 권한이 없는 디렉터리에 파일을 복사하면, 다음과 같은 오류 발생

```
$ cp text1 /etc
cp: 일반 파일 'etc/text1'을 생성할 수 없음: 허가 거부
```

여러 개의 파일을 한 번에 복사하는 경우 (첫 번째 인자를 여러 개 지정)
- 명령에서 첫 번째 인자에 파일명을 여러 개 지정 가능, 다만 두 번째 인자는 반드시 디렉터리임
(여러 개 파일이 해당 디렉터리 내에 모두 복사)
```
user1@myubuntu:~/lunux_ex/ch2$ cp /etc/hosts /etc/services temp
user1@myubuntu:~/lunux_ex/ch2$ ls temp
hosts services text1 text2
user1@myubuntu:~/lunux_ex/ch2$
```

- 파일 복사할 때, -i 옵션 사용하기

- 복사하고자 하는 파일이 이미 존재하는 경우, 덮어쓸 것인지 물어봄(대답 y or n)
```
$ cp -i /etc/hosts text1
cp: 'text1' 를 덮어쓸까요? n
```

- 디렉터리 간의 복사 (-r 옵션 이용)

- 디렉터리 복사는 -r 옵션을 사용함 (디렉터리 내의 모든 내용도 같이 복사)
- 첫 번째, 두 번째 인자 모두 디렉터리
- 두 번째 인자로 지정한 목적지 디렉터리가 존재하지 않는 경우는 새로 생성
- temp 디렉터리를 temp2 디렉터리로 복사
`user1@myubuntu:~/lunux_ex/ch2$ cp -r temp temp2`


### 파일 이동하고 파일명 바꾸기 (mv)
- 파일을 다른 디렉터리로 이동하거나 파일명을 바꿀 때 mv 명령 사용
- 디렉터리를 이동하거나 디렉터리명을 바꿀 때도 mv 명령 사용
- `mv [옵션] 파일1(디렉터리1) 파일2(디렉터리2)`
- 파일1(첫번째 인자): 원본 파일명(디렉터리명)
- 파일2(두번째 인자): 목적지 파일명(디렉터리명)



>기능: 파일을 이동한다
>
>형식: `mv [옵션] 파일1 (디렉터리1) 파일 2(디렉터리2)
>
>옵션:
>
>`-i` : 파일2(디렉터리2)가 존재하면 덮어쓸 것인지 물어본다
>
>ex) `mv file1 file2`

#### 파일을 다른 파일로 이동하기(= 파일명 바꾸기)
- 두 번째 인자로 지정한 파일명 이미 존재 -> 원본 파일의 내용을 덮어쓰고 기존 내용 삭제됨
- text1 파일을 data1 파일로 이동 (파일명 변경)
- `user1@myubuntu:~/lunux_ex/ch2$ mv text1 data1
```
user1@myubuntu:~/lunux_ex/ch2$ mv text1 data1
user1@myubuntu:~/lunux_ex/ch2$ ls
data1 one temp temp2                # data1안에 text1 파일이 이동한 상태
user1@myubuntu:~/lunux_ex/ch2$
```

#### 파일을 다른 디렉터리로 이동하기
- 두 번째 인자로 디렉터리를 지정할 경우 원본 파일을 지정한 디렉터리로 이동
- data1 파일을 temp 디렉터리로 이동
- `$ mv data1 temp`

- 두 번째 인자에 디렉터리와 파일명을 함께 지정 -> 파일이 지정한 디렉터리의 지정한 파일 이름으로 이동
- `$ cp temp/data1 text1`
- `$ mv text1 temp/data2`

#### 파일 여러 개를 디렉터리로 이동하기
- 파일 여러 개를 지정 디렉터리로 한 번에 이동, 두 번째 인자는 반드시 디렉터리
- temp/data1 파일과 temp/data2 파일을 현재 디렉터리(.)로 이동
- `$ mv temp/data1 temp/data2 .`

- -i 옵션: 두 번째 인자의 파일명이 기존에 있는 파일인 경우 overwrite 물어봄(y or n)
- `$ mv -i data1 data2
-> `mv: 'data2'를 덮어쓸까요? n 

#### 디렉터리를 디렉터리로 이동 (디렉터리명 바꾸기)
- 두 개 인자를 모두 디렉터리로 지정하면 디렉터리가 이동됨(디렉터리명 변경)
- temp2 디렉터리가 temp3 디렉터리로 이름 변경
- `user1@myubuntu:~/lunux_ex/ch2$ mv temp2 temp3`
- 두 번째 인자가 기존에 있던 디렉터리일 경우, 원본 디렉터리가 두 번째 디렉터리의 하위로 이동
- temp3 디렉터리가 temp 디렉터리 아래(하위)로 이동
- `user1@myubuntu:~/lunux_ex/ch2$ mv temp3 temp`
```
user1@myubuntu:~/lunux_ex/ch2$ ls
temp temp3
user1@myubuntu:~/lunux_ex/ch2$ mv temp3 temp
user1@myubuntu:~/lunux_ex/ch2$ ls
temp
user1@myubuntu:~/lunux_ex/ch2$ ls temp
hosts services temp3             # temp3 가 temp 하위로 이동했다.
```




### 파일 삭제하기 (rm)
- 삭제할 파일을 인자로 지정하면 해당 파일이 삭제됨 (복구 불가능)
- data2 파일 삭제
- `user1@myubuntu:~/lunux_ex/ch2$ rm data2`



>기능: 파일을 삭제한다
>
>형식: `rm [옵션] 파일(디렉터리)
>
>옵션:
>
>`-i` : 파일2(디렉터리2)가 존재하면 덮어쓸 것인지 물어본다
>
>`-r`: 디렉터리를 삭제할 때 지정한다
>
>ex) `rm file`  `rm -r dir`

#### -i 옵션 사용하기
- rm 명령 사용 시, 정말 삭제할 것인지 물어봄
- `user1@myubuntu:~/lunux_ex/ch2$ rm -i data1`

#### 디렉터리 삭제하기
- rm 명령으로 디렉터리를 지울 때는 -r 옵션 이용(삭제 디렉터리는 복구 불가)
- `$ mkdir temp3`
- `$ rm temp3`  <- 디렉터리 삭제 오류
- `$ rm -r temp3`  <- 디렉터리 삭제

#### 디렉터리 삭제하기 (rm과 rmdir 비교)
- rmdir 명령으로 temp3을 삭제, temp3 디렉터리가 비어있지 않다면 오류 메세지 출력
- `$ cp -r temp4 temp4`  <- temp4 디렉터리 복사
- `$ rm temp4`  <- 디렉터리 삭제 오류(빈 디렉터리 X)
- `$ rmdir temp4`  <- 디렉터리가 비어있지 않아 삭제 X (-r 옵션 X)
- `$ rm -r temp4`  <- 디렉터리 삭제 완료

`-i 옵션`: 삭제하려는 파일이나 디렉터리를 삭제할 것인지 물어봄 (y or n)

```
user1@myubuntu:~/lunux_ex/ch2$ rm -ri temp
rm: 'temp' 디렉터리로 내려가겠습니까? y
rm: 일반 파일 'temp/services'를 제거할까요? y
rm: 일반 파일 'temp/hosts'를 제거할까요? n
```

---

## 리눅스 파일 구성

**파일 구성 = 파일명 + inode 테이블 + 데이터 블록**
- `파일명`: 사용자가 파일에 접근할 때 사용하는 파일 이름
- `inode 테이블`: 파일에 대한 정보를 가지는 구조체 (inode 번호, 파일 종류, 크기, 소유자, 파일 변경 시간 등의 파일 상세 정보와 데이터 블록 주소 저장)

파일의 고유한 inode 번호는 `ls -i` 명령으로 확인 가능
- 파일명 앞에 출력된 숫자가 inode 번호, 파일 이름은 달라도 inode 번호가 같으면 같은 파일을 가리킴
```
user1@myubuntu:~/lunux_ex/ch2$ ls -i
655669 data1  655672 temp  655678 test.org
```


**파일 구성 = 파일명 + inode 테이블 + 데이터 블록**
- `data1.hl` : data1의 하드링크라고 가정 ( inode 번호, 데이터블록주소가 같다)
(*바로가기*- 파일의 상세정보의 변경-> 다같이 바뀐다)
- `data2.sl` : data1의 심벌릭링크라고 가정 ( inode 번호만 다르다)
(*바로가기*- 새로운 파일이 생겼지만 변경이 있다면 다같이 바뀐다(이름, inode번호는 다름, 데이터블록주소만 같다))

### 파일 링크 만들기 (기존 파일에 새로운 이름을 붙이는 것)
- 복잡한 디렉터리 계층 구조를 포함하여 파일명이 복잡할 경우, 짧게 줄인 다른 이름을 붙여서 간단하게 사용하는 목적
`하드링크`: 기존 파일에 새로운 파일명을 추가로 생성(파일)
`심벌릭 링크`: 원본 파일을 가리키는 새로운 파일 생성 (윈도우의 바로가기) (파일, 디렉터리)

#### 하드 링크 만들기 (ln: link)
- 한 파일에 여러 개 이름을 붙임, 추가로 붙이는 파일명을 하드링크
- data1 에 대한 하드링크 data.hl (하드링크 이름은 임의로 줌) 생성
- `$ ln data1 data1.hl`



>기능: 파일의 링크를 생성한다
>
>형식: `ln [옵션] 원본파일 링크파일
>
>옵션:
>
>`-s` : 심벌릭 링크 파일을 생성한다
>
>ex) 
>
>`ln test lntest`       <- ln(하드링크 만듬)  
>
>`ln -s test lntest` <- ln -s(심벌링 링크를 만듬)


(1) 하드링크 생성 후, data1과 data1.hl 파일의 inode 번호가 같은지, 하드 링크 개수 확인
`$ ls -il`  <- i는 inode 번호, l은 링크 개수 확인

(2) 하드링크 생성 후, data1과 data1.hl 파일의 내용이 같은지 비교
`$ cat data1`  # 원본파일
`$ cat data1.ln`  # 하드링크

#### 하드 링크(ln)와 복사(cp)의 차이점
- data1의 복사 파일 data1.cp를 만들고 inode 번호 확인
```
user1@myubuntu:~/lunux_ex/ch2$ cp data1 data1.cp
user1@myubuntu:~/lunux_ex/ch2$ ls -i
```

**하드링크(ln)는 하나의 파일을 공유하는 여러 개의 [파일 이름]을 만드는 것
복사(cp)는 원본 파일과 내용만 동일한 [다른 파일]을 만드는 것**
- `data1.hl` 파일의 내용을 수정 -> data1 파일에도 반영
- `data1.cp` 파일의 내용을 수정 -> data1 파일에는 반영X


#### 심벌릭 링크 만들기 (ln -s)
- data1 파일의 심벌릭 링크로 data1.sl 생성하고 확인
- `user1@myubuntu:~/lunux_ex/ch2$ ln -s data1. data1.sl`
- `user1@myubuntu:~/lunux_ex/ch2$ ls -il`
data1.sl 은 새로운 inode 번호를 가지는 파일이나, data1 파일을 포인터로 가리키고 있음
그러므로 심벌릭 링크 파일의 inode 번호는 원본 파일과 다름

`ls -l` 명령으로 확인하면 파일 종류가 `l`로 표시, 파일명 `->`를 사용하여 원본 파일을 가리킴
```
user1@myubuntu:~/lunux_ex/ch2$ ln -s data1 data1.sl  # data1파일 심벌릭 링크
user1@myubuntu:~/lunux_ex/ch2$ ls -i
user1@myubuntu:~/lunux_ex/ch2$ ls -l data1.sl       # data1.sl 파일 명령으로 확인
lrwxrwxrw 1 uder1 11월 12 11:26 data1.sl -> data1   # ->로 원본파일을 가리킴
```


#### 심벌릭 링크(ln -s) 파일의 특징
- 파일 종류가 `l`로 표시됨 `lrxwrswrsws`
- 하드 링크의 개수가 증가하지 않음
- 파일명 뒤에 원본 파일명이 표시됨 `data1.sh -> data1`
- inode 번호가 원본 파일과 다름 `원본 파일과 심벌릭 링크 파일은 다른 파일`
- data1 이 수정되면 data.sl 도 반영 `반대도 마찬가지`
- 디렉터리에도 심벌릭 링크 생성 가능 `하드 링크는 불가능`
- 원본 파일(data1)이 삭제되면 심벌릭 링크로 연결 불가능 `data1.sl 사용 불가능`

---


### 파일 내용 검색 (grep)
- 파일 내에서 특정 문자열 검색 (정규 표현식 이용하여 복잡한 검색 가능)
- 정규 표현식은 생략 (map grep 또는 웹 검색 참고)
- ` grep [옵션] 패턴 파일`



>기능: 지정한 패턴이 포함된 행을 찾는다
>
>형식: `grep [옵션] 패턴 파일`
>
>옵션:
>
>`-i` : 대문자, 소문자를 모두 검색한다
>
>`-l` : 지정한 패턴이 포함된 파일명을 출력한다
>
>`-n` : 행 번호를 출력한다
>
>ex) 
>
>`grep root /etc/passwd`  # passwd 파일에서 root 를 검색한다
>
>`grep -l hello *.c`          # 모든 .c 파일에서 hello 가 포함된 파일명을 출력한다
>
>`grep -n unix ~/*.txt`    # 홈에 있는 모든 .txt 파일에서 unix 가 포함된 행 번호를 출력한다



#### 파일 내용 검색하기 (grep)

```
$ cp /etc/services data
$ grep NNTP data  # data 파일에 NNTP가 포함된 행 검색
$ grep -n NNPT data  # 줄 번호 포함 옵션 -n
$ grep -i NNTP data  # 대소문자 구분 없음
```

### 파일 찾기 (find)
- 리눅스의 디렉터리 계층 구조에서 특정 파일이 어느 디렉터리에 있는지 검색
- 파일 생성일자와 이름, 소유자 등 다양한 조건에 맞는 파일을 검색
- `find [경로][옵션][동작]`



>기능: 지정한 위치에서 조건에 맞는 파일을 찾는다
>
>형식: `find [경로 검색 조건][동작]`
>
>옵션:
>
>`-name filename` : 파일명으로 검색한다
>
>`-type 파일 종류` : 파일 종류로 검색한다
>
>`-user loginID` : 지정한 사용자가 소유한 모든 파일을 검색한다
>
>`-perm 접근 권한` : 지정한 사용 권한과 일치하는 파일을 검색한다
>
>동작:
>
>`-exec 명령 {}\;` : 검색된 파일에 명령을 실행한다
>
>`-ok 명령 {}\;` :  사용자의 확인을 받아서 명령을 실행한다
>
>`-print` : 검색된 파일의 절대 경로명을 화면에 출력한다(기본 동작)
>
>`-ls` :  검색 결과를 긴 목록 형식으로 출력한다
>
>ex) 
>
>`find ~ -name hello.c`     # 홈 화면에서 hello.c 파일명을 검색한다
>
>`find /tmp -user user10 -exec rm {}\;`  # /tmp 디렉터리에서 user10에 검색된 파일에 삭제 명령을 실행



#### 파일 찾기 (find)

- /bin 디렉터리에서 -name 옵션을 사용하여 ls 파일의 위치 검색
- `/usr/bin`은 경로, `-name ls`는 검색어 
```
$ find /bin -name ls
/bin/ls
```

특정 사용자 계정이 소유자인 파일을 찾고 싶으면 `-user` 옵션 사용
```
$ find /home -user user1
/home/user1
/home/user1/다운로드
(생략)
```

```
$ find . -name data       # data -> data만
$ find . -name 'data?'    # data? -> 한 자만 포함
# find . -name 'data*'.   # data* -> 모두 포함(이름, 파일)
```

**`find`로 검색한 파일을 대상으로 작업을 수행하려면 `-exec`나 `-ok` 옵션 사용**
`/tmp`디렉터리 아래에 있는 user1 계정 소유의 파일을 전부 찾아서 삭제
```
$ find /tmp -user user1 -exec rm {} \;
$ find /tmp -user user1 -ok rm {} \;
```


---

# 요약
- 파일 종류 `일반 파일, 디렉터리, 심벌릭 링크, 장치 파일`
- 경로 종류 `절대 경로, 상대 경로`
- 디렉터리 사용 명령어 `pwd, cd, ls, mkdir, rmdir`
- 파일 사용 명령어 `파일 내용 출력: cat, more, less, tail`
- 파일 사용 명령어 `파일 복사, 이동 삭제: cp, mv, rm`
- 파일 사용 명령어 `링크 파일 생성: ln, ln -s`
- 파일 사용 명령어 `찾기: grep, find`
