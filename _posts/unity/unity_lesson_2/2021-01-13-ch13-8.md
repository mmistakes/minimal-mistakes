---
title:  "Chapter 13-8. ë¯¸ë‹ˆ RPG : ëª¬ìŠ¤í„° AI" 

categories:
  -  Unity Lesson 2
tags:
  - [Game Engine, Unity]

toc: true
toc_sticky: true

date: 2021-01-13
last_modified_at: 2021-01-13
---

ì¸í”„ëŸ°ì— ìˆëŠ” Rookissë‹˜ì˜ **[C#ê³¼ ìœ ë‹ˆí‹°ë¡œ ë§Œë“œëŠ” MMORPG ê²Œì„ ê°œë°œ ì‹œë¦¬ì¦ˆ] Part3: ìœ ë‹ˆí‹° ì—”ì§„** ê°•ì˜ë¥¼ ë“£ê³  ì •ë¦¬í•œ í•„ê¸°ì…ë‹ˆë‹¤. ğŸ˜€  
[ğŸŒœ ê°•ì˜ ë“¤ìœ¼ëŸ¬ ê°€ê¸° Click](https://www.inflearn.com/course/MMORPG-ìœ ë‹ˆí‹°)
{: .notice--warning}


# Chapter 13. ë¯¸ë‹ˆ RPG ë§Œë“¤ê¸°

## ğŸš€ ëª¬ìŠ¤í„° AI

- ğŸ“œBaseController ğŸ‘‰ í”Œë ˆì´ì–´ì™€ ëª¬ìŠ¤í„°ì˜ ê³µí†µì ì¸ ì†ì„±ê³¼ ê¸°ëŠ¥ ëª¨ìŒ
  - ğŸ“œPlayerController
  - ğŸ“œMonsterController

ğŸ“œMonsterControllerì™€ ğŸ“œPlayerControllerì˜ ê³µí†µì ì¸ í•¨ìˆ˜ ë° ë©¤ë²„ë“¤ì€ ğŸ“œBaseControllerë¡œ ì˜®ê²¨ì£¼ì—ˆìŒ. ëª¬ìŠ¤í„° ì• ë‹ˆë©”ì´ì…˜ ì»¨íŠ¸ë¡¤ëŸ¬ì˜ ì• ë‹ˆë©”ì´ì…˜ í´ë¦½ì˜ ì´ë¦„ë“¤ë„ í”Œë ˆì´ì–´ ì• ë‹ˆë©”ì´ì…˜ ì»¨íŠ¸ë¡¤ëŸ¬ì™€ ë™ì¼í•˜ê²Œ. 

### ğŸ“œMonsterController

> ëª¬ìŠ¤í„° ì˜¤ë¸Œì íŠ¸ì— ë¶™ì—¬ì¤€ë‹¤.

ğŸ“œPlayerController ì™€ ìƒë‹¹ìˆ˜ ë¹„ìŠ·í•˜ë‹¤. ì—¬ê¸°ì— ì—†ëŠ”ê±´ ğŸ“œBaseControllerë¡œë¶€í„° ìƒì† ë°›ìŒ.

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class MonsterController : BaseController
{
    Stat _stat;

    [SerializeField]
    float _scanRange = 10;

    [SerializeField]
    float _attackRange = 2;

    public override void Init()
    {
        _stat = gameObject.GetComponent<Stat>();

        if (gameObject.GetComponentInChildren<UI_HPBar>() == null)
            Managers.UI.MakeWorldSpace<UI_HPBar>(transform);
    }
```

- ê²Œì„ì´ ì‹œì‘ë˜ë©´ `UI_HPBar`ë¥¼ ëª¬ìŠ¤í„°ì—ê²Œ ë¶™ì¸ë‹¤.
  - ğŸ“œBaseControllerë¡œë¶€í„° ì´ *Init*ì„ ì‹¤í–‰ì‹œí‚¤ëŠ” *Start* ë¥¼ ìƒì† ë°›ìŒ

```c#
    protected override void UpdateIdle()
    {
        Debug.Log("Monster UpdateIdle");

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player == null)
            return;

        float distance = (player.transform.position - transform.position).magnitude;
        if (distance <= _scanRange)
        {
            _lockTarget = player;
            State = Define.State.Moving;
            return;
        }
    }
```

- *UpdateIdle* ğŸ‘‰ ëª¬ìŠ¤í„°ê°€ `Idle` ìƒíƒœì¼ ë•Œ ë§¤í”„ë ˆì„ ì‹¤í–‰í•  ì¼
  - "Player"íƒœê·¸ë¥¼ ê°€ì§„ ì˜¤ë¸Œì íŠ¸ë¥¼ ì°¾ì•„ `player`ì— í• ë‹¹. í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸ ì°¾ê¸°.
    - í”Œë ˆì´ì–´ê°€ ì‚¬ì •ê±°ë¦¬ë‚´ì— ì¡´ì¬í•˜ë©´ `_lockTarget`ì— í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸ í• ë‹¹í•˜ê³  ì´ì œ í”Œë ˆì´ì–´ ì«“ì•„ê°€ì•¼ í•˜ë‹ˆê¹Œ ìƒíƒœë¥¼ `Moving`ìœ¼ë¡œ ë³€ê²½

```c#
    protected override void UpdateMoving()
    {
        Debug.Log("Monster UpdateMoving");

        // í”Œë ˆì´ì–´ê°€ ë‚´ ì‚¬ì •ê±°ë¦¬ë³´ë‹¤ ê°€ê¹Œìš°ë©´ ê³µê²©
        if (_lockTarget != null)
        {
            _destPos = _lockTarget.transform.position;
            float distance = (_destPos - transform.position).magnitude;
            if (distance <= _attackRange)
            {
                State = Define.State.Skill;
                return;
            }
        }

        // ê¸¸ ì°¾ê¸° ì´ë™
        Vector3 dir = _destPos - transform.position;
        if (dir.magnitude < 0.1f)
        {
            State = Define.State.Idle;
        }
        else
        {
            NavMeshAgent nma = gameObject.GetOrAddComponent<NavMeshAgent>();
            nma.SetDestination(_destPos);
            nma.speed = _stat.MoveSpeed;

            transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(dir), 20 * Time.deltaTime);
        }
    }
```

- *UpdateMoving* ğŸ‘‰ ëª¬ìŠ¤í„°ê°€ `Moving` ìƒíƒœì¼ ë•Œ ë§¤í”„ë ˆì„ ì‹¤í–‰í•  ì¼
  - 'ì‹œì•¼' ì‚¬ì •ê±°ë¦¬ë³´ë‹¤ ê°€ê¹Œìš°ë©´ *UpdateIdle* ë¥¼ í†µí•´ `_lockTarget`ì— í”Œë ˆì´ì–´ ë“¤ì–´ìˆëŠ” ìƒíƒœ
    - í”Œë ˆì´ì–´ë¥¼ í–¥í•´ `_destPos` ì—…ëƒí•˜ê³  
    - í”Œë ˆì´ì–´ê°€ 'ê³µê²©' ì‚¬ì •ê±°ë¦¬ë³´ë‹¤ ê°€ê¹Œìš°ë©´ ê³µê²©. ê·¸ë¦¬ê³  ê¸¸ ì°¾ì„ í•„ìš” ì—†ìœ¼ë‹ˆ return
  - ê¸¸ ì°¾ê¸°
    - ë„ì°©í–ˆë‹¤ë©´ `Idle` ìƒíƒœë¡œ ëŒì•„ê°€ê¸°
    - ì•„ë‹ˆë¼ë©´ í”Œë ˆì´ì–´ í–¥í•´ ë°”ë¼ë³´ë©° ì«“ì•„ê°€ì•¼ í•¨..

```c#
    protected override void UpdateSkill()
    {
        Debug.Log("Monster UpdateSkill");

        if (_lockTarget != null)
        {
            Vector3 dir = _lockTarget.transform.position - transform.position;
            Quaternion quat = Quaternion.LookRotation(dir);
            transform.rotation = Quaternion.Lerp(transform.rotation, quat, 20 * Time.deltaTime);
        }
    }
```

- *UpdateSkill* ğŸ‘‰ ëª¬ìŠ¤í„°ê°€ `Skill` ìƒíƒœì¼ ë•Œ ë§¤í”„ë ˆì„ ì‹¤í–‰í•  ì¼
  - ê³µê²© ì¤‘ì— í”Œë ˆì´ì–´ ë°”ë¼ë³´ê³  ê³µê²©í•˜ê²Œë”

```c#
    void OnHitEvent()
    {
        Debug.Log("Monster OnHitEvent");

        if (_lockTarget != null) // í”Œë ˆì´ì–´ íƒ€ê²ŸíŒ… ì¤‘
        {
            // ì²´ë ¥
            Stat targetStat = _lockTarget.GetComponent<Stat>();
            int damage = Mathf.Max(0, _stat.Attack - targetStat.Defense);
            targetStat.Hp -= damage;

            if (targetStat.Hp > 0)
            {
                float distance = (_lockTarget.transform.position - transform.position).magnitude;
                if (_attackRange >= distance)
                    State = Define.State.Skill;
                else
                    State = Define.State.Moving;
            }
            else
            {
                State = Define.State.Idle;
            }
        }
        else  // í”Œë ˆì´ì–´ íƒ€ê²ŸíŒ… ì¤‘ì´ ì•„ë‹ ë•
        {
            State = Define.State.Idle;
        }
    }
}
```

- *OnHitEvent* ğŸ‘‰ ëª¬ìŠ¤í„°ì˜ ê³µê²© ì• ë‹ˆë©”ì´ì…˜ ì¤‘ ë°œìƒí•˜ëŠ” ì´ë²¤íŠ¸
  - í”Œë ˆì´ì–´ì˜ ì²´ë ¥ ê¹ê¸° 
    - í”Œë ˆì´ì–´ê°€ ì•„ì§ ì•ˆ ì£½ì—ˆë‹¤ë©´ 
      - ê³µê²© ì‚¬ì •ê±°ë¦¬ ì´ë‚´ë¼ë©´ ë‹¤ì‹œ ê³µê²©
      - ì•„ë‹ˆë¼ë©´ ë‹¤ì‹œ ì«“ê¸°
    - í”Œë ˆì´ì–´ê°€ ì£½ì—ˆë‹¤ë©´
      - ì •ì§€


<br>

### âœˆ ì´ë™ì‹œ ë°€ë¦¬ëŠ” í˜„ìƒ

#### ğŸ“œMonsterController : ëª¬ìŠ¤í„°ê°€ ì´ë™ì‹œ í”Œë ˆì´ì–´ë¥¼ ë¯¸ëŠ” í˜„ìƒ 

```c#
    protected override void UpdateMoving()
    {
        Debug.Log("Monster UpdateMoving");

        // í”Œë ˆì´ì–´ê°€ ë‚´ ì‚¬ì •ê±°ë¦¬ë³´ë‹¤ ê°€ê¹Œìš°ë©´ ê³µê²©
        if (_lockTarget != null)
        {
            _destPos = _lockTarget.transform.position;
            float distance = (_destPos - transform.position).magnitude;
            if (distance <= _attackRange)
            {
                NavMeshAgent nma = gameObject.GetOrAddComponent<NavMeshAgent>();
                nma.SetDestination(transform.position);
                State = Define.State.Skill;
                return;
            }
        }
```
```c#
            if (distance <= _attackRange)
            {
                NavMeshAgent nma = gameObject.GetOrAddComponent<NavMeshAgent>();
                nma.SetDestination(transform.position);
```

ê³µê²©í•  ë•Œë„ ê³„ì† ì§§ì€ ìƒˆ ë§ˆë‹¤ í”Œë ˆì´ì–´ë¥¼ ì«“ì§€ ì•Šë„ë¡(ë°€ì§€ ì•Šë„ë¡), ê³µê²© ì‚¬ì • ê±°ë¦¬ ë‚´ì— ìˆìœ¼ë©´ ê·¸ëƒ¥ ì œìë¦¬ì— ìˆë„ë¡ `nma.SetDestination(transform.position)`

<br>

#### ğŸ“œPlayerController : í”Œë ˆì´ì–´ê°€ ì´ë™ì‹œ ëª¬ìŠ¤í„°ë¥¼ ë¯¸ëŠ” í˜„ìƒ

```c#
protected override void UpdateMoving()
{
		// ì´ë™
		Vector3 dir = _destPos - transform.position;
		if (dir.magnitude < 0.1f)
		{
			State = Define.State.Idle;
		}
		else
		{
			Debug.DrawRay(transform.position + Vector3.up * 0.5f, dir.normalized, Color.green);
			if (Physics.Raycast(transform.position + Vector3.up * 0.5f, dir, 1.0f, LayerMask.GetMask("Block")))
			{
				if (Input.GetMouseButton(0) == false) //
					State = Define.State.Idle;
				return;
			}

			float moveDist = Mathf.Clamp(_stat.MoveSpeed * Time.deltaTime, 0, dir.magnitude);
			transform.position += dir.normalized * moveDist;
			transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(dir), 20 * Time.deltaTime);
		}
	}
```

`NavMeshAgent`ì˜ *nma.Move* í•¨ìˆ˜ë¡œ ì´ë™í•˜ì§€ ì•Šê³  ì§ì ‘ í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ë¥¼ ì—…ëƒì‹œì¼œ í•´ê²°í•˜ì˜€ë‹¤. *transform.position += dir.normalized * moveDist;* 

<u>NavMeshAgentë¥¼ ë¶™ì—¬ì„œ ì´ë™í•˜ëŠ” ë°©ì‹ì€ ê¸°ë³¸ì ìœ¼ë¡œ Agentë“¤ì€ ì„œë¡œ í”¼í•´ê°€ë„ë¡ ë˜ì–´ ìˆì–´ ë„ˆë¬´ ì¸ì ‘í•˜ê²Œ ë¶™ìœ¼ë©´ ì˜ë„ì¹˜ ì•Šê²Œ ìƒëŒ€ë¥¼ ë°€ì¹˜ê¸°ë„ í•œë‹¤.</u> Obstacle Avoidance ì†ì„± ë•Œë¬¸ì´ë‹¤. ì´ë¥¼ í•´ê²°í•˜ëŠ” ë°©ë²• ì¤‘ í•˜ë‚˜ëŠ” NavMeshAgent ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë ˆì´ì €ë¥¼ ì´ì„œ ì´ë™ ê°€ëŠ¥í•œì§€ë¥¼ í™•ì¸ í•œ í›„ ì¼ë°˜ì ì¸ í”Œë ˆì´ì–´ ìœ„ì¹˜ ì„¸íŒ…ìœ¼ë¡œ ì´ë™ì„ í•˜ëŠ” ê²ƒì´ë‹¤. *-ì¶œì²˜ : Rookissë‹˜ ë‹µë³€-*

<https://stackoverflow.com/questions/23451983/how-to-avoid-two-navmeshagent-push-away-each-other-in-unity>

***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}