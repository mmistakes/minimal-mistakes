---
title:  "SVD(Singular Value Decomposition)ì— ëŒ€í•˜ì—¬ (in computer vision)" 
categories: studying
tag: [python, cpp, studying, Computer Vision, CV, ai]
date: 2024-07-24
toc: true

last_modified_at: 2024-07-24
---

ì´ ê¸€ì—ì„œëŠ” SVDê°€ ë¬´ì—‡ì¸ì§€ ê°„ë‹¨í•˜ê²Œ ì„¤ëª…í•˜ê³  Computer Visionì™€ AIì—ì„œ ì–¸ì œ ì“°ì´ëŠ”ì§€ ì˜ˆì‹œì™€ í•¨ê»˜ ë‹¤ë£° ì˜ˆì •ì…ë‹ˆë‹¤. (ë³¸ì¸ ê³µë¶€ ë° ê¸°ë¡ìš©)ğŸ˜

# SVDë€?
SVDëŠ” í–‰ë ¬ì„ ë¶„í•´í•˜ëŠ” ë°©ë²• ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. 'íŠ¹ì´ê°’ ë¶„í•´'ë¼ê³ ë„ ë¶ˆë¦¬ëŠ”ë°, ë³µì¡í•œ í–‰ë ¬ì„ ë” ê°„ë‹¨í•œ í˜•íƒœë¡œ ë‚˜ëˆ„ì–´ì£¼ëŠ” ë§ˆë²• ê°™ì€ ê¸°ìˆ ì´ì£ . ì´ë¥¼ í†µí•´ ë°ì´í„°ì˜ íŒ¨í„´ì„ ë°œê²¬í•˜ê±°ë‚˜ ì°¨ì›ì„ ì¶•ì†Œí•˜ëŠ” ë“± ë‹¤ì–‘í•œ ì‘ìš©ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

- SVDì˜ êµ¬ì„± ìš”ì†Œ
: SVDëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì„¸ ê°œì˜ í–‰ë ¬ë¡œ ì›ë˜ì˜ í–‰ë ¬ì„ ë¶„í•´í•©ë‹ˆë‹¤.

## ì»´í“¨í„° ë¹„ì „ì—ì„œì˜ SVD í™œìš©
ì»´í“¨í„° ë¹„ì „ì—ì„œ SVDëŠ” ì£¼ë¡œ ì´ë¯¸ì§€ ì••ì¶•, ë…¸ì´ì¦ˆ ì œê±°, ê°ì²´ ì¸ì‹ ë“± ì—¬ëŸ¬ ì‘ì—…ì— ì‚¬ìš©ë©ë‹ˆë‹¤. ê°ê°ì˜ í™œìš© ì˜ˆë¥¼ í•˜ë‚˜ì”© ì‚´í´ë³¼ê²Œìš”.

### ì´ë¯¸ì§€ ì••ì¶•
ì´ë¯¸ì§€ ì••ì¶•ì€ ì´ë¯¸ì§€ë¥¼ ì €ì¥í•˜ê±°ë‚˜ ì „ì†¡í•  ë•Œ í•„ìš”í•œ ê³µê°„ì„ ì¤„ì´ëŠ” ë° ì¤‘ìš”í•©ë‹ˆë‹¤. SVDë¥¼ ì‚¬ìš©í•˜ë©´ ê³ ì°¨ì›ì˜ ì´ë¯¸ì§€ë¥¼ ì €ì°¨ì›ìœ¼ë¡œ ì••ì¶•í•œ í›„, í•„ìš”í•œ ê²½ìš° ë‹¤ì‹œ ë³µì›í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì•„ë˜ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´, ì›ë³¸ ì´ë¯¸ì§€ì™€ ì••ì¶•ëœ ì´ë¯¸ì§€ë¥¼ ë¹„êµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. k ê°’ì„ ì¡°ì ˆí•˜ë©´ì„œ ì••ì¶•ë¥ ê³¼ ì´ë¯¸ì§€ í’ˆì§ˆì˜ ë³€í™”ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
```python
import numpy as np
import matplotlib.pyplot as plt
from skimage import data, color
from skimage.transform import resize

# ì˜ˆì œ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°
image = color.rgb2gray(data.astronaut())
image = resize(image, (256, 256))

# SVD ë¶„í•´
U, Sigma, VT = np.linalg.svd(image)

# k ê°’ì„ í†µí•´ ì°¨ì› ì¶•ì†Œ
k = 50
compressed_image = np.dot(U[:, :k], np.dot(np.diag(Sigma[:k]), VT[:k, :]))

# ì›ë³¸ ì´ë¯¸ì§€ì™€ ì••ì¶• ì´ë¯¸ì§€ë¥¼ ì‹œê°í™”
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title('Compressed Image with k = {}'.format(k))
plt.imshow(compressed_image, cmap='gray')
plt.axis('off')

plt.show()
```


### ë…¸ì´ì¦ˆ ì œê±°
ì´ë¯¸ì§€ì—ëŠ” ì¢…ì¢… ë…¸ì´ì¦ˆê°€ í¬í•¨ë˜ì–´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. SVDë¥¼ ì‚¬ìš©í•˜ì—¬ ë…¸ì´ì¦ˆë¥¼ ì œê±°í•˜ê³  ë” ê¹¨ë—í•œ ì´ë¯¸ì§€ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” íŠ¹íˆ ì˜ë£Œ ì´ë¯¸ì§€ë‚˜ ìœ„ì„± ì´ë¯¸ì§€ ì²˜ë¦¬ì—ì„œ ì¤‘ìš”í•©ë‹ˆë‹¤.
```python
import numpy as np
import matplotlib.pyplot as plt
from skimage import data, color, util

# ì˜ˆì œ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°
image = color.rgb2gray(data.astronaut())
image = resize(image, (256, 256))

# ë…¸ì´ì¦ˆ ì¶”ê°€
noisy_image = util.random_noise(image, mode='gaussian', var=0.1)

# SVD ë¶„í•´
U, Sigma, VT = np.linalg.svd(noisy_image)

# k ê°’ì„ í†µí•´ ì°¨ì› ì¶•ì†Œ ë° ë…¸ì´ì¦ˆ ì œê±°
k = 50
denoised_image = np.dot(U[:, :k], np.dot(np.diag(Sigma[:k]), VT[:k, :]))

# ì›ë³¸ ì´ë¯¸ì§€, ë…¸ì´ì¦ˆ ì´ë¯¸ì§€, ë…¸ì´ì¦ˆ ì œê±° ì´ë¯¸ì§€ë¥¼ ì‹œê°í™”
plt.figure(figsize=(15, 5))
plt.subplot(1, 3, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')
plt.axis('off')

plt.subplot(1, 3, 2)
plt.title('Noisy Image')
plt.imshow(noisy_image, cmap='gray')
plt.axis('off')

plt.subplot(1, 3, 3)
plt.title('Denoised Image with k = {}'.format(k))
plt.imshow(denoised_image, cmap='gray')
plt.axis('off')

plt.show()
```

### í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ë¶„ì‚°ê³¼ ê¸°í•˜í•™ì  êµ¬ì¡° ë¶„ì„
í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ë°ì´í„°ì— SVDë¥¼ ì ìš©í•˜ë©´, ë°ì´í„°ì˜ ì£¼ìš” ë°©í–¥ì„ ì°¾ê³  ë°ì´í„°ì˜ ë¶„ì‚°ì„ ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í¬ì¸íŠ¸ í´ë¼ìš°ë“œì˜ ë¶„ì‚°ì´ ê°€ì¥ í° ë°©í–¥ì„ ì°¾ëŠ” ë° SVDë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ í¬ì¸íŠ¸ í´ë¼ìš°ë“œì˜ ì£¼ìš” ì¶•ì„ ê²°ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
SVDëŠ” ë°ì´í„°ì˜ ì¤‘ìš”í•œ êµ¬ì¡°ì  ì •ë³´ë¥¼ ìº¡ì²˜í•˜ëŠ” ë° ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ë°ì´í„°ì˜ ê²½ìš°, SVDëŠ” ë°ì´í„°ì˜ ì£¼ìš” ë°©í–¥ì„ ì°¾ëŠ” ë° ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ í¬ì¸íŠ¸ í´ë¼ìš°ë“œì˜ ë¶„ì‚°ê³¼ ê¸°í•˜í•™ì  êµ¬ì¡°ë¥¼ ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

C++ ì½”ë“œì—ì„œ SVDì˜ ì ìš©
í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ë°ì´í„°ì—ì„œ SVDë¥¼ ì‚¬ìš©í•˜ì—¬ í‚¤í¬ì¸íŠ¸ í”„ë ˆì„ì„ ì„ íƒí•˜ëŠ” ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

ë°ì´í„° ìƒ˜í”Œë§: í¬ì¸íŠ¸ í´ë¼ìš°ë“œì—ì„œ ì¼ì • ë¹„ìœ¨ë¡œ ìƒ˜í”Œë§ëœ ë°ì´í„°ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
ì¤‘ì‹¬ ê³„ì‚°: ìƒ˜í”Œë§ëœ ë°ì´í„°ì˜ ì¤‘ì‹¬ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
SVD ìˆ˜í–‰: ìƒ˜í”Œë§ëœ ë°ì´í„°ì— ëŒ€í•´ SVDë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
íŠ¹ì´ê°’ ë¹„êµ: SVDì˜ ê²°ê³¼ë¡œ ì–»ì–´ì§„ ì²« ë²ˆì§¸ íŠ¹ì´ê°’ì„ ì„ê³„ê°’ê³¼ ë¹„êµí•˜ì—¬ í‚¤í¬ì¸íŠ¸ í”„ë ˆì„ì„ ì„ íƒí•©ë‹ˆë‹¤.
ë³€í™˜ ì ìš© ë° ì €ì¥: ì„ íƒëœ í¬ì¸íŠ¸ í´ë¼ìš°ë“œì— ë³€í™˜ì„ ì ìš©í•˜ê³  ì €ì¥í•©ë‹ˆë‹¤.


void processPointCloudSVD(
    const std::vector<std::string>& ply_files,
    const std::vector<Matrix4f>& transforms,
    PointCloud::Ptr& merged_pointcloud,
    std::vector<Vector3f>& centers,
    std::vector<int>& used_indices,
    std::vector<std::pair<PointCloud::Ptr, std::string>>& save_queue,
    std::mutex& mtx,
    float sampling_ratio,
    float svd_threshold,
    int start_idx,
    int end_idx,
    const std::string& sampling_folder) {

    for (int i = start_idx; i < end_idx; ++i) {
        PointCloud::Ptr cloud(new PointCloud);
        if (!customPlyRead(ply_files[i], cloud)) {
            continue;
        }

        // ìƒ˜í”Œë§
        PointCloud::Ptr sampled_points = randomSample(cloud, sampling_ratio);
        Vector3f current_center = computeCenter(sampled_points);

        // ë°ì´í„° ì¤€ë¹„
        Eigen::MatrixXf data(sampled_points->size(), 3);
        for (size_t j = 0; j < sampled_points->size(); ++j) {
            data(j, 0) = sampled_points->points[j].x;
            data(j, 1) = sampled_points->points[j].y;
            data(j, 2) = sampled_points->points[j].z;
        }

        // SVD ìˆ˜í–‰
        Eigen::MatrixXf U, V;
        Eigen::VectorXf S;
        performSVD(data, U, S, V);

        // ì²« ë²ˆì§¸ íŠ¹ì´ê°’ê³¼ ì„ê³„ê°’ ë¹„êµ
        bool should_add = false;
        if (S(0) > svd_threshold) {
            should_add = true;
            std::lock_guard<std::mutex> lock(mtx);
            centers.push_back(current_center);
            used_indices.push_back(i);
        }

        // ì„ íƒëœ í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ë³€í™˜ ë° ì €ì¥
        if (should_add) {
            Matrix4f transform = transforms[i];
            PointCloud::Ptr transformed_points(new PointCloud);
            pcl::transformPointCloud(*sampled_points, *transformed_points, transform);

            {
                std::lock_guard<std::mutex> lock(mtx);
                *merged_pointcloud += *transformed_points;

                std::ostringstream oss;
                oss << sampling_folder << "/" << std::setw(4) << std::setfill('0') << used_indices.size() - 1 << ".ply";
                std::string save_file_path = oss.str();

                save_queue.emplace_back(transformed_points, save_file_path);
            }
        }
    }
}

void performSVD(const Eigen::MatrixXf& data, Eigen::MatrixXf& U, Eigen::VectorXf& S, Eigen::MatrixXf& V) {
    Eigen::JacobiSVD<Eigen::MatrixXf> svd(data, Eigen::ComputeThinU | Eigen::ComputeThinV);
    U = svd.matrixU();
    S = svd.singularValues();
    V = svd.matrixV();
}

processPointCloudSVD: SVDë¥¼ ì‚¬ìš©í•˜ì—¬ í¬ì¸íŠ¸ í´ë¼ìš°ë“œë¥¼ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤. ìƒ˜í”Œë§, SVD ìˆ˜í–‰, ì²« ë²ˆì§¸ íŠ¹ì´ê°’ê³¼ ì„ê³„ê°’ ë¹„êµ, ë³€í™˜ ë° ì €ì¥ì˜ ê³¼ì •ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
performSVD: ì£¼ì–´ì§„ ë°ì´í„° í–‰ë ¬ì— ëŒ€í•´ SVDë¥¼ ìˆ˜í–‰í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤. Eigen ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ SVDë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.