# 

1\. Hoisting

자바스크립트엔진은 코드를 실행하기전 코드를 한번 훑으면서 선언된 변수나 함수들을 메모리에 먼저 저장한다.

즉 뒤에서 한 선언이 맨 앞으로 끌어 올려지는 것이다. 

따라서 코드상으로는 선언보다 참조,호출이 먼저나오더라도 코드가 에러없이 실행되게 된다. 

\- 변수

var : var 변수는 선언과 동시에 undefined 로 초기화 되기 때문에 호이스팅이 일어나서 앞에서 참조 할 경우 에러가 발생하지 않는다.

let, const : 두 변수는 선안과 동시에 초기화 되지 않는다. 즉 초기화 되지 않은 변수는 참조 할수 없기 때문에 

호이스팅이 일어나 앞에서 참조할경우 참조 에러가 나온다.

두 변수의 차이는

var은 변수의 선언(스코프에 등록)과 초기화(메모리할당) 을 동시에하면서 undefiend로 초기화한다.

하지만 let,const는 변수의 초기화가 직접 그 코드에 도달했을 때 일어난다. 

즉, 호이스팅이 일어나서 선언이 먼저 되고 직접 그 코드에 도달해서 초기화가 일어나기 까지의 구간을 

일시적 사각지대(Temporal Dead Zone; TDZ) 라고 한다. 

\- 함수

함수선언문 :

function foo1() {

console.log('Hello');

}

함수표현식:

var foo2 = function() {

console.log('world');

}

함수 선언문에서는 호이스팅이 일어나지만 함수 표현식에서는 일어나지 않는다. 

2\. Event Bubbling 

요소 여러가지가 겹쳐져 있을 때 가장 최하위요소에서 이벤트를 발생 시키면

그 상위 요소에도 이벤트가 전파가 되서 다 발생되는 것이다. 

즉 여러 요소가 겹쳐있는데 

가장 안쪽의 요소에 이벤트를 발생시키면 겹쳐져있는 상위요소도 다 이벤트가 발생되는 것이다.

이것을 제어하는 방법으로는 

event.stopPropagation() 

해당 메소드로 제어 할수 있다. 해당 메소드가 호출되는 순간 더이상 상위 요소로 전파되지 않는다. 

3\. var, let, const and scope

기존의 var 변수는 함수단위의 범위를 가지고 재정의가 가능했다.

하지만 ES6 이후 let이란 block 단위의 범위를 가지고 재정의 불가능한 변수가 생기면서 var은 거의 쓰지 않게되었다. 

하지만 만약 같은 이름의 변수가 let으로 서로 다른 범위에서 정의 되는 것은 에러가 일어나지 않는다.

(for(int i=0... 을 여러번 쓰는 것처럼 )

const는 선언과 동시에 초기화 되어야 한다. 

4\. Prototype 

프로토타입이란 유전자라고 볼 수 있다. 즉 자신의 상위 객체의 유전자인것이다.

어떤 함수를 생성자 형태로 만들면 그 함수를 통해서 여러 객체들을 뽑아낼수있다.

즉 여기서 그 함수는 부모가 되고 객체들은 자식이 되는 것이다. 

그 자식들의 \_\_proto\_\_ 는 그 부모인 함수가 된다.

const car = {

    wheel: 4

};

const bmw = {

    maker : 'bmw'

};

bmw.\_\_proto\_\_ = car;

console.log(bmw);

이와 같이 객체를 생성한 후 \_\_proto\_\_ 를 통해 부모를 정해주면 그 부모의 property 들이 상속 되는 것이다. 

이런것의 예로

우리가 배열을 생성하면 해당 배열에 .sort 나 .forEach 와 같은 함수를 사용할수 있다. 이런 함수를 정의한적이 없는데 어떻게 사용하는 것일까? 

바로 부모들중 이런 함수를 가지고 있다면 그 함수를 사용하는 것이다. 

즉 내가 생성한 배열의 함수중 .sort가 있는지 확인하고 없다면 배열의 프로토를 없다면 또 그 프로토의 프로토를 

이렇게 거슬러올라가면서 있다면 사용하고 없다면 에러를 내보내는 것이다. 

5\. shadow DOM

5-1. 그전에 렌더링이란?

렌더링이란 브라우저가 서버로부터 HTML 문서를 받아와서 브라우저에 그리는 과정이다.

- HTML을 파싱하여 DOM 트리를 만든다. 
- CSS를 파싱하여 CSSOM 트리를 만든다.
- DOM 과 CSSOM 을 결합하여 렌더링 트리를 만든다.
- 렌더링 트리에서 각 노드의 크기와 위치를 계산한다.
- 개별 노드를 화면에 그린다.

5-2. shadow DOM

DOM(Document Object Model) 이란 HTML문서에서 요소들을 어떻게 그릴지 또 자바 스크립트에서 요소들을 어떻게 수정할지 등을 결정하는 것이다.

DOM은 global 한 범위를 가진다 즉 css에서도 모든 DOM에 자유롭게 접근할수있고 

자바스크립트에서도 document.select... 등을 통해 모든 DOM에 접근할수 있는 것이다. 

근데 여기서 css의 영향을 받지 않고 독립적으로 스타일을 가지고 싶은 DOM 이 있을수도 있다.

예를 들어 input type의 range 같은 경우다

문서 상에는 <input type = "range"> 만을 가지지만 뭔가 스타일링 된 모습이다.

해당 요소를 파헤쳐보면 사실 

[##_Image|kage@oc8PM/btrr04BZLVE/BZLdhcdxwphWxp7dGJoGEK/img.png|CDM|1.3|{"originWidth":932,"originHeight":458,"style":"alignCenter"}_##]

아래와 같이 여러 div로 이루어져 있고 뭔가 특성이나 요소들을 가진다 

이런 DOM 들을 shadow DOM 이라고 한다. 

그럼 shadow DOM 을 어떻게 사용할까 

shadow DOM 의 호스트가 되길원하는 요소(shadow host)에 자바스크립트로 attachShadow() 

를 통해 요소(shadow root)를 붙혀 shadow DOM 을 생성할수있고 그 밑에 여러 요소나 스타일을 추가할 수 있다.

6\. strict mode 

자바스크립트에서는 여러 사소한 오류나 실수들을 묵인해준다. 하지만 strict mode를 사용하면 이런것들을

다 일일히 에러로 표시해준다.

사용법은 

문서의 가장 첫줄이나

함수의 첫줄에 

```
"use strict";
```

를 선언해주면 된다. 

이를 사용하면 여러 버그들을 줄일수있다.





```python
# Python3 code to demonstrate
# Matrix Product
# Using list comprehension + loop
 
# getting Product
 
 
def prod(val):
    res = 1
    for ele in val:
        res *= ele
    return res
 
 
# initializing list
test_list = [[1, 4, 5], [7, 3], [4], [46, 7, 3]]
 
# printing original list
print("The original list : " + str(test_list))
 
# using list comprehension + loop
# Matrix Product
res = prod([ele for sub in test_list for ele in sub])
 
# print result
print("The total element product in lists is : " + str(res))

```
