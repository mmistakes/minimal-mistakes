---
categories: "learning"
---

# 1. 유효범위

- 유효범위(Scope)는 변수의 수명을 의미

```js
var vscope = 'global';
function fscope(){
    var vscope = 'local';
    alert('함수안 '+vscope);
}
fscope();
alert('함수밖 '+vscope);

//output : 함수안 vscope, 함수밖 vscope
```

- 여기서 function 안에서 vscope를 호출할 때 var를 빼면 전역변수가 됨

```js
var vscope = 'global';
function fscope(){
    vscope = 'local';
    alert('함수안 '+vscope);
}
fscope();
alert('함수밖 '+vscope);

//output : 함수밖 vscope, 함수밖 vscope
```

- 불가피하게 전역변수를 사용해야 하는 경우는 하나의 객체를 전역변수로 만들고 객체의 속성으로 변수를 관리하는 방법을 사용

```js
YAPP = {}
MYAPP.calculator = {
    'left' : null,
    'right' : null
}
MYAPP.coordinate = {
    'left' : null,
    'right' : null
}
 
MYAPP.calculator.left = 10;
MYAPP.calculator.right = 20;
function sum(){
    return MYAPP.calculator.left + MYAPP.calculator.right;
}
document.write(sum());
```

- 전역변수를 사용하고 싶지 않다면 아래와 같이 익명함수를 호출함으로서 이러한 목적 달성

```js
(function(){
    var MYAPP = {}
    MYAPP.calculator = {
        'left' : null,
        'right' : null
    }
    MYAPP.coordinate = {
        'left' : null,
        'right' : null
    }
    MYAPP.calculator.left = 10;
    MYAPP.calculator.right = 20;
    function sum(){
        return MYAPP.calculator.left + MYAPP.calculator.right;
    }
    document.write(sum());
}())
```

- js는 함수가 선언된 시점에서의 유효범위를 갖는다. 
- 이러한 유효범위의 방식을 정적 유효범위(static scoping), 혹은 렉시컬(lexical scoping)이라고 한다.

```js
var i = 5;
 
function a(){
    var i = 10;
    b();
}
 
function b(){
    document.write(i);
}
 
a();
//output : 5
```



# 2. 값으로서의 함수와 롤백

### 값으로서의 함수

- js가 다른 언어와 다른 점은 함수 자체가 값이 될 수 있다는 점이다

```js
// 다음 2개는 같은 내용이다.
function a(){}
var a = function(){}
```

- 함수는 객체의 값으로 포함될 수도 있다. 
- 이렇게 객체의 속성 값으로 담겨진 함수를 메소드(method)라고 부른다

```js
a = {
    b:function(){
    }
};

// a라는 변수에 담겨있는 객체 안에는.
// b라고 하는 속성이 담겨 있는데, 그 속성의 값은 함수
// 그러면 그 함수를 method라고 부른다
```

- 함수는 값이기 때문에 다른 함수의 인자로 전달될 수 있다.

```js
function cal(func, num){
    return func(num)
}
function increase(num){
    return num+1
}
function decrease(num){
    return num-1
}
alert(cal(increase, 1));
alert(cal(decrease, 1));
// output : 2, 0
```

- 함수의 리턴 값으로도 사용 가능

```js
function` `cal(mode){
    ``var` `funcs = {
        ``'plus'` `: ``function``(left, right){``return` `left + right},
        ``'minus'` `: ``function``(left, right){``return` `left - right}
    ``}
    ``return` `funcs[mode];
}
alert(cal(``'plus'``)(2,1));
alert(cal(``'minus'``)(2,1));  
//output : 3, 1
```

- 배열의 값으로도 사용 가능

```js
var process = [
    function(input){ return input + 10;},
    function(input){ return input * input;},
    function(input){ return input / 2;}
];
var input = 1;
for(var i = 0; i < process.length; i++){
    input = process[i](input);
}
alert(input);

// output : 60.5
```

- 즉 함수는 변수, 매개변수, 리턴값, 배열 등으로 사용가능
- 이러한 용도로 사용될 수 있는 형태의 테이터를 프로그래밍에서는 "first-class citizen" (~object, value 등)으로 불림



### 콜백

#### 처리의 위임

- 함수가 값으로 사용될 수 있는 특성을 이용하면 함수의 인자를 함수로 전달 할 수 있다.
- 값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 바꿀 수 있다.
- ex) .sort()

```js
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort()); 
// output : [1, 10, 2, 20, 3, 4, 5, ..]
// 원하는 결과가 아님
```

```js
function sortNumber(a,b){
	if(a > b){
	return 1;
	} else if(a < b){
	return -1;
	} else {
	return 0;
	}
}

var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort()); 
// output : [1, 2, 3, 4, 5... ]
// 제대로 나옴
```

- if 문에서 양수, 음수, 0만 확인하면 되므로

```js
function sortNumber(a, b){
	return a - b
}
```

- 이 때 역순으로 출력하고 싶으면 b-a로 부호를 바꾸면 된다.

```js
function sortNumber(a, b){
	return b - a
}

//output : [20, 10, 9, 8, ...]
```

- 이때 sortNumber가 콜백 함수가 됨

### 비동기 처리

- Ajax 사용



# 3. 클로저

### 내부함수

```js
function outter(){
    function inner(){
        var title = 'coding everybody'; 
        alert(title);
    }
    inner();
}
outter();
```

- 함수 안에서만 사용되는 함수가 있으면 응집도를 높이기 위해 사용
- 내부함수 inner에서 title을 호출했을 때 외부함수인 outter의 지역변수에 접근 가능



### 클로저란

- 내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 이러한 메커니즘을 클로저라고 한다.

- 예제

  ```js
  function outter(){
      var title = 'coding everybody';  
      return function(){        
          alert(title);
      }
  }
  var inner = outter();
  inner();
  
  //output : coding everyday
  ```

  - 이 때, inner() 함수에서 title 값은 otter 함수가 끝났음에도 접근이 가능하다.

### 클로저 실용적인 예제

- ```js
  function factory_movie(title){
      return {
          get_title : function (){
              return title;
          },
          set_title : function(_title){
              title = _title
          }
      }
  }
  ghost = factory_movie('Ghost in the shell');
  matrix = factory_movie('Matrix');
  // ghost와 matrix에 메소드를 넣음
  
  alert(ghost.get_title());
  alert(matrix.get_title());
  // Ghost in the shell, Matrix 출력
  
  ghost.set_title('공각기동대');
  // title이 공각기동대로 변경
  
  alert(ghost.get_title());
  alert(matrix.get_title());
  // 공각기동대, Matrix 출력
  ```



### 클로저 응용

- ```js
  var arr = []
  for(var i = 0; i < 5; i++){
      arr[i] = function(){
          return i;
      }
  }
  for(var index in arr) {
      console.log(arr[index]());
  }
  
  //output: 5 5 5 5 5
  --> i값이 최종적으로 5이므로 5만 출력됨
  ```

- 내부함수가 외부함수의 id 지역변수를 호출할 수 있도록 만들면 됨

- ```js
  var arr = []
  for(var i = 0; i < 5; i++){
      arr[i] = function(id) {
          return function(){
              return id;
          }
      }(i);
  }
  for(var index in arr) {
      console.log(arr[index]());
  }
  ```

  

# 4. arguments

- js는 문법이 관대해서 함수에 매개변수를 설정하지 않아도 사용할 수 있음

- 인자의 배열이 arguments이다.

- 예제

  - ```js
    function sum(){
        var i, _sum = 0;    
        for(i = 0; i < arguments.length; i++){
            document.write(i+' : '+arguments[i]+'<br />');
            _sum += arguments[i];
        }   
        return _sum;
    }
    document.write('result : ' + sum(1,2,3,4));
    ```

  - arguments[i] 는 1, 2, 3, 4가 됨



### 매개변수의 수

- 함수.length를 하면 함수 매개변수 개수를 알려줌
- arguments.length를 하면 인수 개수를 알려줌

- ```js
  function one(arg1){
      console.log(
          'one.length', one.length,
          'arguments', arguments.length
      );
  }
  one('val1', 'val2');  // one.length 1 arguments 2 
  
  function two(arg1, arg2){
      console.log(
          'two.length', two.length,
          'arguments', arguments.length
      );
  }
  two('val1');  // two.length 2 arguments 1
  ```

  

# 5. 함수의 호출

- 함수의 메소드 중 apply와 call 이 있음 (apply 만 설명)

- ```js
  function sum(arg1, arg2){
      return arg1+arg2;
  }
  alert(sum.apply(null, [1,2]))
  // output : 3
  ```

### apply 를 사용하는 이유

- 예제

- sum.apply(null)에서 o1, o2를 1, 2번째 인자로 줌

- ```js
  o1 = {val1:1, val2:2, val3:3}
  o2 = {v1:10, v2:50, v3:100, v4:25}
  function sum(){
      var _sum = 0;
      for(name in this){
          _sum += this[name];
      }
      return _sum;
  }
  alert(sum.apply(o1)) // 6
  alert(sum.apply(o2)) // 185
  ```

  - sum.apply(o1)으로 `var this = o1` 이라고 생각하면 됨(함수 sum이 o1의 객체인 것처럼 실행)
    - 따라서 마치 o1.sum() 이 되고 o1 = {val1:1, val2:2, val3:3, sum:sum}이 됨