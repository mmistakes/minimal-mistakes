---
title:  "ë³´ì¶© ê°•ì˜) ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ & ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ êµ¬í˜„í•˜ê¸°" 

categories:
  - Algorithm Lesson 1
tags:
  - [Algorithm, Binary Search Tree]

toc: true
toc_sticky: true

date: 2020-08-12
last_modified_at: 2020-08-12
---

ê¶Œì˜¤í  êµìˆ˜ë‹˜ì˜ ìœ íŠœë¸Œ ê°•ì˜ **ì˜ë¦¬í•œ í”„ë¡œê·¸ë˜ë°ì„ ìœ„í•œ ì•Œê³ ë¦¬ì¦˜ ê°•ì¢Œ** ë¥¼ ë“£ê³  ì •ë¦¬í•œ í•„ê¸°ì…ë‹ˆë‹¤. ğŸ˜€  
{: .notice--warning}


> *ì£¼, ì§€ëª…, ìœ„ë„, ê²½ë„, ìˆ˜ë„ë¡œë¶€í„°ì˜ ê±°ë¦¬* ë°ì´í„°ë¥¼ ê°€ì§„ **ì§€ì—­** ë“¤ì„ `ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬`ì— ì €ì¥í•  ê²ƒ

> ì„œë¡œ ê±°ë¦¬ê°€ 10km ì´ë‚´ì˜ ì§€ì—­ë“¤ ì‚¬ì´ì—” ê·¸ë˜í”„ edgeê°€ ìˆë‹¤ê³  ê°€ì •. `ì¸ì ‘ ë¦¬ìŠ¤íŠ¸`

## ğŸ“œplace.h

```cpp
typedef struct place 
{
    int index;
    char *state;            // ì£¼
    char *name;             // ì§€ëª…
    double lon, lat;        // ìœ„ë„, ê²½ë„
    double distFromCapital; // ìˆ˜ë„ë¡œë¶€í„°ì˜ ê±°ë¦¬
} Place;

int compareTo(Place * p, Place * q);  // ë‘ placeì˜ í¬ê¸° ë¹„êµ í•¨ìˆ˜
```

<br>

## ğŸ“œplace.cpp

```cpp
int compareTo(Place * p, Place * q)  // name ì„ ê¸°ì¤€ìœ¼ë¡œ í¬ê¸°ë¥¼ ë¹„êµí•  ê²ƒ.
{
    return strcmp(p->name, q->name);
}
```

<br>

## ğŸ“œbst.h

> ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ *Binary Search Tree*

```cpp
typedef Place * Item;  // Place * ë°ì´í„° íƒ€ì…ì„ Item ìœ¼ë¡œ ëª…ëª…
typedef int (*CompareFtnType) (Item, Item);  // int (*f) (Item, Item) í˜•ì‹ì˜ í•¨ìˆ˜ í¬ì¸í„° íƒ€ì…ì„ CompareFtnType ì´ë¼ê³  ëª…ëª…

struct tnode  // íŠ¸ë¦¬ ë…¸ë“œ
{
    Item data;
    struct tnode *left, *right;  // ì™¼ìª½ ìì‹, ì˜¤ë¥¸ìª½ ìì‹
};

typedef struct tnode Node; // tnodeë¥¼ Nodeë¡œ ëª…ëª…

typedef struct bst // BST. ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬
{
    Node * root;  // ë£¨íŠ¸ë§Œ ìˆìœ¼ë©´ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ë“¤ì„ êµ¬ë¶„í•  ìˆ˜ ìˆëŠ” ì •ë³´ê°€ ë¨
    CompareFtnType compareFtn;  // ë¹„êµ í•¨ìˆ˜ í¬ì¸í„°
} BST;

BST * create_bst(CompareFtnType f);  // íŠ¸ë¦¬ ìƒì„±. ë…¸ë“œ í¬ê¸° ë¹„êµ ê¸°ì¤€ì´ ë˜ëŠ” í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì¸ìˆ˜ë¡œ ë°›ìŒ.
Item search(BST * tree, Item item);  // í•´ë‹¹ íŠ¸ë¦¬ì— ì´ ì•„ì´í…œì´ ìˆëŠ”ì§€ ê²€ìƒ‰
bool insert(BST * tree, Item item); // í•´ë‹¹ íŠ¸ë¦¬ì— ì•„ì´í…œ ì‚½ì…. boolì¸ ì´ìœ ëŠ” ì´ë¯¸ íŠ¸ë¦¬ì— ìˆëŠ” ë°ì´í„°ë©´ false ë¦¬í„´í•˜ê²Œë”.
Item remove(BST * tree, Item item);  // í•´ë‹¹ íŠ¸ë¦¬ì— ì•„ì´í…œ ì‚­ì œ
```

<br>

## ğŸ“œbst.cpp

> ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ì— í•„ìš”í•œ í•¨ìˆ˜ë“¤ êµ¬í˜„

```cpp
BST * create_bst(CompareFtnType f)  // íŠ¸ë¦¬ ìƒì„±. ë…¸ë“œ í¬ê¸° ë¹„êµ ê¸°ì¤€ì´ ë˜ëŠ” í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì¸ìˆ˜ë¡œ ë°›ìŒ.
{
    BST * tree = (BST *)malloc(sizeof(BST));
    tree->root = NULL;
    tree->compareFtn = f;
    return tree;
}

Item search(BST * tree, Item item)  // í•´ë‹¹ íŠ¸ë¦¬ì— ì´ ì•„ì´í…œì´ ìˆëŠ”ì§€ ê²€ìƒ‰
{
    Node * p = tree->root;
    while(p != NULL)
    {
        int result = tree->compareFtn(p->data, item); // íŠ¸ë¦¬ê°€ ê°€ì§€ê³  ìˆëŠ” ë¹„êµ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹„êµ 
        if (result == 0)   // ì¼ì¹˜. ì¦‰ ì°¾ì•˜ë‹¤ë©´
            return p->data;
        else if (result > 0) // ì°¾ìœ¼ë ¤ëŠ” ì•„ì´í…œë³´ë‹¤ ë” í¬ë‹¤ë©´ ì™¼ìª½ ìì‹ ë…¸ë“œë¡œ ë‚´ë ¤ê°
            p = p->left;
        else  // ì°¾ìœ¼ë ¤ëŠ” ì•„ì´í…œë³´ë‹¤ ë” ì‘ë‹¤ë©´ ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œë¡œ ë‚´ë ¤ê°
            p = p->right;
    }

    return NULL;  // ëê¹Œì§€ ëŒì•„ë„ ëª» ì°¾ì•˜ë‹¤ë©´
}

bool insert(BST * tree, Item item) // í•´ë‹¹ íŠ¸ë¦¬ì— ì•„ì´í…œ ì‚½ì…. boolì¸ ì´ìœ ëŠ” ì´ë¯¸ íŠ¸ë¦¬ì— ìˆëŠ” ë°ì´í„°ë©´ false ë¦¬í„´í•˜ê²Œë”.
{
    Node *p = tree->root, *q = NULL;  // ìˆœíšŒ í¬ì¸í„°ê°€ í•˜ë‚˜ ë” í•„ìš”í•¨

    // ì¤‘ë³µ ê²€ì‚¬
    while(p != NULL)  // leaf ë…¸ë“œê¹Œì§€ ë‚´ë ¤ ê°
    {
        int result = tree->compareFtn(p->data, item); // íŠ¸ë¦¬ê°€ ê°€ì§€ê³  ìˆëŠ” ë¹„êµ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹„êµ 
        q = p;  // ë‚´ë ¤ê°€ê¸°ì „ì— që¥¼ í˜„ì¬ì˜ pë¡œ ì—…ë°ì´íŠ¸. í•­ìƒ ì´ì „ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ê²Œ
        if (result == 0)   // ì¼ì¹˜. ì¦‰ íŠ¸ë¦¬ì— ì¤‘ë³µë˜ëŠ” ê°’ì´ ìˆë‹¤ë©´
            return false;
        else if (result > 0) // ì°¾ìœ¼ë ¤ëŠ” ì•„ì´í…œë³´ë‹¤ ë” í¬ë‹¤ë©´ ì™¼ìª½ ìì‹ ë…¸ë“œë¡œ ë‚´ë ¤ê°
            p = p->left;
        else  // ì°¾ìœ¼ë ¤ëŠ” ì•„ì´í…œë³´ë‹¤ ë” ì‘ë‹¤ë©´ ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œë¡œ ë‚´ë ¤ê°
            p = p->right;
    }

    // while ì„ ë¹ ì ¸ ë‚˜ì™”ë‹¤ëŠ” ê²ƒì€ ì¤‘ë³µë˜ëŠ” ê²ƒì´ ì—†ìœ¼ë‹ˆê¹Œ ì‚½ì… í•´ë„ ëœë‹¨ëŠ ê²ƒ

    Node * tmp = (Node *)malloc(sizeof(Node));  // ì¶”ê°€í•  ë…¸ë“œ
    tmp->data = item;
    tmp->left = NULL;
    tmp->right = NULL;

    if (q == NULL)  // íŠ¸ë¦¬ê°€ ë¹ˆ íŠ¸ë¦¬ë¼ëŠ” ê²ƒ. ë£¨íŠ¸ ë…¸ë“œë¡œì„œ ì¶”ê°€í•´ì£¼ë©´ ë¨.
    {
        tree->root = tmp;
        return true;
    } 

    // ì ì ˆí•œ ìœ„ì¹˜ì— ì‚½ì…. q ì™€ ë¹„êµí•˜ì—¬ qì˜ ì™¼ìª½ ìì‹ìœ¼ë¡œ ë„£ì„ì§€ ì˜¤ë¥¸ìª½ ìì‹ìœ¼ë¡œ ë„£ì„ì§€.
    int result = tree->compareFtn(q->data, item);
    if (result > 0) 
        q->left = tmp;
    else
        q->right = tmp;
    return true;
}

Item remove(BST * tree, Item item)  // í•´ë‹¹ íŠ¸ë¦¬ì— ì•„ì´í…œ ì‚­ì œ
{

}

```

<br>

## ğŸ“œgraph.h

> `ì¸ì ‘ ë¦¬ìŠ¤íŠ¸` êµ¬í˜„

> ì„œë¡œ ê±°ë¦¬ê°€ 10km ì´ë‚´ì˜ ì§€ì—­ë“¤ ì‚¬ì´ì—” ê·¸ë˜í”„ edgeê°€ ìˆë‹¤ê³  ê°€ì •.

```cpp
struct node 
{
    int end;  // edgeì˜ ë
    struct node *next;
};
typedef struct node Edge;

typedef struct graph
{
    Edge **vertices;  // ì •ì 
    int nbrNode;    // ë…¸ë“œ ê°œìˆ˜
} Graph;

Graph *create_graph(int n);  // ë…¸ë“œ ê°œìˆ˜ë¥¼ ì¸ìˆ˜ë¡œ ë°›ìŒ
void addEdge(Graph *graph, ins s, int t);  // ë‘ ë…¸íŠ¸ë¼ë¦¬ edge ì—°ê²°. ì¸ìˆ˜ë¡  ì‹œì‘ì , ëì  ë„˜ê¹€

```


<br>

## ğŸ“œgraph.cpp

```cpp
Graph *create_graph(int n)
{
    Graph *g = (Graph *)malloc(sizeof(Graph));
    g->vertices = (Edge **)malloc(n * sizeof(Edge *));
    g->nbrNode = n;
    for (int i = 0; i < n; i++) g->vertices[i] = NULL;
    return g;
}

void addEdge(Graph *graph, ins s, int t)  // ì—£ì§€ ì¶”ê°€. sëŠ” ì‹œì‘ì , tëŠ” ëì .
{
    Edge * edge = (Edge *)malloc(sizeof (Edge));  // edge ìƒì„±
    edge->end = t;
    edge->next = graph->vertices[s];  // ì‹œì‘ì  ë…¸ë“œ
    graph->vertices[s] = edge;
}

```

<br>

## ğŸ“œmain.cpp

- "Alabama AL Distances.TXT" íŒŒì¼. '\t' ì„ ê¸°ì¤€ìœ¼ë¡œ *ì£¼, ì§€ëª…, ìœ„ë„, ê²½ë„, ìˆ˜ë„ë¡œë¶€í„°ì˜ ê±°ë¦¬* ë¶„ë¥˜ê°€ ë˜ì–´ìˆë‹¤. 
  - ![image](https://user-images.githubusercontent.com/42318591/89987086-63856080-dcb8-11ea-92c0-46c9fc2e9eb4.png){: width="50%" height="50%"}{: .align-center}
- **ìµœì¢… ê²°ê³¼**
  - ì§€ì—­ ì´ë¦„ê³¼ ì¤‘ë³µ ê°¯ìˆ˜ì™€ í•¨ê»˜ ê·¸ ì§€ì—­ì˜ 10kmë‚´ì— ìˆëŠ” íƒ€ ì§€ì—­ë“¤ì„ ë³´ì—¬ì£¼ê²Œ ëœë‹¤.
    - ![image](https://user-images.githubusercontent.com/42318591/90007805-58412d80-dcd6-11ea-8e56-afe66d8055df.png){: width="80%" height="80%"}{: .align-center}


```cpp
#include <stdio.h>
#include <cstring>
#include <cstdlib>
#include "place.h"
#include "bst.h"
#include "graph.h"
#include "geolocation.h"

#define MAX 40000
#define BUFFER_SIZE 1000

Place * places[MAX];        // íŠ¸ë¦¬ê°€ ë  ë°°ì—´. í¬ê¸°ëŠ” 40000
int n = 0; 
char * fileName = "Alabama AL Distances.TXT";   // ì£¼, ì§€ëª…, ìœ„ë„, ê²½ë„, ìˆ˜ë„ë¡œë¶€í„°ì˜ ê±°ë¦¬ë¥¼ ë‹´ì€ ê°ê°ì˜ ì§€ì—­ ë°ì´í„°ë“¤ì´ ë‹´ê¸´ txt íŒŒì¼. ìœ„ ì‚¬ì§„ê³¼ ê°™ì´ ìƒê¹€
BST * theTree;
Graph *theGraph;

void inorder(Node *p);
void readData(char * name);
void rename(Place *p);
void makeGraph();
void printGraph(Graph *graph);

int main()
{
    theTree = create_bst(compareTo);  // compareTo í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ë„˜ê¹€
    readData(fileName);
    makeGraph();
    printGraph(theGraph);

    /*
    inorder(theTree->root);  // ì¤‘ìœ„ í‘œê¸° ë°©ì‹ìœ¼ë¡œ ìˆœíšŒí•˜ë©° íŠ¸ë¦¬ì˜ ë…¸ë“œë“¤ ì¶œë ¥
    */

    return 0;
}

void makeGraph()
{
    theGraph = create_graph(n);
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            // caldDist í•¨ìˆ˜ëŠ” "geolocation.h"ì— ìˆëŠ” ë‘ ì§€ì—­ì˜ ìœ„ì¹˜(ìœ„ë„,ê²½ë„)ë¥¼ í†µí•´ ê±°ë¦¬ë¥¼ ë¦¬í„´í•œëŠ í•¨ìˆ˜ë‹¤.
            if (caldDist(places[i]->lat, places[i]->lon, places[j]->lat, places[j]->lon) < 10000.0)  // 10km ì´ë‚´ë©´
            {
                addEdge(theGraph, i, j);  // ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì—ì§€ë¥¼ ì´ì–´ ì¤Œ
                addEdge(theGraph, j, i);  // ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì—ì§€ë¥¼ ì´ì–´ ì¤Œ
            }
        }
    }
}

void printGraph(Graph *graph)
{
    for(int i = 0; i < graph->nbrNode; i++)
    {
        printf("%s\n", places[i]->name);
        Edge *edge = graph->verticles[i];
        while(edge != NULL)
        {
            printf("    --- %s\n", places[edge->end]->name);
            edge = edge->next;
        }
    }
}

void inorder(Node *p)
{
    if (p == NULL)
        return;
    inorder(p->left);  
    printf("%s\n", p->data->name);
    inorder(p->right);  
}

void readData(char * name)  // Tab ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ìˆëŠ” íŒŒì¼ì˜ ë°ì´í„°ë“¤ì„ ì½ê¸°
{
    char buffer[BUFFER_SIZE];
    FILE * fp = fopen(fileName, "r");
    while(fgets(buffer, BUFFER_SIZE, fp) != NULL)
    {
        Place *place = (Place *)malloc(sizeof(Place));

        char *p = strtok(buffer, "\t"); // tokenizing
        place->state = strdup(p);

        p = strtok(NULL, "\t");
        place->name = strdup(p);

        p = strtok(NULL, "\t");
        place->lon = (double)atof(p);

        p = strtok(NULL, "\t");
        place->lat = (double)atof(p);

        p = strtok(NULL, "\t");
        place->distFromCapital = (double)atof(p);

        place->index = n;

        rename(place);

        places[n++] = place;
        insert(theTree, place);
    }

    fclose(fp);
}

void rename(Place *p)  // ì¤‘ë³µì¸ ì§€ëª…ì€ ì§€ëª… ë’¤ì— ì¤‘ë³µ ê°¯ìˆ˜ë¥¼ ë¶™ì—¬ì¤€ë‹¤.
{
    int count = 0;
    for (int i = 0; i < n; i++)
    {
        if (strncmp(p->name, places[i]-> name, strlen(p->name)) == 0)
            count++;
    }
    if (count > 0)
    {
        char namebuffer[BUFFER_SIZE];
        sprintf(namebuffer, "%s%d", p->name, (count + 1));
        free(p->name);
        p->name = strdup(namebuffer);
    }
}
```


***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}