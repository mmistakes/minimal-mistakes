---
title:  "Chater 3-2. ì¶”ìƒí™”ëœ ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬ì²´í™”í•œ ì˜í™” í‰ì  ë¦¬ìŠ¤íŠ¸ (ì—°ê²°ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©)" 

categories:
  - DataStructure2
tags:
  - [Algorithm, Data Structure, C]

toc: true
toc_sticky: true

date: 2021-02-25
last_modified_at: 2021-02-25
---

í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ ê°•ì˜ **í™ì •ëª¨ì˜ ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” Cì–¸ì–´(ë¶€ë¡)** ë¥¼ ë“£ê³  ì •ë¦¬í•œ í•„ê¸°ì…ë‹ˆë‹¤. ğŸ˜€  
<u>ppt ìº¡ì²˜ëŠ” ëª¨ë‘ êµìˆ˜ë‹˜ ê°•ì˜ì—ì„œ ìº¡ì²˜í•œ ê²ƒì„ì„ ë°í™ë‹ˆë‹¤.</u> 
{: .notice--warning}

# Chapter 3. ì¶”ìƒí™”

## ğŸš€ ì¸í„°í˜ì´ìŠ¤ì˜ í•„ìš”ì„±

![image](https://user-images.githubusercontent.com/42318591/109135460-7239ed80-779a-11eb-82ac-6a9b21331625.png)

![image](https://user-images.githubusercontent.com/42318591/109145292-a8309f00-77a5-11eb-950e-90818472a9f8.png)

"ì–´ë–¤ ë°ì´í„° ì•„ì´í…œì„ ë‹´ì„ ìˆ˜ ìˆëŠ” ë¦¬ìŠ¤íŠ¸"ë¡œì„œ ì¶”ìƒí™” í•œë‹¤. ğŸ‘‰ **ì¼ë°˜í™”!!** ì˜í™” í‰ì  ë¿ë§Œ ì•„ë‹ˆë¼ ì–´ë–¤ ë°ì´í„°ë“  ë‹´ì„ ìˆ˜ ìˆëŠ” ë¦¬ìŠ¤íŠ¸ë¡œì„œ ì¼ë°˜í™”í•˜ê¸°. <u>ëª¨ë“  ì•„ì´í…œ ë¦¬ìŠ¤íŠ¸ë“¤ì´ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ê³µí†µëœ "ê°ì²´"ì™€ "ì—°ì‚°"ì„ ì •ë¦¬í•˜ì—¬ ì¼ë°˜í™”í•  ìˆ˜ ìˆê² ë‹¤.</u>

- 1ï¸âƒ£ "ê°ì²´" ì¼ë°˜í™” (OOP ê°œë…ì—ì„œ ë³´ìë©´ ë©¤ë²„ ë³€ìˆ˜)
- 2ï¸âƒ£ "ì—°ì‚°" ì¼ë°˜í™” (OOP ê°œë…ì—ì„œ ë³´ìë©´ ì¶”ìƒ í•¨ìˆ˜)

<br>

## ğŸš€ ì¶”ìƒí™” ê³¼ì •

![image](https://user-images.githubusercontent.com/42318591/109145591-052c5500-77a6-11eb-9034-95e5dcff6fd1.png)

- 1ï¸âƒ£ ë°ì´í„°ì™€ ìë£Œ êµ¬ì¡°ì˜ ë¶„ë¦¬ 
  - ì˜í™” ë°ì´í„°ë§Œ ë‹´ì„ ìˆ˜ ìˆëŠ” ë¦¬ìŠ¤íŠ¸ì—ì„œ ëª¨ë“  ì¢…ë¥˜ì˜ ë°ì´í„°ë¥¼ ë‹´ì„ ìˆ˜ ìˆëŠ” ë¦¬ìŠ¤íŠ¸ë¡œì„œ ì¼ë°˜í™” í•´ì•¼ í•˜ê¸° ë–„ë¬¸
  - í™˜ì ë¦¬ìŠ¤íŠ¸, ì˜í™” ë¦¬ìŠ¤íŠ¸, ì‡¼í•‘ ë¦¬ìŠ¤íŠ¸ ê°™ì€ ë‹¤ì–‘í•œ ë°ì´í„°ë¥¼ ë‹´ëŠ” ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬ì²´í™” ë  ìˆ˜ ìˆë„ë¡ "ë¦¬ìŠ¤íŠ¸" ë¼ëŠ” ì¶”ìƒì ì¸ ê°œë…ì„ ì¼ë°˜í™”í•˜ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì— ë°ì´í„°ì™€ ë¶„ë¦¬í•´ì•¼í•œë‹¤. 
  - ì´ë ‡ê²Œ ë¶„ë¦¬í•˜ë©´ <u>êµ¬ì²´í™”í•  ë°ì´í„°ë¥¼ ë‹¤ë¥¸ ê²ƒìœ¼ë¡œ ë°”ê¿€ ë•Œ ì‰½ê²Œ ìˆ˜ì •ì´ ê°€ëŠ¥í•˜ë‹¤.</u>
    - ì˜í™” í‰ì  ë¦¬ìŠ¤íŠ¸ì—ì„œ ì‡¼í•‘ ë¦¬ìŠ¤íŠ¸ë¡œ ì‰½ê²Œ ë°”ê¿€ ìˆ˜ ìˆìŒ!

![image](https://user-images.githubusercontent.com/42318591/109146967-d44d1f80-77a7-11eb-8d6b-70fe8b8be7f4.png)

- 2ï¸âƒ£ ì½”ë“œ ì¬ì‚¬ìš©
  - ì™¼ìª½ ì½”ë“œê°€ ì˜¤ë¥¸ìª½ ì½”ë“œë¡œ ê°„ë‹¨í•´ì§ˆ ìˆ˜ ìˆë‹¤.

<br>

## ğŸš€ ì˜í™” í‰ì  ë¦¬ìŠ¤íŠ¸ ì¼ë°˜í™”í•˜ê¸° (ì–´ë–¤ ë¦¬ìŠ¤íŠ¸ë¡œë“  êµ¬ì²´í™” ë  ìˆ˜ ìˆë„ë¡!)

[ì˜í™” í‰ì  ê´€ë¦¬ í”„ë¡œê·¸ë¨ ì½”ë“œ ì°¸ê³ ](https://ansohxxn.github.io/datastructure2/ch1/)

![image](https://user-images.githubusercontent.com/42318591/109150979-f09f8b00-77ac-11eb-9f9b-b4752623a6ee.png)

"ë¦¬ìŠ¤íŠ¸"ìì²´ë¥¼ <u>ì¼ë°˜í™”</u> í•´ë†“ìœ¼ë©´ ë‚˜ì¤‘ì— ì˜í™” ë¦¬ìŠ¤íŠ¸ë¥¼ í™˜ì ë¦¬ìŠ¤íŠ¸ë¡œ ë°”ê¾¸ë”ë¼ë„ **Data íƒ€ì…ë§Œ 'í™˜ì' í•„ë“œë¡œ ë°”ê¾¸ë©´ ê·¸ë§Œì´ë‹¤!** 

### ğŸ“œSimpleList.h

```cpp
#pragma once

#include <stdbool.h>
#include <stdio.h>

#define TSIZE 45

// ë‚˜ì¤‘ì— ì˜í™” ë¦¬ìŠ¤íŠ¸ ë§ê³  ë‹¤ë¥¸ ë°ì´í„° ë¦¬ìŠ¤íŠ¸ ì“¸ê±°ë¼ë©´
// ì—¬ê¸°ë§Œ ìˆ˜ì •í•˜ë©´ ë•¡!!!!! ğŸ’›âœ¨ğŸ’›âœ¨ğŸ’›âœ¨
// ì–´ë–¤ ë°ì´í„°ë¥¼ ë‹´ì„ ë¦¬ìŠ¤íŠ¸ëƒì— ë”°ë¼ 
typedef struct movie {
	char name[TSIZE];
	int year;
	// struct movie* next;
}Item;

typedef struct node {
	Item item;
	struct node* next;
}Node;

// ì—°ê²°ë¦¬ìŠ¤íŠ¸ ìë£Œêµ¬ì¡°
typedef struct list {
	Node* head; // head pointer
	int size; // number of items
}List;

void InitializeList(List* plist);
bool IsEmpty(const List* plist);  
bool IsFull(const List* plist);  
bool AddItem(Item item, List* plist);
void InsertbyIndex(Item item, List* plist, int index);
void RemoveByIndex(List* plist, int index);
bool InsertItemFront(Item item, List* plist);
bool Find(const List* plist, Item item_to_find, int* index, Item* item_found, bool (*compare_func)(Item a, Item b));

unsigned int CountItems(const List* plist);
unsigned int PrintAllItems(const List* plist, void (*print_an_item_func)(Item item));
unsigned int WriteAllItems(const List* plist, FILE* file, void (*write_an_item_func)(FILE* file, Item item));

void Traverse(const List* plist, void (*pfun)(Item item)); 
void ClearList(List* plist);

bool FindItemByIndex(const List* plist, const int index, Item** item);
Node* FindNodeByIndex(const List* plist, const int index);
void RemoveFirstItem(List* plist);
void RemoveNextItem(Node* prev);

unsigned int ReadFromFile(List* plist, const char* filename, bool (*read_an_item_func)(FILE* file, Item* item));
unsigned int FindAndRun(const List* plist, Item item_to_find, bool (*compare_func)(Item a, Item b), void (*func_run)(Item item));
```

- 


<br>


### ğŸ“œSimpleList.c

```cpp
#include "SimpleList.h"
#include <stdbool.h>
#include <stdio.h>

static void CopyToNode(Item item, Node* pnode)
{
	pnode->item = item;
}

void InitializeList(List* plist)
{
	plist->head = NULL;
}

bool IsEmpty(const List* plist)
{
	if (plist->head == NULL)
		return true;
	else
		return false;
}

// ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¼ë©´ ê½‰ ì°° ì¼ì´ ê±°ì˜ ë°œìƒí•˜ì§€ ì•Šê² ì§€ë§Œ ë°°ì—´ì¼ ê²½ìš°ì—” ì¤‘ìš”í•˜ê²Œ ì‘ìš©í•  í•¨ìˆ˜
bool IsFull(const List* plist) 
{
	Node* pt;
	bool full;

	pt = (Node*)malloc(sizeof(Node));
	if (pt == NULL) // ì‹¤íŒ¨í–ˆë‹¤ë©´ ê½‰ì°¨ì„œ ë” ì´ìƒ ë§Œë“¤ ìˆ˜ ì—†ëŠ”ê±¸ë¡œ
		full = true;
	else
		full = false;
	free(pt);

	return full;
}

unsigned int CountItems(const List* plist)
{
	unsigned int count = 0;
	Node* pnode = plist->head;

	while (pnode != NULL) {
		++count;
		pnode = pnode->next;
	}
	return count;
}

bool InsertItemFront(Item item, List* plist)
{
	Node* new_node;
	new_node = (Node*)malloc(sizeof(Node));
	if (new_node == NULL) {
		priintf("Malloc failed.\n");
		return false;
	}
	CopyToNode(item, new_node);
	Node* temp = plist->head;
	plist->head = new_node;
	new_node->next = temp;
	
	return true;
}

bool AppendItem(Item item, Node* prev) // prev ë’¤ì— ì•„ì´í…œ ì¶”ê°€
{
	Node* new_node;
	new_node = (Node*)malloc(sizeof(Node));
	if (new_node == NULL) {
		priintf("Malloc failed.\n");
		return false;
	}
	CopyToNode(item, new_node);
	Node* temp = prev->next;
	prev->next = new_node;
	new_node->next = temp;

	return true;
}

bool AddItem(Item item, List* plist) // ë§¨ ë’¤ì— ì¶”ê°€
{
	Node* new_node;
	Node* search = plist->head;

	new_node = (Node*)malloc(sizeof(Node));

	if (new_node == NULL) {
		priintf("Malloc failed.\n");
		return false;
	}

	CopyToNode(item, new_node);
	new_node->next = NULL;

	if (search == NULL)
		plist->head = new_node;
	else {
		while (search->next != NULL)
			search = search->next;
		search->next = new_node;
	}

	return true;
}

// êµ¬ì²´í™” ë  ì•„ì´í…œì— ë”°ë¼ ì¶œë ¥í•´ì•¼ í• ê²Œ ë‹¤ë¥´ë‹¤. 
// (ì˜í™”ë¦¬ìŠ¤íŠ¸ì˜ ê²½ìš° ì œëª©ê³¼ ë ˆì´íŒ…ì„ ì¶œë ¥, í™˜ì ë¦¬ìŠ¤íŠ¸ì˜ ê²½ìš° í™˜ì ì´ë¦„ê³¼ ë³‘ëª… ì¶œë ¥)
// ë”°ë¼ì„œ ì¶œë ¥í•´ì•¼í•  êµ¬ì¡°ì²´ ë©¤ë²„ê°€ ë‹¤ë¥´ë¯€ë¡œ 
// ì´ ë¶€ë¶„ì€ main.cì—ì„œ ë‹¹ì‹œì— êµ¬ì²´í™” ë˜ëŠ” ë°ì´í„° ì¢…ë¥˜ì˜ ë©¤ë²„ë“¤ì„ ì¶œë ¥í•˜ëŠ” 
// í•¨ìˆ˜ë¥¼ ë”°ë¡œ ë§Œë“¤ê³  ì´ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ë„˜ê¸°ëŠ” ì‹ìœ¼ë¡œ!
unsigned int WriteAllItems(const List* plist, FILE* file, void (*write_an_item_func)(FILE* file, Item item))
{
	Node* pnode = plist->head;

	unsigned int count = 0;
	while (pnode != NULL) {
		(*write_an_item_func)(file, pnode->item);
		pnode = pnode->next;
		count++;
	}

	return count;
}

unsigned int PrintAllItems(const List* plist, void (*print_an_item_func)(Item item))
{
	Node* pnode = plist->head;
	unsigned int count = 0;
	while (pnode != NULL) {
		printf("%d : ", count);
		(*print_an_item_func)(pnode->item);
		pnode = pnode->next;
		count++;
	}

	return count++;
}

// ëª¨ë“  ë…¸ë“œë¥¼ ëŒë©´ì„œ pfun í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œí‚´
void Traverse(const List* plist, void (*pfun)(Item item))
{
	Node* pnode = plist->head;

	while (pnode != NULL) {
		(*pfun)(pnode->item);
		pnode = pnode->next;
	}
}

// ê°™ë‹¤ê³  ì°¾ì•„ë‚´ëŠ” ê¸°ì¤€ -> ë¹„êµí•¨ìˆ˜ compare_func ì£¼ì†Œ í•¨ìˆ˜ë¡œ íŒë‹¨ (í•¨ìˆ˜í¬ì¸í„°)
bool Find(const List* plist, Item item_to_find, int* index, Item* item_found, bool (*compare_func)(Item a, Item b))
{
	Node* pnode = plist->head;
	
	*index = 0;
	while (pnode != NULL) {
		if ((*compare_func)(pnode->item, item_to_find) == true) {
			*item_found = pnode->item;
			return true;
		}

		pnode = pnode->next;
		*index += 1;
	}

	return false;
}

void ClearList(List* plist)
{
	Node* iterator = plist->head;
	Node* temp = NULL;

	while (iterator != NULL) {
		temp = iterator->next;
		free(iterator);
		iterator = temp;
	}

	plist->head = NULL;
}

bool FindItemByIndex(const List* plist, const int index, Item** item)
{
	Node* pnode = plist->head; 

	int count = 0;

	while (pnode != NULL) {
		if (count == index) break;

		pnode = pnode->next;
		count++;
	}

	if (pnode == NULL)
		return false;
	else {
		*item = &pnode->item;
		return true;
	}
}

Node* FindNodeByIndex(const List* plist, const int index)
{
	Node* pnode = plist->head;

	int count = 0;

	while (pnode != NULL) {
		if (count == index) break;

		pnode = pnode->next;
		count++;
	}

	return pnode;
}

void InsertbyIndex(Item item, List* plist, int index)
{
	Node* prev = FindNodeByIndex(plist, index - 1);

	if (prev == NULL)
		InsertItemFront(item, plist);
	else
		AppendItem(item, prev);
}

void RemoveFirstItem(List* plist)
{
	Node* temp = NULL;
	if (plist->head != NULL)
		temp = plist->head->next;
	free(plist->head);
	plist->head = temp;
}

void RemoveNextItem(Node* prev) // prev ë‹¤ìŒì— ìˆëŠ” ì•„ì´í…œ ì‚­ì œ
{
	Node* temp = NULL;
	if (prev->next != NULL)
		temp = NULL;
	else
		temp = prev->next->next;
	free(prev->next);
	prev->next = temp;
}

void RemoveByIndex(List* plist, int index)
{
	Node* prev = FindNodeByIndex(plist, index - 1); // ì‚­ì œí•  ì¸ë±ìŠ¤ì— ìœ„ì¹˜í•œ ë…¸ë“œì˜ ì´ì „ ë…¸ë“œ

	if (prev == NULL) // when index is 0
		RemoveFirstItem(plist);
	else
		RemoveNextItem(prev);
}

// Item ì´ ë­”ì§€ ëª¨ë¥´ëŠ” ìƒíƒœì—¬ì•¼
unsigned int ReadFromFile(List* plist, const char* filename, bool (*read_an_item_func)(FILE* file, Item* item))
{
	FILE* file = fopen(filename, "r");

	if (file == NULL) {
		printf("ERROR: Cannot open file.\n");
		exite(1);
	}

	int num;
	if (fscanf(file, "%d%*c", &num) != 1) {
		printf("ERROR: Wrong file format.\n");
		exite(1);
	}

	for (int n = 0; n < num; ++n) {
		Item new_item;

		const bool flag = read_an_item_func(file, &new_item);

		if (flag == false) {
			printf("ERROR: Wrong file format.\n");
			exite(1);
		}
		else
			AddItem(new_item, plist);

		fclose(file);

		return num;
	}
}

unsigned int FindAndRun(const List* plist, Item item_to_find, bool (*compare_func)(Item a, Item b), void (*func_run)(Item item))
{
	Node* pnode = plist->head;

	int count = 0;
	while (pnode != NULL) {
		if ((*compare_func)(pnode->item, item_to_find) == true)
			(*func_run)(pnode->item);
		pnode = pnode->next;
		count += 1;
	}

	return count;
}
```

<br>

### ğŸ“œmain.c  

```cpp
#include "SimpleList.h"

bool read_an_item_func(FILE* file, Item* new_item);
void print_an_item(Item item);
bool name_starts_with(Item a, Item b);
bool joined_in(Item a, Item b);

int main() {
	List avengers;
	InitializeList(&avengers);

	/*
		1. Read data from a file.
		2. Print all members.
		3. Print all members whose names start with "Black"
		4. Print all members who joined in 1965.
	*/

	const int n_items = ReadFromFile(&avengers, "avengers.txt", &read_an_item_func);
	printf("%d avengers joined.\n", n_items);

	printf("\nPrint all members\n");
	PrintAllItems(&avengers, &print_an_item);

	printf("\nPrint all members whose names start with \"Black\" : \n");
	Item item_to_find;
	strcpy(item_to_find.name, "Black");
	FindAndRun(&avengers, item_to_find, &name_starts_with, &print_an_item);

	printf("\nPrint all members who joined in 1965:\n");
	item_to_find.year = 1965;
	FindAndRun(&avengers, item_to_find, &name_starts_with, &print_an_item);

	return 0;
}

bool read_an_item_func(FILE* file, Item* new_item)
{
	if (fscanf(file, "%[^\n]%*c", new_item->name) != 1 ||
		fsacnf(file, "%d%*c", &new_item->year) != 1) {
		return false;
	}
	else
		return true;
}

void print_an_item(Item item)
{
	printf("\"%s\" joined in %d\n", item.name, item.year);
}

bool name_starts_with(Item a, Item b)
{
	return strncmp(b.name, a.name, strlen(b.name)) == 0;
}

bool joined_in(Item a, Item b)
{
	return a.year == b.year;
}
```

***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}