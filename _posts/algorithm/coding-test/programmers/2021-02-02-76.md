---
title:  "[C++ë¡œ í’€ì´] ì¹´ì¹´ì˜¤ í”„ë Œì¦ˆ ì»¬ëŸ¬ë§ë¶ (BFS/DFS)â­â­" 

categories:
  - Programmers
tags:
  - [Algorithm, Coding Test]

toc: true
toc_sticky: true

date: 2021-02-02
last_modified_at: 2021-02-02
---


# ğŸ“Œ ì¹´ì¹´ì˜¤ í”„ë Œì¦ˆ ì»¬ëŸ¬ë§ë¶

> ë‚œì´ë„ â­â­

## ğŸš€ ë¬¸ì œ

![image](https://user-images.githubusercontent.com/42318591/106605509-529d1400-65a4-11eb-8498-a05a8e2e6580.png)

![image](https://user-images.githubusercontent.com/42318591/106605546-5df03f80-65a4-11eb-90d6-9df32eaeb566.png)

<br>

## ğŸš€ ë‚´ í’€ì´ 

### âœˆ 1 ì°¨ í’€ì´ âŒ

> <u>ì´ í’€ì´ëŠ” í‹€ë¦° í’€ì´ì…ë‹ˆë‹¤.</u>

```cpp
#include <vector>
#include <algorithm>

vector<int> solution(int m, int n, vector<vector<int>> picture) {
    vector<int> answer(2);
    vector<vector<pair<int, int>>> record(picture.size());   // ëª¨ë“  ì¹¸ ë§ˆë‹¤ (ì¹¸, ì†í•œ ì˜ì—­)
    vector<int> group;                                  // ì˜ì—­ë§ˆë‹¤ ëª‡ ì¹¸ ìˆëŠ”ì§€

    for (int i = 0; i < picture.size(); i++)
    {
        for (int j = 0; j < picture[i].size(); j++)
        {
            // ì†í•œ ì˜ì—­ ì°¾ê¸°
            if (picture[i][j] == 0)
            {
                record[i].push_back(make_pair(picture[i][j], -1));
                continue;
            }

            // ì™¼ìª½, ìœ„ìª½ ë‹¤ ê°™ì€ ì˜ì—­ì¸ë° ê·¸ë£¹ì„ í•©ì³ì•¼ í•  ë•Œ)
            if (j >= 1 && i >= 1 && picture[i][j - 1] == picture[i][j] && picture[i - 1][j] == picture[i][j])
            {
                if (group[record[i][j - 1].second] < group[record[i - 1][j].second])
                {
                    int groupIndex = record[i - 1][j].second;
                    record[i].push_back(make_pair(picture[i][j], groupIndex));
                    group[groupIndex]++;

                    int mustEraseGroupIndex = record[i][j - 1].second;
                    for (int k = 0; k <= j - 1; k++)
                        if (record[i][k].second == mustEraseGroupIndex)
                            record[i][k].second = groupIndex;
                    group[groupIndex] += group[mustEraseGroupIndex];
                    group.erase(group.begin() + mustEraseGroupIndex);

                    continue;
                }
                else if (group[record[i][j - 1].second] > group[record[i - 1][j].second])
                {
                    int groupIndex = record[i][j - 1].second;
                    record[i].push_back(make_pair(picture[i][j], groupIndex));
                    group[groupIndex]++;

                    int mustEraseGroupIndex = record[i - 1][j].second;
                    for (int k = 0; k <= i - 1; k++)
                        if (record[k][j].second == mustEraseGroupIndex)
                            record[k][j].second = groupIndex;
                    group[groupIndex] += group[mustEraseGroupIndex];
                    group.erase(group.begin() + mustEraseGroupIndex);

                    continue;
                }

                else if (group[record[i][j - 1].second] == group[record[i - 1][j].second])
                {
                    int groupIndex = record[i][j - 1].second;
                    record[i].push_back(make_pair(picture[i][j], groupIndex));
                    group[groupIndex]++;

                    int mustEraseGroupIndex = record[i - 1][j].second;
                    for (int k = 0; k <= i - 1; k++)
                        if (record[k][j].second == mustEraseGroupIndex)
                            record[k][j].second = groupIndex;
                    group[groupIndex] += group[mustEraseGroupIndex];
                    group.erase(group.begin() + mustEraseGroupIndex);

                    continue;
                }
            }

            // ìœ„ìª½ê³¼ ê°™ì€ ì˜ì—­ì¼ ë•Œ
            if (i >= 1 && picture[i - 1][j] == picture[i][j])
            {
                int groupIndex = record[i - 1][j].second;
                record[i].push_back(make_pair(picture[i][j], groupIndex));
                group[groupIndex]++;
                continue;
            }

            // ì™¼ìª½ê³¼ ê°™ì€ ì˜ì—­ì¼ ë•Œ
            if (j >= 1 && picture[i][j - 1] == picture[i][j])
            {
                int groupIndex = record[i][j - 1].second;
                record[i].push_back(make_pair(picture[i][j], groupIndex));
                group[groupIndex]++;
                continue;
            }

            // ì†í•œ ì˜ì—­ ì—†ìœ¼ë©´ ìƒˆë¡œìš´ ì˜ì—­
            int groupIndex = group.size();
            record[i].push_back(make_pair(picture[i][j], groupIndex));
            group.push_back(1);
        }
    }

    answer[0] = group.size();
    answer[0] != 0 ? *max_element(group.begin(), group.end()) : 0;

    return answer;
}
```

ìš”ìƒˆ ì½”í…Œë¥¼ 3 ë‹¬ë§Œì— í’€ì–´ì„œì¸ì§€ BFS, DFSë¥¼ ë‹¤ ê¹Œë¨¹ì—ˆë‹¤.. ê·¸ë˜ì„œ ì´ ë¬¸ì œë¥¼ ê·¸ë˜í”„ì— ëŒ€ì‘ì‹œí‚¤ì§€ ëª»í–ˆê³  ìœ„ì™€ ê°™ì´ ì‚½ì§ˆí•˜ë‹¤ê°€ í¬ê¸°..ã… ã…  íŒíŠ¸ë¥¼ ì‚´ì§ ë³´ë ¤ê³  êµ¬ê¸€ë§ í•´ë³´ê³ ë‚˜ì„œì•¼ ì´ ë¬¸ì œê°€ BFS ë¬¸ì œë¼ëŠ” ê²ƒì„ ì•Œê²Œ ë˜ì–´ BFSì™€ DFSë¥¼ ë³µìŠµí•œ í›„ ì•„ë˜ì™€ ê°™ì´ í’€ì´í–ˆë‹¤! 

<br>

### âœˆ BFS í’€ì´ â­•

```cpp
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

vector<int> solution(int m, int n, vector<vector<int>> picture) {
    vector<int> answer(2);

    vector<vector<bool>> found(m, vector<bool>(n, false));
    vector<int> colorCount;  // ê·¸ë˜í”„ë³„ë¡œ ì •ì (=íƒ€ì¼) ê°œìˆ˜ ì €ì¥

    const int dirX[4] = { 0, -1, 0, 1 };
    const int dirY[4] = { 1, 0, -1, 0 };

    for (int i = 0; i < picture.size(); i++) {
        for (int j = 0; j < picture[i].size(); j++) {
            if (picture[i][j] == 0 || found[i][j] == true) continue;

            // BFS ê³¼ì • (whileë¬¸ê¹Œì§€)  : ì²˜ìŒìœ¼ë¡œ ë°©ë¬¸ ì•ˆí•œ ì§€ì—­ì„ ë°œê²¬í•œë‹¤ë©´ ê·¸ê±´ ìƒˆë¡œìš´ ê·¸ë˜í”„(=ìƒˆë¡œìš´ ìƒ‰ ë°œê²¬)ë¼ëŠ” ëœ»ì´ë‹¤. BFS ìˆœíšŒë¥¼ ì‹œì‘í•´ì•¼í•¨.
            int nowRow = i;
            int nowCol = j;
            queue<pair<int, int>> q;
            q.push(make_pair(nowRow, nowCol));
            found[nowRow][nowCol] = true;

            colorCount.push_back(1); // ìƒˆë¡œìš´ ê·¸ë˜í”„ ìˆœíšŒë¥¼ ì‹œì‘í–ˆìœ¼ë‹ˆ ì¶œë°œì§€ 1ê°œ ì¶”ê°€

            while (q.empty() == false) {
                pair<int, int> pos = q.front();
                nowRow = pos.first;
                nowCol = pos.second;
                q.pop();

                for (int k = 0; k < 4; k++) {
                    int nextRow = nowRow + dirX[k];
                    int nextCol = nowCol + dirY[k];

                    if (nextRow < 0 || nextRow > m - 1 || nextCol < 0 || nextCol > n - 1) // 1. ê·¸ë¦¼ì„ ë²—ì–´ë‚œ ì˜ì—­ì´ ì•„ë‹ˆê³ 
                        continue;
                    if (found[nextRow][nextCol] == true) // 2. ì˜ˆì•½ëœ ì ì´ ì—†ê³ 
                        continue;
                    if (picture[nowRow][nowCol] != picture[nextRow][nextCol]) // 3. ìƒ‰ê¹”ì´ ê°™ë‹¤ë©´ ! ì´ë ‡ê²Œ 1,2,3 ì¡°ê±´ì„ ëª¨ë‘ ë§Œì¡±í•˜ë©´ ì—°ê²°ë˜ì–´ ìˆëŠ” íƒ€ì¼ì´ë‹ˆ ì¶”í›„ ë°©ë¬¸ì„ ìœ„í•´ íì— ì˜ˆì•½! 
                        continue;

                    q.push(make_pair(nextRow, nextCol));
                    found[nextRow][nextCol] = true;

                    colorCount.back()++; // ì§€ê¸ˆ ìˆœíšŒì¤‘ì¸ ì´ ê·¸ë˜í”„ëŠ” colorCountì— ìµœê·¼ì— ë’¤ì— ì¶”ê°€ë˜ì—ˆìœ¼ë‹ˆ ê°€ì¥ ë§ˆì§€ë§‰ ì›ì†Œë‹¤. ì˜ˆì•½í–ˆê³  ê³§ ë°©ë¬¸ ì˜ˆì •ì´ë‹ˆ íƒ€ì¼ ê°œìˆ˜ 1 ë”í•´ì¤Œ.
                }
            }
        }
    }

    answer[0] = colorCount.size();
    answer[1] = *max_element(colorCount.begin(), colorCount.end());

    return answer;
}
```

> ê·¸ë˜í”„ì— ëŒ€ì‘ì‹œí‚¤ê¸°

- ì˜ˆì „ì— ë°°ì› ë˜ ë¯¸ë¡œì°¾ê¸°ì²˜ëŸ¼ íƒ€ì¼ í•˜ë‚˜í•˜ë‚˜ë¥¼ ê·¸ë˜í”„ "ì •ì "ìœ¼ë¡œ ìƒê°í•˜ê³ , ê°™ì€ ìƒ‰ê¹” && 0 ì´ ì•„ë‹Œ ê³³ì´ë¼ ê°ˆ ìˆ˜ ìˆëŠ” ê³³ì´ë¼ë©´ "ê°„ì„ "ìœ¼ë¡œ ì—°ê²°ë˜ì–´ìˆëŠ” ì •ì ì´ë¼ê³  ìƒê°í•˜ë©´ ëœë‹¤. ì´ë ‡ê²Œ ê·¸ë˜í”„ì— ëŒ€ì‘ì‹œí‚¬ ìˆ˜ ìˆë‹¤ë©´ **ê·¸ë˜í”„ë¥¼ ìˆœíšŒ**í•˜ëŠ” ë¬¸ì œë¡œ ìƒê°í•´ë³¼ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤. 
- <u>ì—°ê²° ë˜ì–´ ìˆëŠ” ëª¨ë“  ì •ì  ìˆœíšŒ</u> ğŸ‘‰ `DFS`, `BFS` 
  - ì—°ê²° ë˜ì–´ ìˆë‹¤ê³  íŒë‹¨ë˜ëŠ” ê¸°ì¤€
    1. `0` ì´ ì•„ë‹Œ ê³³
    2. ë‚˜(ì •ì )ì™€ ê°™ì€ ìƒ‰ê¹” (pictrue ì›ì†Œ ê°’ì´ ê°™ì„ ë•Œ)
    3. ë‚˜(ì •ì )ì˜ ìƒí•˜ì¢Œìš°ì— ìˆì„ ë•Œ 

> BFS

ì˜ˆì œì—ì„  ê·¸ë¦¼ì´ 12ê°œ ì˜ì—­ìœ¼ë¡œ ë‚˜ë‰˜ì–´ì ¸ ìˆë‹¤ê³  í–ˆëŠ”ë° ì´ëŠ” ê·¸ë˜í”„ê°€ ë…ë¦½ì ìœ¼ë¡œ 12ê°œ ìˆëŠ” ê²ƒì´ë‚˜ ë§ˆì°¬ê°€ì§€ì´ë‹¤. ê°™ì€ ìƒ‰ê¹”ì´ê³  ìƒí•˜ì¢Œìš°ì— ìˆëŠ” ê²ƒë“¤ë¼ë¦¬ê°€ ê°™ì€ ê·¸ë˜í”„ë¼ê³  ìƒê°í•  ìˆ˜ ìˆë‹¤. ìƒ‰ê¹”ì´ ë‹¤ë¥¸ íƒ€ì¼ì€ ì„œë¡œ ë‹¤ë¥¸ ê·¸ë˜í”„ë¼ ì—°ê²°ë˜ì–´ ìˆì§€ ì•Šë‹¤ê³  ë³¼ ìˆ˜ ìˆë‹¤.


ì´ì¤‘ forë¬¸ ë‚´ì—ì„œ BFSë¥¼ ì§„í–‰í•˜ëŠ” ì´ìœ ëŠ”, ì´ëŸ¬í•œ ê°ê°ì˜ ê·¸ë˜í”„ë³„ë¡œ BFS ë¥¼ ì§„í–‰í•˜ê¸° ìœ„í•´ì„œì´ë‹¤. ê·¸ë˜í”„ê°€ í•˜ë‚˜ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤! ì–´í”¼ì¹˜ ì–¼êµ´ ìƒ‰ì´ ë˜ëŠ” ë¶„í™ìƒ‰ íƒ€ì¼ë“¤ì„ íë¥¼ ì‚¬ìš©í•´ BFSë¡œ ëª¨ë‘ ìˆœíšŒí–ˆë‹¤ë©´ ë¶„í™ìƒ‰ ê·¸ë˜í”„ í•˜ë‚˜ë¥¼ ì „ë¶€ ìˆœíšŒí•œ ê²ƒì´ë‚˜ ë§ˆì°¬ê°€ì§€ì´ë‹ˆ ì´ ë¶„í™ íƒ€ì¼ë“¤ì€ ì „ë¶€ ë°©ë¬¸ ì²´í¬ê°€ ë˜ì–´ ìˆì„ ê²ƒì´ë‹¤. ë‹¤ìŒ forë¬¸ ë°˜ë³µì—ì„œ ì²˜ìŒìœ¼ë¡œ ë°©ë¬¸ì´ ì•ˆëœ ìƒ‰ê¹”ì„ ë°œê²¬í•˜ë©´ ì´ì œ ê·¸ íƒ€ì¼ì€ ìƒˆë¡œìš´ ê·¸ë˜í”„ì— ì†í•œ ì •ì ì¸ ê²ƒì´ë‹ˆ ìƒˆë¡­ê²Œ ê·¸ íƒ€ì¼ì„ ì‹œì‘ì ìœ¼ë¡œ íë¥¼ ìƒì„±í•´ì„œ BFSë¡œ ë˜ ê·¸ ìƒˆë¡œìš´ ê·¸ë˜í”„ë¥¼ ìˆœíšŒí•˜ê³  ì´ëŸ° ì‹ì´ë‹¤! ìœ„ì˜ ì½”ë“œë¡œ ë³´ìë©´ íê°€ ì´ì¤‘ forë¬¸ ë„ëŠ”ë™ì•ˆ ì´ 12ë²ˆ ë§Œë“¤ì–´ì¡Œê³  BFSê°€ 12ë²ˆ ì‹¤í–‰ë˜ì—ˆì„ ê²ƒì„ì„ ì•Œ ìˆ˜ ìˆë‹¤! 


ì•„ë˜ ê³¼ì •ì„ íê°€ ë¹„ì–´ìˆì„ ë•Œê¹Œì§€(= í•˜ë‚˜ì˜ ê·¸ë˜í”„ ìˆœíšŒë¥¼ ì™„ë£Œí•  ë•Œê¹Œì§€) ë°˜ë³µí•œë‹¤. 

1. íì—ì„œ êº¼ë‚´ì„œ ë°©ë¬¸í•œë‹¤. 
  ```cpp
              while (q.empty() == false) {
                pair<int, int> pos = q.front();
                nowRow = pos.first;
                nowCol = pos.second;
                q.pop();
  ```
2. ì—°ê²°ë˜ì–´ ìˆëŠ” ì •ì ì„ ê²€ì‚¬í•œ í›„ í†µê³¼í•˜ë©´ íì— ì‚½ì…í•˜ì—¬ ì˜ˆì•½
  ```cpp
                  for (int k = 0; k < 4; k++) {
                    int nextRow = nowRow + dirX[k];
                    int nextCol = nowCol + dirY[k];

                    if (nextRow < 0 || nextRow > m - 1 || nextCol < 0 || nextCol > n - 1) // 1. ê·¸ë¦¼ì„ ë²—ì–´ë‚œ ì˜ì—­ì´ ì•„ë‹ˆê³ 
                        continue;
                    if (found[nextRow][nextCol] == true) // 2. ì˜ˆì•½ëœ ì ì´ ì—†ê³ 
                        continue;
                    if (picture[nowRow][nowCol] != picture[nextRow][nextCol]) // 3. ìƒ‰ê¹”ì´ ê°™ë‹¤ë©´ ! ì´ë ‡ê²Œ 1,2,3 ì¡°ê±´ì„ ëª¨ë‘ ë§Œì¡±í•˜ë©´ ì—°ê²°ë˜ì–´ ìˆëŠ” íƒ€ì¼ì´ë‹ˆ ì¶”í›„ ë°©ë¬¸ì„ ìœ„í•´ íì— ì˜ˆì•½! 
                        continue;

                    q.push(make_pair(nextRow, nextCol));
                    found[nextRow][nextCol] = true;

                    colorCount.back()++; // ì§€ê¸ˆ ìˆœíšŒì¤‘ì¸ ì´ ê·¸ë˜í”„ëŠ” colorCountì— ìµœê·¼ì— ë’¤ì— ì¶”ê°€ë˜ì—ˆìœ¼ë‹ˆ ê°€ì¥ ë§ˆì§€ë§‰ ì›ì†Œë‹¤. ì˜ˆì•½í–ˆê³  ê³§ ë°©ë¬¸ ì˜ˆì •ì´ë‹ˆ íƒ€ì¼ ê°œìˆ˜ 1 ë”í•´ì¤Œ.
                }
  ```


![image](https://user-images.githubusercontent.com/42318591/106684075-12bc4800-6609-11eb-973d-9a3663457e1f.png)


<br>

### âœˆ DFS í’€ì´ â­•

```cpp
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

int DFS (vector<vector<int>>& picture, vector<vector<bool>>& found, int& m, int& n, int& color, int row, int col){
    int count = 1;  // DFSê°€ ì§„í–‰ë˜ëŠ” ë™ì•ˆ íƒ€ì¼ ê°œìˆ˜ë¥¼ í•˜ë‚˜ì”© ì„¼ë‹¤.
    found[row][col] = true;
    
    // ìœ„ ìª½ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ê²€ì‚¬í•˜ê³  ì—°ê²°ë˜ì–´ ìˆë‹¤ë©´ ê¹Šì´ ë“¤ì–´ê°.
    if (row - 1 >= 0) 
        if(picture[row - 1][col] == color)
            if(found[row - 1][col] == false)
                count += DFS(picture, found, m, n, color, row - 1, col);
    // ì•„ë˜ ìª½ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ê²€ì‚¬í•˜ê³  ì—°ê²°ë˜ì–´ ìˆë‹¤ë©´ ê¹Šì´ ë“¤ì–´ê°.
    if (row + 1 < m) 
        if(picture[row + 1][col] == color)
            if(found[row + 1][col] == false)
                count += DFS(picture, found, m, n, color, row + 1, col);
    // ì™¼ ìª½ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ê²€ì‚¬í•˜ê³  ì—°ê²°ë˜ì–´ ìˆë‹¤ë©´ ê¹Šì´ ë“¤ì–´ê°.
    if (col - 1 >= 0) 
        if(picture[row][col - 1] == color)
            if(found[row][col - 1] == false)
                count += DFS(picture, found, m, n, color, row, col - 1);
    // ì˜¤ë¥¸ ìª½ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ê²€ì‚¬í•˜ê³  ì—°ê²°ë˜ì–´ ìˆë‹¤ë©´ ê¹Šì´ ë“¤ì–´ê°.
    if (col + 1 < n) 
        if(picture[row][col + 1] == color)
            if(found[row][col + 1] == false)
                count += DFS(picture, found, m, n, color, row, col + 1);
    
    return count;
}

vector<int> solution(int m, int n, vector<vector<int>> picture) {
    vector<int> answer(2);

    vector<vector<bool>> found(m, vector<bool>(n, false));
    vector<int> colorCount;

    for (int i = 0; i < picture.size(); i++) {
        for (int j = 0; j < picture[i].size(); j++) {
            if (picture[i][j] == 0 || found[i][j] == true) continue;
                colorCount.push_back(DFS(picture, found, m, n, picture[i][j], i, j));
        }
    }

    answer[0] = colorCount.size();
    answer[1] = *max_element(colorCount.begin(), colorCount.end());

    return answer;
}
```

DFSë„ ìœ„ì˜ BFS í’€ì´ì™€ ë§ˆì°¬ê°€ì§€ë¡œ, ê·¸ë˜í”„ê°€ 12ê°œì´ë‹ˆ (ê°™ì€ ìƒ‰ê¹”ì´ê³  ìƒí•˜ì¢Œìš° ì—°ê²°ë˜ì–´ ìˆëŠ” ê²ƒë“¤ì´ í•˜ë‚˜ì˜ ê·¸ë˜í”„) ì´ì¤‘ forë¬¸ì—ì„œ DFSë¥¼ ì‹¤í–‰í•œë‹¤. 

![image](https://user-images.githubusercontent.com/42318591/106684028-ff10e180-6608-11eb-8fd0-8c6dc05afadc.png)

`BFS`ê°€ ë” ë¹ ë¥¸ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ì•„ë¬´ë˜ë„ `DFS`ëŠ” ì¬ê·€ë¥¼ ì‚¬ìš©í•´ì„œì¸ ê²ƒ ê°™ë‹¤. 


***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}