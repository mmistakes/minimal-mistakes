---
title:  "[C++ë¡œ í’€ì´] ë©”ë‰´ ë¦¬ë‰´ì–¼ (DFS, ì¡°í•©)â­â­" 

categories:
  - Programmers
tags:
  - [Algorithm, Coding Test]

toc: true
toc_sticky: true

date: 2021-02-05
last_modified_at: 2021-02-05
---


# ğŸ“Œ ë©”ë‰´ ë¦¬ë‰´ì–¼

> ë‚œì´ë„ â­â­

## ğŸš€ ë¬¸ì œ

![image](https://user-images.githubusercontent.com/42318591/106905985-11da0200-6740-11eb-96bb-426fe73ef7ba.png)

![image](https://user-images.githubusercontent.com/42318591/106906038-1ef6f100-6740-11eb-88c7-2c44ca40f151.png)


<br>

## ğŸš€ ë‚´ í’€ì´ â­• (DFSë¡œ ì¡°í•© êµ¬í•˜ê¸°)

```cpp
#include <string>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

bool cmp(pair<string, int> a, pair<string, int> b){
    return a.second > b.second;
}

void DFS(map<string, int>& dic, string& order, string comb, int index, int depth) {
    if (depth == comb.length()) {
        dic[comb]++;
        return;
    }

    for (int i = index; i < order.length(); i++) {
        comb[depth] = order[i];
        DFS(dic, order, comb, i + 1, depth + 1);
    }
}

vector<string> solution(vector<string> orders, vector<int> course) {
    vector<string> answer;
    map<string, int> dic;

    for (int i = 0; i < orders.size(); i++) {
        sort(orders[i].begin(), orders[i].end());
        for (int j = 0; j < course.size(); j++) {
            string comb = "";
            comb.resize(course[j]);
            DFS(dic, orders[i], comb, 0, 0);
        }
    }
    
    vector<pair<string, int>> sorted;
    for (auto& order : dic) 
        if (order.second > 1)
            sorted.push_back(make_pair(order.first, order.second));
    sort(sorted.begin(), sorted.end(), cmp);
    
    for(int i = 0; i < course.size(); i++){
        int max = 0;
        for(int j = 0; j < sorted.size(); j++){
            if (sorted[j].first.length() != course[i]) 
                continue;
            else if (max == 0){
                answer.push_back(sorted[j].first);
                max = sorted[j].second;
            }
            else if (max == sorted[j].second)
                answer.push_back(sorted[j].first);
            else
                break;
        }
    }
    
    sort(answer.begin(), answer.end());
    return answer;
}
```

```
ë¨¼ì € ë¬¸ì œì— ëŒ€í•œ í•´ë‹µì„ ì–»ê¸° ì „ì—, ê° ë©”ë‰´ë³„ë¡œ ê°€ëŠ¥í•œ ëª¨ë“  ì¡°í•©ì„ ë§Œë“¤ì–´ ë´…ë‹ˆë‹¤. 
ì˜ˆë¥¼ ë“¤ì–´ â€œABCDâ€ì˜ ê²½ìš° ë‹¤ìŒê³¼ ê°™ì´ 11ê°€ì§€ ì¡°í•©ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

- â€œABâ€, â€œACâ€, â€œADâ€, â€œBCâ€, â€œBDâ€, â€œCDâ€, â€œABCâ€, â€œABDâ€, â€œACDâ€, â€œBCDâ€, â€œABCDâ€

ìœ„ì™€ ê°™ì´ ê° ë©”ë‰´ì—ì„œ ê°€ëŠ¥í•œ ëª¨ë“  ì¡°í•©ì„ ë§Œë“¤ì—ˆë‹¤ë©´, ê° ì¡°í•©ì˜ ê°œìˆ˜ë¥¼ ì„¸ë©´ ë©ë‹ˆë‹¤. 
ì´ë•Œ â€œABCâ€ì™€ â€œCBAâ€ë¥¼ ê°™ì€ ì¡°í•©ìœ¼ë¡œ ì„¸ëŠ” ì ì„ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤. 
ì‰½ê²Œ í•´ê²°í•˜ëŠ” ë°©ë²•ìœ¼ë¡œëŠ” ì²˜ìŒì— ê° ë¬¸ìì—´ì„ ì•ŒíŒŒë²³ ìˆœì„œë¡œ ì •ë ¬í•˜ê±°ë‚˜, ë§Œë“¤ì–´ì§„ ì¡°í•© ë¬¸ìì—´ì„ ì •ë ¬í•˜ëŠ” ë°©ë²•ì´ ìˆê² ìŠµë‹ˆë‹¤.

ê° ì¡°í•©ë³„ë¡œ ê°œìˆ˜ë¥¼ ì…Œë‹¤ë©´, ìµœì¢…ì ìœ¼ë¡œ ë¬¸ìì—´ì˜ ê¸¸ì´ê°€ ê°™ì€ ì¡°í•© ì¤‘ ê°€ì¥ ë§ì´ ë‚˜íƒ€ë‚œ ì¡°í•©ì€ ë¬´ì—‡ì¸ì§€ ì°¾ìœ¼ë©´ ë©ë‹ˆë‹¤.
```

> ì¶œì²˜ : Kakao Tech 2021 ì¹´ì¹´ì˜¤ ì‹ ì… ê³µì±„ 1ì°¨ ì½”í…Œ ë¬¸ì œ í•´ì„¤ <https://tech.kakao.com/2021/01/25/2021-kakao-recruitment-round-1/>

ì´ ë¬¸ì œëŠ” ì–´ë–»ê²Œ í’€ì–´ì•¼í• ì§€ ê°ì„ ì „í˜€ ëª» ì¡ê² ì–´ì„œ Kakao Tech ì‚¬ì´íŠ¸ì— ì°¾ì•„ê°€ ìœ„ì™€ ê°™ì€ í•´ì„¤ì„ ë³¸ í›„ í’€ì´ë¥¼ í•  ìˆ˜ ìˆì—ˆë‹¤.ã… ã…  ê·¸ëƒ¥ <u>ì¡°í•©ì„ ë‹¤ êµ¬í•´ì„œ ì¹´ìš´íŒ… í•˜ëŠ”ê±°êµ¬ë‚˜..!</u>

<br>

### 1ï¸âƒ£ ëª¨ë“  ì¡°í•© êµ¬í•˜ê³  ì¡°í•© ì¢…ë¥˜ì— ë”°ë¥¸ ì¹´ìš´íŒ…í•˜ê¸° (mapì— ì €ì¥)

```cpp
void DFS(map<string, int>& dic, string& order, string comb, int index, int depth) {
    if (depth == comb.length()) {
        dic[comb]++;
        return;
    }

    for (int i = index; i < order.length(); i++) { // orderì˜ indexë¶€í„°
        comb[depth] = order[i];
        DFS(dic, order, comb, i + 1, depth + 1); // indexì— i+1ë¥¼ ë„˜ê¹€. â­ì¦‰, ë‹¤ìŒ ë¬¸ìë¶€í„° DFS ì‹œì‘ (ì¤‘ë³µ í—ˆìš© X)â­
    }
}

vector<string> solution(vector<string> orders, vector<int> course) {
    vector<string> answer;
    map<string, int> dic;

    for (int i = 0; i < orders.size(); i++) {
        sort(orders[i].begin(), orders[i].end());
        for (int j = 0; j < course.size(); j++) {
            string comb = "";
            comb.resize(course[j]);
            DFS(dic, orders[i], comb, 0, 0); 
        }
    }
```

- 1ï¸âƒ£ ì¡°í•©ì—ì„  "AB"ë‚˜ "BA"ë‚˜ ë™ì¼í•œ ê²ƒì´ê¸° ë•Œë¬¸ì— ì´ë¥¼ ê³ ë ¤í•˜ì—¬ ë¨¼ì € `orders`ì˜ ëª¨ë“  ë¬¸ìì—´ì„ ì‚¬ì „ìˆœìœ¼ë¡œ ì •ë ¬í•œ í›„ ì§„í–‰í•œë‹¤.
- 2ï¸âƒ£ `orders`ì˜ ì›ì†Œë“¤(string)ë§ˆë‹¤ `course`ì˜ ì›ì†Œë“¤ì— í•´ë‹¹í•˜ëŠ” ìˆ˜ì˜ ëª¨ë“  ì¡°í•©ì„ êµ¬í•œë‹¤. 
  - ì˜ˆë¥¼ ë“¤ì–´ `course`ê°€ [2, 3, 4]ì´ë¼ë©´ "ABCD" ì£¼ë¬¸ì—ì„œ ì–»ì„ ìˆ˜ ìˆëŠ” ì¡°í•©ì˜ ì¢…ë¥˜ëŠ” 
    - 2 ğŸ‘‰ â€œABâ€, â€œACâ€, â€œADâ€, â€œBCâ€, â€œBDâ€, â€œCDâ€
    - 3 ğŸ‘‰ â€œABCâ€, â€œABDâ€, â€œACDâ€, â€œBCDâ€
    - 4 ğŸ‘‰ â€œABCDâ€
  - `depth`ê°€ ê³ ì •ì ì¸ `comb`ì˜ ê¸¸ì´(=`course[j]`)ì— ë„ë‹¬í•˜ë©´ í•´ë‹¹ ì¡°í•©ì´ ì™„ì„±ë˜ì–´ DFS ì¢…ë£Œ.
  - DFS ìˆœì„œ 
    - `course[j]`ê°€ 2 ë¼ë©´ 
      - "A"ğŸ‘‰"AB" (ì¬ê·€ì¢…ë£Œ)
      - "A"ğŸ‘‰"AC" (ì¬ê·€ì¢…ë£Œ)
      - "A"ğŸ‘‰"AD" (ì¬ê·€ì¢…ë£Œ)
      - "B"ğŸ‘‰"BC" (ì¬ê·€ì¢…ë£Œ)
      - "B"ğŸ‘‰"BD" (ì¬ê·€ì¢…ë£Œ)
      - "C"ğŸ‘‰"CD" (ì¬ê·€ì¢…ë£Œ)
    - `course[j]`ê°€ 3 ë¼ë©´
      - "A" ğŸ‘‰ "AB" ğŸ‘‰ "ABC" (ì¬ê·€ì¢…ë£Œ)
      - "A" ğŸ‘‰ "AB" ğŸ‘‰ "ABD" (ì¬ê·€ì¢…ë£Œ)
      - "A" ğŸ‘‰ "AC" ğŸ‘‰ "ACD" (ì¬ê·€ì¢…ë£Œ)
      - "B" ğŸ‘‰ "BC" ğŸ‘‰ "BCD" (ì¬ê·€ì¢…ë£Œ)
- 3ï¸âƒ£ í•˜ë‚˜ì˜ string `orders[i]`ì—ì„œ êµ¬í•œ **ëª¨ë“  ì¡°í•© ë¬¸ìì—´ì„ map ì˜ Key ë¡œ ì¶”ê°€í•œë‹¤. ê·¸ë¦¬ê³  ValueëŠ” ì´ ì¡°í•© ë¬¸ìì—´ì´ ëª¨ë“  orders ë¥¼ ëŒë©´ì„œ ë“±ì¥í•œ íšŸìˆ˜ê°€ ì €ì¥ë  ê²ƒì´ë‹¤.**
  - 3 ë²ˆì§¸ ì˜ˆì œì˜ `orders`ë¡œ ì§„í–‰í–ˆë‹¤ë©´ `dic` mapì˜ ìƒíƒœ
    - dic["AW"] = 1; dic["AWX"] = 1; dic["AX"] = 1; dic["WX"] = 2; dic["WXY"] = 1; dic["WY"] = 1; dic["XY"] = 2; dic["XYZ"] = 1; dic["XZ"] = 1; dic["YZ"] = 1;
- 4ï¸âƒ£ *DFS(dic, orders[i], comb, 0, 0);* ì€ ê³§ nCr ì¡°í•©ì„ êµ¬í•˜ëŠ” ê³¼ì •ì¸ë°, ì—¬ê¸°ì„œ nì´ `order[i].length()`ê°€ ë˜ê³  r ì´ `course[j]`ê°€ ëœë‹¤. 


[(C++) ì¡°í•©(Combination)ì„ êµ¬í˜„í•˜ëŠ” ì—¬ëŸ¬ê°€ì§€ ë°©ë²•](https://ansohxxn.github.io/algorithm/combination/)

<br>

### 2ï¸âƒ£ map ì„ vector ë¡œ ì˜®ê¸°ê³  value(ë“±ì¥í•œ íšŸìˆ˜)ë³„ë¡œ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ (ê°€ì¥ ë§ì´ ë“±ì¥í•œê²Œ ê°€ì¥ ì•ì— ì˜¤ê²Œë”)

```cpp
bool cmp(pair<string, int> a, pair<string, int> b){
    return a.second > b.second;
}

//...
    vector<pair<string, int>> sorted;
    for (auto& order : dic) 
        if (order.second > 1)
            sorted.push_back(make_pair(order.first, order.second));
    sort(sorted.begin(), sorted.end(), cmp);
```

ê°€ì¥ ë§ì´ ë“±ì¥í•œ ì¡°í•©ì„ ë©”ë‰´ë¡œ ì‚¼ì„ ê²ƒì´ê¸° ë•Œë¬¸ì— **Valueì— ì˜í•œ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬**ì„ ì§„í–‰í•´ì•¼ í•œë‹¤. map ìì²´ëŠ” Keyì— ì˜í•œ ì •ë ¬ë°–ì— ì•ˆë˜ê¸° ë•Œë¬¸ì— vectorì— mapì˜ ì›ì†Œë“¤ì„ pair ì›ì†Œë¡œ ì˜®ê¸´ í›„ ì´ë¥¼ Valueì¸ `order.second`ì— ì˜í•´ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ ì‹œí‚¨ë‹¤. 

ê·¸ë¦¬ê³  ì–´ì°¨í”¼ 1 ë²ˆ ë°–ì— ë“±ì¥í•˜ì§€ ì•Šì€ ì¡°í•© ë¬¸ìì—´(ì£¼ë¬¸ ì¡°í•©)ë“¤ì€ 2 ë²ˆ ì´ìƒ ë‚˜ì˜¤ì§€ ì•Šì€ ê²ƒì´ë¯€ë¡œ vectorì— ë„£ì§€ ì•Šì•˜ë‹¤. 

3 ë²ˆì§¸ ì˜ˆì œì˜ `orders`ë¡œ ì§„í–‰í–ˆë‹¤ë©´ `dic` mapì˜ ìƒíƒœë¥¼ ìœ„ì™€ ê°™ì´ ì •ë ¬í•œ ì´í›„ `sorted`ì˜ ìƒíƒœ ğŸ‘‰ ("WX", 2) ("XY", 2)

<br>

### 3ï¸âƒ£ ë‚´ë¦¼ ì°¨ìˆœ ì •ë ¬ëœ ê²ƒì˜ ìµœëŒ€ê°’ì— í•´ë‹¹í•˜ëŠ” ê²ƒë“¤ answerì— ì‚½ì…

```cpp
    for(int i = 0; i < course.size(); i++){
        int max = 0;
        // ë©”ë‰´ ìˆ˜ê°€ course[i]ì¸ ê²ƒì˜ ìµœë‹¤ ë“±ì¥ ë©”ë‰´ ì¡°í•©ë“¤ êµ¬í•˜ê¸°
        for(int j = 0; j < sorted.size(); j++){
            if (sorted[j].first.length() != course[i]) 
                continue;
            else if (max == 0){ // ìµœëŒ€ê°’ ì²« ë“±ì¥ (maxì— ì´ë¥¼ ì €ì¥)
                answer.push_back(sorted[j].first);
                max = sorted[j].second;
            }
            else if (max == sorted[j].second) // ìµœëŒ€ê°’ì´ ì—¬ëŸ¬ê°œì¼ ê²½ìš°ë¥¼ ëŒ€ë¹„í•˜ì—¬  (maxì™€ ì¼ì¹˜í•˜ë©´)
                answer.push_back(sorted[j].first);
            else // ì´ì œ ìµœëŒ€ê°’ì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ break
                break;
        }
    }
    
    sort(answer.begin(), answer.end());
```

- `course` ì›ì†Œ, ì¦‰ ë©”ë‰´ ìˆ˜ë³„ë¡œ ìµœëŒ€ê°’ì„ ì €ì¥í•´ì•¼í•˜ë©°
- ìµœëŒ€ê°’ì´ ì—¬ëŸ¬ê°œì¼ ê²½ìš° ê·¸ ë©”ë‰´ë“¤ë„ ì „ë¶€ ì¶”ê°€í•œë‹¤. 

ì˜ˆë¥¼ë“¤ì–´ ì˜ˆì œ 1ì˜ ê²½ìš° ë©”ë‰´ `4`ê°œì˜ ì¡°í•© ê°™ì€ ê²½ìš° ìµœëŒ€ ë“±ì¥ íšŸìˆ˜ê°€ "ACDE", "BCFG"ê°€ ë™ì¼í•˜ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ë‘˜ ë‹¤ `answer`ì— ì¶”ê°€ê°€ ë˜ì•¼ í•œë‹¤. "ACDE" ëŠ” ì²«ë²ˆì§¸ `else if`ë¥¼ í†µí•´ ì¶”ê°€ë  ê²ƒì´ê³  "BCFG"ëŠ” ì²« ë“±ì¥ì´ ì•„ë‹ˆë¯€ë¡œ ë‘ë²ˆì§¸ `else if`ë¥¼ í†µí•´ ì¶”ê°€ë  ê²ƒ.

- ë¬¸ìì—´ ì›ì†Œ ìì²´ë“¤ì€ ì •ë ¬ë˜ì–´ ìˆì§€ë§Œ ì „ì²´ì ì¸ ì •ë ¬ë„ í•´ì£¼ê¸° ìœ„í•´ ë§ˆì§€ë§‰ìœ¼ë¡œ í•œë²ˆ ë” `answer`ë¥¼ ì •ë ¬

<br>

## ğŸš€ ë‹¤ë¥¸ í’€ì´ (next_permutationìœ¼ë¡œ ì¡°í•© êµ¬í•˜ê¸°)

```cpp
#include <string>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

bool cmp(pair<string, int> a, pair<string, int> b){
    return a.second > b.second;
}

vector<string> solution(vector<string> orders, vector<int> course) {
    vector<string> answer;
    map<string, int> dic;

    for (int i = 0; i < orders.size(); i++) {
        sort(orders[i].begin(), orders[i].end());
        
        for (int j = 0; j < course.size(); j++) {
            if (course[j] > orders[i].length())
                continue;
            vector<bool> temp(orders[i].length(), true);
            for(int k = 0; k < course[j]; k++)
                temp[k] = false;
            do{
                string str = "";
                for(int k = 0; k < orders[i].length(); k++)
                    if (temp[k] == false)
                        str += orders[i][k];
                dic[str]++;
            }while(next_permutation(temp.begin(), temp.end()));
        }
    }
    
    vector<pair<string, int>> sorted;
    for (auto& order : dic) 
        if (order.second > 1)
            sorted.push_back(make_pair(order.first, order.second));
    sort(sorted.begin(), sorted.end(), cmp);
    
    for(int i = 0; i < course.size(); i++){
        int max = 0;
        for(int j = 0; j < sorted.size(); j++){
            if (sorted[j].first.length() != course[i]) 
                continue;
            else if (max == 0){
                answer.push_back(sorted[j].first);
                max = sorted[j].second;
            }
            else if (max == sorted[j].second)
                answer.push_back(sorted[j].first);
            else
                break;
        }
    }
    
    sort(answer.begin(), answer.end());
    return answer;
}
```
```cpp
    // nCr ì¡°í•© ğŸ‘‰ ì—¬ê¸°ì„œ nì€ orders[i].length()ê°€ ë˜ê³  rì€ course[j]ê°€ ëœë‹¤.
    for (int i = 0; i < orders.size(); i++) {
        sort(orders[i].begin(), orders[i].end());
        
        for (int j = 0; j < course.size(); j++) {
            if (course[j] > orders[i].length())  // ì´ê±° ì•ˆí•´ì£¼ë©´ ë°‘ì—ì„œ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤!! nCrì— ìˆì–´ì„œ rì´ në³´ë‹¤ í¬ë©´ ì•ˆëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì£¼ë¬¸ 3ê°œë°–ì— ì•ˆí–ˆëŠ”ë° 4ê°œ ì§œë¦¬ ì¡°í•© ìƒì„±í•˜ë ¤ëŠ” ê²½ìš° ë°©ì§€
                continue;
            vector<bool> temp(orders[i].length(), true);
            for(int k = 0; k < course[j]; k++) // ì•ì˜ rê°œë¥¼ falseë¡œ í•˜ê¸°ë¡œ í–ˆë‹¤. 
                temp[k] = false;
            do{
                string str = "";
                for(int k = 0; k < orders[i].length(); k++)
                    if (temp[k] == false)
                        str += orders[i][k];
                dic[str]++;
            }while(next_permutation(temp.begin(), temp.end()));
        }
    }
```

`next_permutation`ìœ¼ë¡œ ì¡°í•©ì„ êµ¬í˜„í•˜ëŠ” ìì„¸í•œ ì„¤ëª…ì€ [ì´ í¬ìŠ¤íŠ¸ ì°¸ê³ ](https://ansohxxn.github.io/algorithm/combination/#stl-next_permutation%EC%9C%BC%EB%A1%9C-%EC%A1%B0%ED%95%A9-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0) (ì´ í¬ìŠ¤íŠ¸ì—ì„œ ë‚´ê°€ í•œ ë°©ë²•ì€ ì•„ë˜ ë°©ë²•ì´ë‹¤. ìˆœì„œëŒ€ë¡œ ì¡°í•©ë˜ë„ë¡ í•œ ê²ƒ.)

***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}