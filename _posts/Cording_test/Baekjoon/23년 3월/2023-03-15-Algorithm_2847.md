---
layout: single
title: "[백준 2847번] [🥈4] 게임을 만든 동준이 (python)"
categories: Baekjoon
tag: [python, Algorithm, Baekjoon, Greedy]
toc: true
---

**[백준 사이트 링크](<https://www.acmicpc.net/problem/2847>)**
{: .notice--primary}

### 문제

학교에서 그래픽스 수업을 들은 동준이는 수업시간에 들은 내용을 바탕으로 스마트폰 게임을 만들었다. 게임에는 총 N개의 레벨이 있고, 각 레벨을 클리어할 때 마다 점수가 주어진다. 플레이어의 점수는 레벨을 클리어하면서 얻은 점수의 합으로, 이 점수를 바탕으로 온라인 순위를 매긴다. 동준이는 레벨을 난이도 순으로 배치했다. 하지만, 실수로 쉬운 레벨이 어려운 레벨보다 점수를 많이 받는 경우를 만들었다.

이 문제를 해결하기 위해 동준이는 특정 레벨의 점수를 감소시키려고 한다. 이렇게해서 각 레벨을 클리어할 때 주는 점수가 증가하게 만들려고 한다.

각 레벨을 클리어할 때 얻는 점수가 주어졌을 때, 몇 번 감소시키면 되는지 구하는 프로그램을 작성하시오. 점수는 항상 양수이어야 하고, 1만큼 감소시키는 것이 1번이다. 항상 답이 존재하는 경우만 주어진다. 정답이 여러 가지인 경우에는 점수를 내리는 것을 최소한으로 하는 방법을 찾아야 한다.


### 입력

첫째 줄에 레벨의 수 N이 주어진다. (1 ≤ N ≤ 100) 다음 N개 줄에는 각 레벨을 클리어하면 얻는 점수가 첫 번째 레벨부터 마지막 레벨까지 순서대로 주어진다. 점수는 20,000보다 작은 양의 정수이다.

### 출력

첫째 줄에 점수를 몇 번 감소시키면 되는지 출력한다.

### 예제 입력 1

```
3
5
5
5
```

### 예제 출력 1

```
3
```

### 예제 입력 2

```
4
5
3
7
5
```

### 예제 출력 2

```
6
```

---


### 문제를 풀면서 막혔던 부분

뒤에 숫자부터 낮춰주어야 한다. 앞에서 부터 낮추게 되면, 다시 앞의 난이도가 뒤의 난이도보다 높아지는 경우가 발생하기 때문이다.

### 코드

##### ver(1)

```python
n = int(input())
k = []
for _ in range(n):
  k.append(int(input()))

c = 0
for i in range(n-1,0,-1):
  if k[i] <= k[i - 1]:
    c += (k[i - 1] - k[i] + 1)
    k[i - 1] = k[i] - 1
print(c)

```

##### ver(2)

```python
n = int(input())
p = list([int(input()) for i in range(n)])
p.reverse()
cnt = 0
for i in range(1,n):
    if p[i] >= p[i-1]:
        dif = p[i-1] - 1
        cnt += p[i] - dif
        p[i] = dif
        dif = 0
    
print(cnt)
```