---
title: "[Ad-Oracle-Sql] 3. Sub-Queries and Merge Statements"

categories:
  - Ad-Oracle-Sql
tags:
  - [Sub-Queries, Merge]

toc: true
toc_sticky: true

date: 2023-09-27
last_modified_at: 2023-09-27
---

{% capture notice-2 %}

ğŸ“‹ This is my note-taking from what I learned in the class "Advanced Database Concepts"
{% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div>

<!-- ğŸ“‹ This is my note-taking from what I learned in the LinkedIn Learning course "Explore a Career in SQL Development"
{: .notice--danger} -->

<br>

# Objective

- Determine when using a sub-query is appropriate
- Identify which clauses can contain sub-queries
- Distinguish between an outer query and a sub-query
- Use a single-row sub-query in a WHERE clause
- Use a single-row sub-query in a HAVING clause
- Use a single-row sub-query in a SELECT clause
- Distinguish between single-row and multiple-row comparison operators
- Use a multiple-row sub-query in a WHERE clause
- Use a multiple-row sub-query in a HAVING clause
- Use a multiple-column sub-query in a WHERE clause
- Create an inline view using a multiple-column sub-query in a FROM clause
- Compensate for NULL values in sub-queries
- Distinguish between correlated and uncorrelated sub-queries
- Nest a sub-query inside another sub-query
- Use a sub-query in a DML action
- Process multiple DML actions with a MERGE statement

<br>

# Sub-Queries and Their Uses

- Sub-query: A query nested inside another query
- Used when a query is based on an unknown value
- Requires SELECT and FROM clauses
- Must be enclosed in parentheses
- Place on right side of comparison operator

<br>

# Types of Sub-Queries

| Sub-Query                 | Description                                                                                              |
| :------------------------ | :------------------------------------------------------------------------------------------------------- |
| Single-row sub-query      | Returns to the outer query one row of results that consists of one column                                |
| Multiple-row sub-query    | Returns to the outer query more than one row of results                                                  |
| Multiple-column sub-query | Returns to the outer query more than one column of results                                               |
| Correlated sub-query      | References a column in the outer query, and executes the sub-query once for every row in the outer query |
| Uncorrelated sub-query    | Executes the sub-query first and passes the value to the outer query                                     |

<br>

# Single-Row Sub-Queries

- Can only return one result to the outer query
- Operators include `=`, `>`, `<`, `>=`, `<=`, `< >`

## Single-Row Sub-Query in a WHERE Clause

- Used for comparison against individual data

```
SELECT category, title, cost
  FROM books
  WHERE cost >
        (SELECT cost
        FROM books
        WHERE title = 'DATABASE IMPLEMENTATION')
    AND category = 'COMPUTER';
```

![img](../../assets/images/SingleRowSubQueryWhere.png)

## Single-Row Sub-Query in a HAVING Clause

- Required when returned value is compared to grouped data

```
SELECT category, AVG(retail-cost) "Average Profit"
  FROM books
  GROUP BY category
  HAVING AVG(retail-cost) > (SELECT AVG(retail-cost)
                              FROM books
                              WHERE category = 'LITERATURE');
```

![img](../../assets/images/SingleRowSubQueryHaving.png)

## Single-Row Sub-Query in a SELECT Clause

- Replicates sub-query value for each row displayed

```
SELECT title, retail
              (SELECT TO_CHAR(AVG(retail),999.99)
                FROM books) "Overall Average"
  FROM books;
```

![img](../../assets/images/SingleRowSubQuerySelect.png)

<br>

# Multiple-Row Sub-Queries

- Return more than one row of results
- Require use of IN, ANY, ALL, or EXISTS operators

## ANY and ALL Operators

- Combine with arithmetic operators

| Operator | Description                                               |
| :------- | :-------------------------------------------------------- |
| `>ALL`   | More than the highest value returned by the sub-query     |
| `<ALL`   | Less than the lowest value returned by the sub-query      |
| `<ANY`   | Less than the highest value returned by the sub-query     |
| `>ANY`   | More than the lowest value returned by the sub-query      |
| `=ANY`   | Equal to any value returned by the sub-query (same as IN) |

## Multiple-Row Sub-Query in a WHERE Clause

```
SELECT title, retail, category
  FROM books
  WHERE retail IN (SELECT MAX(retail)
                    FROM books
                    GROUP BY category)
  ORDER BY category;
```

![img](../../assets/images/MultipleRowSubQueryWhere.png)

```
SELECT title, retail
  FROM books
  WHERE retail <ANY (SELECT retail
                      FROM books
                      WHERE category = 'COOKING');
```

![img](../../assets/images/MultipleRowSubQueryWhere2.png)

## Multiple-Row Sub-Query in a HAVING Clause

```
SELECT order#, SUM(quantity*paideach)
  FROM orderitems
  HAVING SUM(quantity*paideach) >ALL (SELECT SUM(quantity*paideach)
                                      FROM customers JOIN orders USING (customer#)
                                        JOIN orderitems USING (order#)
                                      WHERE state = 'FL'
                                      GROUP BY order#)
  GROUP BY order#;
```

![img](../../assets/images/MultipleRowSubQueryHaving.png)

<br>

# Multiple-Column Sub-Queries

- Return more than one column in results
- Can return more than one row
- Column list on the left side of operator must be in parentheses
- Use the IN operator for WHERE and HAVING clauses

## Multiple-Column Sub-Query in a FROM Clause

- Creates a temporary table

```
SELECT b.title, b.retail, a.category, a.cataverage
  FROM books b, (SELECT category, AVG(retail) cataverage
                  FROM books
                  GROUP BY category) a
  WHERE b.category = a.category
    AND b.retail > a.cataverage;
```

![img](../../assets/images/MultipleColumnSubQueryFrom.png)

## Multiple-Column Sub-Query in a WHERE Clause

- Returns multiple columns for evaluation

```
SELECT title, retail, category
  FROM books
  WHERE (category, retail) IN (SELECT category, MAX(retail)
                                FROM books
                                GROUP BY category)
  ORDER BY category;
```

![img](../../assets/images/MultipleColumnSubQueryWhere.png)

## NULL Values

- When a sub-query might return NULL values, use NVL function

```
SELECT customer#
  FROM customers
  WHERE NVL(referred, 0) = (SELECT NVL(referred, 0)
                            FROM customers
                            WHERE customer# = 1005);
```

![img](../../assets/images/MultipleColumnSubQueryNull.png)

<br>

# Uncorrelated Sub-Queries

- Processing sequence
  : - Inner query is executed first
  : - Result is passed to outer query
  : - Outer query is executed

<br>

# Correlated Sub-Queries

- Inner query is executed once for each row processed by the outer query
- Inner query references the row contained in the outer query

```
SELECT title
  FROM books
  WHERE EXISTS (SELECT isbn
                FROM orderitems
                WHERE books.isbn = orderitems.isbn);
```

![img](../../assets/images/CorrelatedSubQuery.png)

<br>

# Nested Sub-Queries

- Maximum of 255 sub-queries if nested in the WHERE clause
- No limit if nested in the FROM clause
- Innermost sub-query is resolved first, then the next level, etc

- Innermost is resolved first(A), then the second level(B), then the outer query(C)

```
SELECT customer#, lastname, firstname
  FROM customers JOIN orders USING(customer#)
  WHERE order# IN (SELECT order#
                    FROM orderitems
                    GROUP BY order#
                    HAVING COUNT(*) = (SELECT MAX(COUNT(*))
                      FROM orderitems
                      GROUP BY order#));
```

![img](../../assets/images/NestedSubQuery.png)

<br>

# Sub-Query Factoring Clause

```
WITH dcount AS (
Â  SELECT deptno, COUNT(*) AS dcount
Â  FROMÂ Â  employees
Â  GROUP BY deptno)
SELECT e.lname Emp_Lastname,
Â Â Â Â Â Â  e.deptno e_dept,
Â Â Â Â Â Â  d1.dcount edept_count,
Â Â Â Â Â Â  m.lname manager_name,
Â Â Â Â Â Â  m.deptno mdept,
Â Â Â Â Â Â  d2.dcount mdept_count
FROMÂ Â  employees e,
Â Â Â Â Â Â  dcount d1,
Â Â Â Â Â Â  employees m,
Â Â Â Â Â Â  dcount d2
WHEREÂ  e.deptno = d1.deptno
ANDÂ Â Â  e.mgr = m.empno
ANDÂ Â Â  m.deptno = d2.deptno
Â Â Â  AND e.mgr = '7839';
```

<br>

# Sub-Query in a DML Action

```
UPDATE employees
  SET bonus = (SELECT AVG(bonus)
              FROM employees)
  WHERE empno = 8844;
```

![img](../../assets/images/SubQueryDmlAction.png)

<br>

# MERGE Statement

- With a MERGE statement, a series of DML actions can occur with a single SQL statement
- Conditionally updates one data source based on another

```
MERGE INTO books_1 a
  USING books_2 b
    ON (a.isbn = b.isbn)
  WHEN MATCHED THEN
    UPDATE SET a.retail = b.retail, a.category = b.category
  WHEN NOT MATCHED THEN
    INSERT (isbn, title, pubdate, retail, category)
      VALUES (b.isbn, b.title, b.pubdate, b.retail, b.category);

SELECT * FROM books_1;
```

![img](../../assets/images/MergeStatement.png)

- The following explains each part of the previous MERGE statement:
  : - MERGE INTO books_1 a: The BOOKS_1 table is to be changed and a table alias of â€œaâ€ is assigned to this table
  : - USING books_2 b: The BOOKS_2 table will provide the data to update and/or insert into BOOKS_1 and a table alias of â€œbâ€ is assigned to this table
  : - ON (a.isbn = b.isbn): The rows of the two tables will be joined or matched based on isbn
  : - WHEN MATCHED THEN: If a row match based on ISBN is discovered, execute the UPDATE action in this clause. The UPDATE action instructs the system to modify only two columns (Retail and Category)
  : - WHEN NOT MATCHED THEN: If no match is found based on the ISBN (a books exists in BOOKS_2 that is not in BOOKS_1), then perform the INSERT action in this clause

## MERGE with WHERE

```
MERGE INTO books_1 a
  USING books_2 b
    ON (a.isbn = b.isbn)
  WHEN MATCHED THEN
    UPDATE SET a.retail = b.retail, a.category = b.category
    WHERE b.category = 'COMPUTER'
  WHEN NOT MATCHED THEN
    INSERT (isbn, title, pubdate, retail, category)
      VALUES (b.isbn, b.title, b.pubdate, b.retail, b.category)
      WHERE b.category = 'COMPUTER';

SELECT * FROM books_1;
```

![img](../../assets/images/MergeWithWhere.png)

## MERGE with DELETE

```
MERGE INTO books_1 a
  USING books_2 b
    ON (a.isbn = b.isbn)
  WHEN MATCHED THEN
    UPDATE SET a.retail = b.retail, a.category = b.category
    DELETE WHERE (b.retail < 50);

SELECT * FROM books_1;
```

![img](../../assets/images/MergeWithDelete.png)

<br>

# Summary

<br>

---

<br>

    ğŸ–‹ï¸ This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts ğŸ˜†

[Back to Top](#){: .btn .btn--primary }{: .align-right}
