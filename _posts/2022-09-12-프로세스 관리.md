---
layout: single
title:  "프로세스 관리"
categories: cs
tag: 운영체제의 자원 관리
toc: true
toc_sticky: true
---

# 프로세스 관리

## 자원

자원이란 컴퓨터에서 사용될 수 있는 요소들로 하드웨어,소프트웨어,데이터 구성 요소들을 뜻한다 예시로는

#### 하드웨어 자원
1. 프린터
2. 디스크 
3. 메모리
4. 네트워크 자원

#### 소프트웨어 자원
1. 프로그램
2. 유틸리티
3. 프로그램 내의 구성요소

#### 데이터 자원
1. 파일
2. 데이터베이스

## 프로세스 (process)

프로세스란 실행되기 위해 주 기억 장치에 옮겨진 프로그램이다 

   자세히 설명하면 운영체제는 프로그램을 실행하기 위해 보조 장치에 저장되어 있는 프로그램을 주 기억 장치의 적절한 위치로 올리는데 이것이 프로세스이며 프로그램 코드뿐만 아니라 실행에 필요한 다양한 정보도 포함된다 

## 프로세스 제어 블록 (PCB : process contro block)

프로세스 제어 블록은 프로세스 각각에 대한 정보를 정리하는 테이블로 운영체제는 이를 통해 프로세스를 관리한다 

또한 PCB는 프로세스 생성 시 생성되고 종료 시 같이 사라진다

### PCB 저장되는 정보
1. 프로세스 상태 :  실행 상태인지 실행을 위한 준비 상태인지에 대한 정보 
2. 프로그램 카운터 값 :  다음에 실행될 명령어의 주 기억 장치 주소 
3. 스케줄링 정보 :  다음에 실행될 프로세스를 결정하는데 필요한 정보
4. 주 기억 장치 정보 : 해당 프로세스가 주 기억 장치 어디에 위치인지에 대한 정보

이외에도 프로세스 ID,레지스터 등의 정보를 포함한다


## 프로세스의 상태

프로세스는 생성되어 종료되어 종료할 때까지 생성,준비,대기,실행,종료 
5가지 상태가 있다

1. 준비 큐에서 이전 프로세스의 실행이 종료된 경우

    * 중앙 처리 장치에서 실행되고 있던 프로세스의 실행이 종료된 경우 운영체제가 준비 상태에 있는 프로세스 중 프로세스 스케줄링 정책에 따라 가장 먼저 실행될 프로세스가 시행 상태가 된다

2. 이전 프로세스가 중앙 처리 장치를 오래 차지하고 있는 경우

    * 프로세스가 중앙 처리 장치를 일정 시간 이상 차지하고 있는 경우 운영체제가 프로세스를 준비 상태가 되게 하고 가장 먼저 실행될 프로세스가 실행 상태가 된다

    * 이때 중앙 처리 장치의 일부 레지스터에 저장되어 있는 이전 프로세스의 정보와 새 프로세스 정보 일부를 중앙 처리의 레지스터에 저장하는 것을 문맥 전환 (context switch)라고 한다
    대표적으로 프로그램 카운터 값을 저장하고 있어야 프로세스가 다시 실행될 때 원하는 명령부터 실행된다

3. 실행 프로세스가 디스크 입출력 명령을 실행해야 하는 경우
    
    * 디스크 입출력 명력이 발생하면 입출력 동작이 완료될 동안 중앙 처리 장치가 멈추게 된다 이런 경우 운영체제가 해당 프로세스를 대기 큐로 보내고 가장 먼저 실행될 프로세스가 실행 상태가 된다 이때 이전 프로세스 상태를 대기 상태라고 하며 문맥 전환이 일어난다

## 프로세스의 생성 실행 및 준비

1. 생성
    * 운영체제가 다음에 실행할 새로운 프로세스 "가"를 주 기억 장치에 가져오면 A의 PCB가 준비 큐에 등록되고 이를 프로세스의 생성이라 한다
2. 실행
    * 운영체제는 준비 큐의 가장 앞에 위치한 PCB를 중앙 처리 장치가 실행할 수 있도록 한다 만약 "가"PCB가 가장 앞에 있다면 제어블록이 중앙 처리 장치 레지스터에 저장된다 그 후 프로세스 "가"는 수행되고 이를 프로세스의 실행이라 한다
3. 준비
    * 프로세스가 "가"가 실행되고 있는 상태에서 "나"와 "다"가 생성되면 "나","다"에 PCB는 준비큐에 연결되고 이를 프로세스의 준비라고 한다
    
<br>

# 프로세스 스케줄링

최근에는 대부분 여러 프로세스를 주 기억 장치에 적재하여 중앙 처리 장치 이용률은 최대화하는
다중프로그래밍 방식을 쓰기 때문에 준비 상태의 프로세스에 실행 순서를 결정하는 프로세스 스케줄링이 필요하다

그 종류로는 대표적으로 FCFS 스케줄링,라운드로빈 스케줄링, 우선순위 스케줄링 등이 있다

### FCFS 스케줄링

FCFS 스케줄링은 가장 먼저 도착한 프로세스를 먼저 실행하는 가장 간단한 정책이다
예를 들어 가,나,다 순으로 생성되면 우선 "가"에게 중앙 처리 장치를 배정하여 실행시키고
"나","다"는 "가"가 종료되어 자기 차례가 될 때 까지 준비 큐에서 기다린다

만약 중앙 처리 장치 시간이
* 가 15ms
* 나 10ms
* 다 5ms

라면 실행 순서는 가 -> 나 -> 다 이고 
평균 대기 시간은 (0+15+25)/3 = 13.333···ms가 된다

### 라운드 로빈 스케줄링

라운드 로빈 스케줄링은 여러 프로세스들이 중앙 처리 장치를 돌아가면 할당받아 실행하는 방식으로 대부분에 시스템에서 사용하는 방식이다 프로세스들은 시간 할당량동안 중앙처리장치를 할당받아 실행되며 시간 할당량안에 종료하지 못하면 준비상태로 전환되고 다음 차례 프로세스가 실행된다

만약 시간 할당량이 5ms일 때 중앙 처리 장치 시간이
* 가 15ms
* 나 10ms
* 다 5ms

라면 평균 대기 시간은 (15+15+10)/3 = 13.333···ms가 된다

### 우선순위 스케줄링

우선순위 스케줄링은 말 그대로 가장 높은 우선순위의 프로세스에게 먼저 중앙 처리 장치를 할당하는 방법이다 여기서 우선순위는 PCB에 저장된다

만약 장치 시간과 우선순위가
* 가 15ms 3
* 나 10ms 2
* 다 5ms 1

라면 실행 순서는 다 -> 나 -> 가 이고
평균 대기 시간은 (0+5+15)/3 = 6.666···ms가 된다


# 교착 상태

교착 상태란 두 개 이상의 작업이 다음 진행되어야 할 작업과 맞물려서 서로 상대방 작업이 끝날 때까지만 기다리느라 아무것도 완료되지 않는 상태이다

ex) 프로세스 "가"가 프린트 자원을 점유하고 있고 "나"가 디스크 자원을 점유하고 있을 때 
"가"는 디스크 자원을 요청하고 "나"는 프린트 자원을 요청하면 각 자원들이 사용 중이므로 무한하게 대기하게 된다

## 교착 상태 발생 조건
1. 상호 배제 : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다
2. 점유 대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다
3. 비선점 : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다
4. 순환 대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다

위와 같은 4가지 조건을 모두 만족해야만 교착이 일어난다

## 교착 상태 관리

현재 대부분의 운영체제들은 교착 상태를 막는 것이 불가능하여 예방하거나 회피,무시,발견하는 방법으로 교착을 관리한다

## 교착 상태의 예방
* 상호배제 조건의 제거 : 교착은 두 가지 이상의 프로세스가 공유 가능한 자원을 사용할 때 때문에 생기니 공유 불가능한, 즉 상호 배제 조건을 제거한다

* 점유와 대기 조건의 제거 : 작업을 수행하기 전 각 프로세스가 요구하는 모든 자원을 요청하여
획득하거나 자원을 전혀 가지고 있지 않을 때만 자원을 요청할 수 있게 한다 
(자원과다 효율성,프로세스 요구 자원 파악 비용, 자원에 대해 내용 저장 및 복원 비용, 기아상태, 무한 대기 등 문제점 있음)

* 비선점 조건의 제거 : 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어준다

* 환영 대기 조건의 제거 : 자원의 종류에 일련의 순서를 부여하여 각 프로세스는 증가하는
순서로만 자원을 요청하게 한다

## 교착 상태의 회피

자원이 어떻게 요청될지 추가 정보를 요구하여 회피가 가능하며, 시스템에 순환 대기가 발생하지 않도록 자원 할당 상태를 검사한다 교착 상태 회피를 위한 알고리즘은
* 자원 할당 그래프 알고리즘
* 은행원 알고리즘

이 있다

## 교착 상태의 무시

예방 또는 회피를 할 수 있으나 성능에 큰 영향을 미칠 수 있으니 교착 발생 확률이 낮은 경우 별다른 조치를 취하지 않고 무시한다

## 교착 상태의 발견

감시,발견 하는 검출 알고리즘으로 교착 발생을 체크하는 방식으로 이 역시도 성능에 큰 영향을 미칠 수 있다