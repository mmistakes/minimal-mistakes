---
title:  "javascript-14: ìƒì†/property "
layout: single
categories : js
tag: [coding, javascript, github, jekyll, blog, html]
toc: true
toc_sticky: true
author_profile: false
---

# Promise  

- Promise is a JavaScript object for asynchronous operation.
- State: pormiseê°€ ë§Œë“¤ì–´ì ¸ì„œ ì§€ì •í•œ ì‘ì—…ì´ ìˆ˜í–‰ì¤‘ì¼ë•Œ pending â†’ ì™„ë£Œë˜ë©´ fullfilled / ì—ëŸ¬ê°€ ë‚  ê²½ìš°:rejected
- Producer(ë°ì´í„°ë§Œë“¤ì–´ë‚´ëŠ”) vs Consumer(ë°ì´í„°ë¥¼ ì†Œë¹„í•˜ëŠ”)

### 1. Producer
- when new Promise is created, the executor runs automatically.
  (ìƒˆë¡œìš´ promiseê°€ ë§Œë“¤ì–´ì§€ë©´ excutorëŠ” ë°”ë¡œ ì‹¤í–‰ì´ë¨)
  
```js
const promise = new Promise((resolve, reject) => {
  // doing some heavy work (network, read files)
  console.log('doing something...');
  setTimeout(() => {
    resolve('ellie');
    // reject(new Error('no network'));
  }, 2000);
});
```

![image](https://user-images.githubusercontent.com/111720411/197516829-f1fd89b1-9911-4728-b8f2-28ddc7abed12.png)

\* promiseì•ˆì— ë„¤íŠ¸ì›Œí¬í†µì‹ í•˜ëŠ” ì½”ë“œë¥¼ ë§Œë“¤ì—ˆë‹¤ë©´ promiseê°€ ë§Œë“¤ì–´ì§€ëŠ” ìˆœê°„ ë„¤íŠ¸ì›Œí¬ í†µì‹  ìˆ˜í–‰

### 2. Consumers: then, catch, finally
promise //
  .then(value => {
    console.log(value);
  })
  .catch(error => {
    console.log(error);
  })
  .finally(() => {
    console.log('finally');
  });

![image](https://user-images.githubusercontent.com/111720411/197517593-363804c0-bc35-4403-9c38-5a33aed4ae52.png)


### 1.promise chainning

#### 1-1 ì˜ˆì œ1
```js
const fetchNumber = new Promise((resolve, reject) => {
  setTimeout(() => resolve(1), 1000);
});

fetchNumber
  .then(num => num * 2)
  .then(num => num * 3)
  .then(num => {
    return new Promise((resolve, reject) => {
      setTimeout(() => resolve(num - 1), 1000);
    });
  })
  .then(num => console.log(num));
```

![image](https://user-images.githubusercontent.com/111720411/197517917-9394fd14-1051-4c3b-b7ab-c48ea72acd22.png)


#### 1-2 ì˜ˆì œ2
```js
const f1 = () => {
  return new Promise((res, rej) => {
    setTimeout(() => {
      res("1ë²ˆ ì£¼ë¬¸ ì™„ë£Œ");
    }, 1000);
  })
};
const f2 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(() => {
      res("2ë²ˆ ì£¼ë¬¸ ì™„ë£Œ");
    }, 1000);
  })
};

const f3 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(() => {
      res("3ë²ˆ ì£¼ë¬¸ ì™„ë£Œ");
    }, 1000);
  })
};
console.log('ì‹œì‘');
f1()
.then(res => f2(res))
.then(res => f3(res))
.then(res => console.log(res));
``` 

![image](https://user-images.githubusercontent.com/111720411/197479861-f7f3b807-a195-481a-9823-ac8b503327f3.png)

### 2.promise all(í”„ë¡œë¯¸ìŠ¤ë¥¼ ë³‘ë ¬ë¡œ ì‚¬ìš©/ ë°°ì—´ ê°’)

```js
console.time("x")
Promise.all([f1(), f2(), f3()]).then((res) => {
  console.log(res);
  console.timeEnd("x");
});
```

![image](https://user-images.githubusercontent.com/111720411/197480026-7917bafc-9c84-4e41-a582-de462f38e55f.png)


\* console.time("x") ~ console.timeEnd("x")  = ì‹œê°„ ì¬ê¸°


### 3. promise race (ì œì¼ ë¹¨ë¦¬ ëë‚˜ëŠ” ê°’ë§Œ ë„ì¶œí•¨)

```js
console.time("x")
Promise.race([f1(), f2(), f3()]).then((res) => {
  console.log(res);
  console.timeEnd("x");
});
```

![image](https://user-images.githubusercontent.com/111720411/197480166-2e256d54-73b0-4ce9-a733-87d68b7bb76a.png)

### 4. Error Handling

``js
const getHen = () =>
  new Promise((resolve, reject) => {
    setTimeout(() => resolve('ğŸ“'), 1000);
  });
const getEgg = hen =>
  new Promise((resolve, reject) => {
    setTimeout(() => resolve((`${hen} => ğŸ¥š`)), 1000);
  });
const cook = egg =>
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(`${egg} => ğŸ³`), 1000);
  });


getHen()
  .then(hen => getEgg(hen))
  .then(egg => cook(egg))
  .then(meal => console.log(meal));
```

![image](https://user-images.githubusercontent.com/111720411/197519312-4125d46f-5bd0-493a-b16f-74a05678a4c3.png)

â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“rejectâ†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“

```js
const getHen = () =>
  new Promise((resolve, reject) => {
    setTimeout(() => resolve('ğŸ“'), 1000);
  });
const getEgg = hen =>
  new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error(`error! ${hen} => ğŸ¥š`)), 1000);
  });
const cook = egg =>
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(`${egg} => ğŸ³`), 1000);
  });

getHen() //
  .then(getEgg)
  .then(cook)
  .then(console.log)
  .catch(console.log);
```

![image](https://user-images.githubusercontent.com/111720411/197519239-2c5de77c-b003-42f7-80d5-adbc32254032.png)
