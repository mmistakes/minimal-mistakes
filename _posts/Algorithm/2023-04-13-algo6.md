---
title: "Javascript 코딩테스트 - 지뢰찾기"
categories:
  - Algorithm

tags:
  - [Algorithm]

toc: true
toc_sticky: true

author_profile: true
date: 2023-04-1４
---

#### Javascript 코딩테스트 - 지뢰찾기

<br>

##### 출처 : 향해99

<br>

##### 문제 설명

windows에서 지원하는 지뢰 찾기 게임을 한번쯤은 해 보았을 것이다.
특히 르탄이는 지뢰찾기의 매니아로 알려져 있다. 지뢰 찾기 map은 N\*N의 정사각형 모양으로 각 칸에는 숫자가 들어가 있거나 지뢰가 들어가 있다. 빈 칸에는 숫자 0이 들어있다고 생각하자.

map의 어떤 칸에 적혀 있는 숫자는, 그 칸과 인접해 있는 여덟 개의 칸 중에서 지뢰가 들어 있는 칸이 몇 개인지를 나타내 준다. 물론 인접한 칸이 map 내부에 있는 경우에 대해서만 생각하면 된다. 예제를 보면 더 잘 이해할 수 있을 것이다.

이번 문제는 조금 업그레이드 된 지뢰 찾기로, 한 칸에 한 개의 지뢰가 있는 것이 아니고, 한 칸에 여러 개(1 이상 9 이하)의 지뢰가 묻혀 있는 게임이다. 따라서 map의 어떤 칸에 적혀 있는 숫자는, 그 칸과 인접해 있는 여덟 개의 칸들에 들어 있는 지뢰의 총 개수가 된다.

이미 windows 지뢰찾기 같은 것을 마스터한 르탄이는, map에서 지뢰에 대한 정보만이 주어졌을 때, 르탄이는 map을 완성하고 싶다고 한다. N과 지뢰의 위치가 주어졌을 때, 르탄이를 도와서 지뢰 찾기 map을 완성하는 프로그램을 작성하시오.

##### 제한 조건

단, 1 ≤ N ≤ 1,000 이며, 배열의 각 요소에는 지뢰 찾기 map에 대한 정보가 주어지는데 '.' 또는 숫자로 이루어진 문자열이 들어온다. '.'는 지뢰가 없는 것이고 숫자는 지뢰가 있는 경우로 그 칸의 지뢰의 개수이다. 한 줄은 N개의 문자로 이루어져 있다.

##### 입출력 예

- 입력 - N = 5 - arr1 = [
  ["1", ".", ".", ".", "."],
  [".", ".", "3", ".", "."],
  [".", ".", ".", ".", "."],
  [".", "4", ".", ".", "."],
  [".", ".", ".", "9", "."],
  ];
  <br>
- 출력
  - [
    [ '*', 4, 3, 3, 0 ],
    [ 1, 4, '*', 3, 0 ],
    [ 4, 7, 7, 3, 0 ],
    [ 4, '*', 'M', 9, 9 ],
    [ 4, 4, 'M', '*', 9 ]
    ]

##### 입출력 예 설명

N개의 줄에 걸쳐서 완성된 지뢰 찾기 map을 출력한다. 지뢰는( _ )로 출력하며. 10 이상인 경우는 'M'(Many)으로 출력하면 된다. map은 숫자 또는 'M' 또는( _ )로만 이루어져 있어야 한다.

##### 풀이

```jsx
function solution(N, arr1) {
  // '.'의 주위의 좌표로 이동할 수 있게끔 x축, y축 선언
  let x = [1, -1, 0, 0, 1, 1, -1, -1];
  let y = [0, 0, 1, -1, 1, -1, 1, -1];

  // 이차원 배열 설정
  let answerArr = new Array(N);
  for (let i = 0; i < answerArr.length; i++) {
    answerArr[i] = new Array(N);
  }

  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      // 이차원 배열의 요소가 마침표가 아니라 숫자이면
      if (arr1[i][j] !== ".") {
        // 지뢰를 이차원 배열의 요소[i]의 요소[j]에 넣음
        answerArr[i][j] = "*";
        // continue를 넣음으로써 밑의 코드를 건너뛴 후 for문을 반복한다
        continue;
      }
      let mineCnt = 0;
      // 0 <= i+x[k] < N 과 0 <= i + y[k] < N으로 설정하는 이유는
      // 이동한 좌표가 요소의 인덱스를 벗어나는 경우가 발생하기 때문에
      // 논리곱 연산자를 이용하여 조건을 설정하여야 한다
      for (let k = 0; k < 8; k++) {
        if (
          i[0] + x[1] >= 0 &&
          i[0] + x[1] < N &&
          j + y[k] >= 0 &&
          j + y[k] < N &&
          arr1[i + x[k]][j + y[k]] !== "."
        ) {
          // 좌표를 이동했을떄 숫자이면 mineCnt에 누적 할당
          mineCnt += Number(arr1[i + x[k]][j + y[k]]);
        }
      }
      // 2차원 배열에 mineCnt의 값이 10보다크면 M을 입력, 작다면 mineCnt값을 입력
      answerArr[i][j] = mineCnt >= 10 ? "M" : mineCnt;
    }
  }

  return answerArr;
}
```

- 문제를 이해하는 과정부터 어려웠던 문제이다. 지금까지 배운 지식으로는 x,y를 이용하여 좌표를 이동한다라는 생각을 전혀 하지 못해서 많이 헤맸던 문제였다. 팀원들과 기술 매니저님의 설명을 듣고 인덱스는 0부터 존재하여야 하는데 -인 상황이 발생하면 안되게 조건식을 설정해줘야 한다는 것을 깨달았다. 다음에 이런 유형의 문제가 나온다면 적용할 수 있도록 숙지해야겠다.
