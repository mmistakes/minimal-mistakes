---
title: "[Arrays] Sort Array By Parity"

categories:
  - Arrays
tags:
  - [Sort]

toc: true
toc_sticky: true

date: 2023-05-06
last_modified_at: 2023-05-08
---

<!-- {% capture notice-2 %}

ğŸ“‹ This is the tech-news archives to help me keep track of what I am interested in!

- Reference tech news link: <https://thenextweb.com/news/blockchain-development-tech-career>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div> -->

ğŸ“‹ This is my note-taking from what I learned in LeetCode!
{: .notice--danger}

<br>

# Problem

[Problem Link](https://leetcode.com/explore/learn/card/fun-with-arrays/511/in-place-operations/3260/)

Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

Example 1:

- Input: nums = [3,1,2,4]
- Output: [2,4,3,1]
- Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.

Example 2:

- Input: nums = [0]
- Output: [0]

Constraints:

1 <= nums.length <= 5000
0 <= nums[i] <= 5000

<br>

# Solution

[Solution Link](https://leetcode.com/problems/sort-array-by-parity/editorial/)

## Approach 1: Sort

Use a custom comparator when sorting, to sort by parity.

Algorithm:

1. Sort the input list "nums" based on the remainder of each element when divided by 2. The key function used for sorting is a lambda function that returns the result of x%2 for each element x in the list.
2. Return the sorted list as the output. The sorted list will have all the even numbers first, followed by all the odd numbers.

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    nums.sort(key=lambda x: x % 2)
    return nums

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

> ì½”ë“œ ì„¤ëª…
>
> - ëŒë‹¤(lambda) í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ë¦¬ìŠ¤íŠ¸ ë‚´ì˜ ê°’ì„ 2ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ ê°’ì„ êµ¬í•©ë‹ˆë‹¤.
> - sortë¥¼ ì‚¬ìš©í•´ ë‚˜ë¨¸ì§€ ê°’ë“¤ì„ ì •ë ¬í•©ë‹ˆë‹¤.
> - ë”°ë¼ì„œ í•´ë‹¹ nums ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•˜ë©´, ì§ìˆ˜ê°€ ë¨¼ì € ì˜¤ê³  í™€ìˆ˜ê°€ ë‚˜ì¤‘ì— ì˜¤ëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

Complexity Analysis

- Time Complexity: O(Nlogâ¡N), where N is the length of A.
- Space Complexity: O(N) for the sort, depending on the built-in implementation of sort.

<br>

## Approach 2: Two Pass

Algorithm:

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    return [x for x in nums if x % 2 == 0] + [x for x in nums if x % 2 == 1]

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

> ì½”ë“œ ì„¤ëª…
>
> - 2ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ê°€ 0ì¸ ì§ìˆ˜ ê°’ë“¤ì„ êµ¬í•˜ê³ , ë‚˜ë¨¸ì§€ê°€ 1ì¸ í™€ìˆ˜ ê°’ë“¤ì„ êµ¬í•©ë‹ˆë‹¤.
> - ì§ìˆ˜ ë¦¬ìŠ¤íŠ¸ì™€ í™€ìˆ˜ ë¦¬ìŠ¤íŠ¸ë¥¼ + ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ì–´ ë¶™ì¸ í›„ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

Complexity Analysis

- Time Complexity: O(N), where N is the length of A.
- Space Complexity: O(N), the space used by the answer.

<br>

## Approach 3: In-Place

If we want to do the sort in-place, we can use quicksort, a standard textbook algorithm.

Algorithm:

We'll maintain two pointers i and j. The loop invariant is everything below i has parity 0 (ie. A[k] % 2 == 0 when k < i), and everything above j has parity 1.

Then, there are 4 cases for (A[i] % 2, A[j] % 2):

- If it is (0, 1), then everything is correct: i++ and j--.
- If it is (1, 0), we swap them so they are correct, then continue.
- If it is (0, 0), only the i place is correct, so we i++ and continue.
- If it is (1, 1), only the j place is correct, so we j-- and continue.

Throughout all 4 cases, the loop invariant is maintained, and j-i is getting smaller. So eventually we will be done with the array sorted as desired.

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    i, j = 0, len(nums) - 1
    while i < j:
        if nums[i] % 2 > nums[j] % 2:
            nums[i], nums[j] = nums[j], nums[i]
        if nums[i] % 2 == 0:
            i += 1
        if nums[j] % 2 == 1:
            j -= 1
    return nums

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

> ì½”ë“œ ì„¤ëª…
>
> - Two Pointers ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
> - í•˜ë‚˜ì˜ í¬ì¸í„°ëŠ” ì™¼ìª½ ëì—ì„œ ì‹œì‘í•˜ê³  ë‹¤ë¥¸ í•˜ë‚˜ì˜ í¬ì¸í„°ëŠ” ì˜¤ë¥¸ìª½ ëì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤.
> - í¬ì¸í„° iì™€ jë¥¼ ê°ê° ë¦¬ìŠ¤íŠ¸ì˜ ì™¼ìª½ ëê³¼ ì˜¤ë¥¸ìª½ ëì— ìœ„ì¹˜ì‹œí‚µë‹ˆë‹¤.
> - ë§Œì•½ nums[i]ê°€ í™€ìˆ˜ì´ê³  nums[j]ê°€ ì§ìˆ˜ì´ë©´, ë‘ ê°’ì˜ ìœ„ì¹˜ë¥¼ ì„œë¡œ ë°”ê¿‰ë‹ˆë‹¤.
> - ë§Œì•½ nums[i]ê°€ ì§ìˆ˜ì´ë©´, ië¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤.
> - ë§Œì•½ nums[j]ê°€ í™€ìˆ˜ì´ë©´, jë¥¼ ê°ì†Œì‹œí‚µë‹ˆë‹¤.
> - ì´ë ‡ê²Œ í•˜ë©´, iì™€ jê°€ êµì°¨í•˜ëŠ” ì‹œì ì—ëŠ” ëª¨ë“  ì§ìˆ˜ê°€ ë¦¬ìŠ¤íŠ¸ì˜ ì™¼ìª½ì— ëª¨ì´ê³ , ëª¨ë“  í™€ìˆ˜ê°€ ë¦¬ìŠ¤íŠ¸ì˜ ì˜¤ë¥¸ìª½ì— ëª¨ì´ê²Œ ë©ë‹ˆë‹¤.
> - ê·¸ë¦¬ê³  ê·¸ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

Complexity Analysis

- Time Complexity: O(N), where N is the length of A. Each step of the while loop makes j-i decrease by at least one. (Note that while quicksort is O(Nlogâ¡N) normally, this is O(N) because we only need one pass to sort the elements.)
- Space Complexity: O(1) in additional space complexity.

<br>

---

<br>

    ğŸ–‹ï¸ This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts ğŸ˜†

[Back to Top](#){: .btn .btn--primary }{: .align-right}
