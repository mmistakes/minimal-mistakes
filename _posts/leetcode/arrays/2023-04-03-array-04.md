---
title: "[Arrays] Duplicate Zeros"

categories:
  - Arrays
tags:
  - [Duplicate]

toc: true
toc_sticky: true

date: 2023-04-03
last_modified_at: 2023-04-03
---

<!-- {% capture notice-2 %}

üìã This is the tech-news archives to help me keep track of what I am interested in!

- Reference tech news link: <https://thenextweb.com/news/blockchain-development-tech-career>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div> -->

üìã This is my note-taking from what I learned in LeetCode!
{: .notice--danger}

# Problem

Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right.

Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.
{: .notice--info}

> Example 1:
>
> - Input: arr = [1,0,2,3,0,4,5,0]
> - Output: [1,0,0,2,3,0,0,4]
> - Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]

> Example 2:
>
> - Input: arr = [1,2,3]
> - Output: [1,2,3]
> - Explanation: After calling your function, the input array is modified to: [1,2,3]

Constraints:

- 1 <= arr.length <= 10<sup>4</sup>
- 0 <= arr[i] <= 9

{% capture notice-2 %}

Hints!

1. This is a great introductory problem for understanding and working with the concept of in-place operations. The problem statement clearly states that we are to modify the array in-place. That does not mean we cannot use another array. We just don't have to return anything.
2. A better way to solve this would be without using additional space. The only reason the problem statement allows you to make modifications in place is that it hints at avoiding any additional memory.
3. The main problem with not using additional memory is that we might override elements due to the zero duplication requirement of the problem statement. How do we get around that?
4. If we had enough space available, we would be able to accommodate all the elements properly. The new length would be the original length of the array plus the number of zeros. Can we use this information somehow to solve the problem?
   {% endcapture %}

<div class="notice--info">{{ notice-2 | markdownify }}</div>

<br>

# Solution

The problem requires that we modify the input array in place, which means we can't create a separate output array to hold the modified elements. If creating a separate output array was allowed, we could simply copy each element from the source array to the output array, duplicating any zeroes we encounter.

However, since we must modify the input array in place, we need to be a bit more careful with how we handle zeroes. In particular, if we encounter a zero, we need to "shift" the remaining elements of the array to make room for the additional zero.

To do this, we'll start by iterating over the array to determine how many zeroes we need to duplicate. We'll then iterate over the array again, this time starting from the end, and copy each element to its new position, making sure to duplicate any zeroes we encounter and shifting the remaining elements as needed.

![1](../../../assets/images/1089_Duplicate_Zeros_1.png)

```
int s = 0;
int d = 0;

// Copy is performed until the destination array is full.
for (s = 0; s < N; s++) {
  if (source[s] == 0) {
    // Copy zero twice.
    destination[d] = 0;
    d++;
    destination[d] = 0;
  }
  else {
    destination[d] = source[s];
  }
  d++;
}
```

The problem wants us to modify the input array instead of creating a new one. We can't add new elements to the array, we can only replace the existing elements. We also need to make sure that the final length of the modified array is the same as the original array. Therefore, we need to remove any extra elements that may exist in the modified array after all the required duplications have been performed.

![2](../../../assets/images/1089_Duplicate_Zeros_2.png)

The problem constraint requires us to modify the input array in-place without using any extra space. This means that we can't simply copy the elements from the input array to a separate output array, as doing so would require extra space. We need to come up with a way to modify the input array directly.

![3](../../../assets/images/1089_Duplicate_Zeros_3.png)

In the approach below, we start copying elements from the end of the array since we know that these elements won't be overwritten, and we can use the remaining space in the array to duplicate any zeros.

This way, we can avoid losing any elements from the original array and satisfy the problem constraint of not using any extra space.

## Approach: Two pass, O(1) space

To modify the original array in place, we need to ensure that we don't overwrite any elements of the array before we have used them. To do this, we can start copying elements from the end of the array, where there is guaranteed to be extra space for the new elements.

To determine how many elements from the original array will be part of the final array, we can count the number of extra zeros that will be added to the array. Each extra zero will create space for itself by pushing out an element from the end of the array. Once we know how many elements from the original array will be part of the final array, we can just start copying from the end.

Algorithm:

1. To modify the given array in-place without using extra space, we need to find the number of zeros that should be duplicated in the array. Let's call this count "possibleDups". However, we should not count the zeros that will be trimmed off from the end of the array, as they won't be part of the final array. The possibleDups count will tell us how many elements to trim off the original array. Therefore, at any point in the algorithm, length\_-possibleDups is the number of elements that will be included in the final array. We can start copying from the end of the array to ensure that we don't overwrite any element that we need to keep.
   : ![4](../../../assets/images/1089_Duplicate_Zeros_4.png)
   : > Note: In the diagram above we just show source and destination array for understanding purpose. We will be doing these operations only on one array.
2. In the edge case, we need to handle the scenario when there is a zero present at the boundary of the leftover elements. If we try to duplicate this zero, we will exceed the original array size, so we just copy it once without duplication. To handle this, we check if the left pointer is pointing to the last element that could be included in the final array, i.e., length\_-possible_dups. If yes, we copy the zero once and decrement the length\* variable.
   : > An example of the edge case is - [8,4,5,0,0,0,0,7]. In this array there is space to accommodate the duplicates of first and second occurrences of zero. But we don't have enough space for the duplicate of the third occurrence of zero. Hence when we are copying we need to make sure for the third occurrence we don't copy twice. Result = [8,4,5,0,0,0,0,0]
3. To modify the array in-place, we need to start iterating from the end of the array. For each element, if it is zero, we need to duplicate it twice by shifting the array to the right and inserting the zero twice. If it is non-zero, we simply insert it once. We continue iterating until we reach the beginning of the array. This way, we make sure that we are not overwriting any elements that we still need to modify, and we are able to modify the array in-place. To handle the possible duplicates, we first need to find the number of zeros in the original array. We then iterate through the array to find out how many zeros we can duplicate without overwriting any elements. Once we have the count of possible duplicates, we can start iterating from the end of the array and insert the zeros twice and non-zeros once. We need to be careful when handling the edge case of a zero on the boundary, as it might be part of the possible duplicates or not. Finally, we shift the elements to the right to make space for the duplicated zeros.

![5](../../../assets/images/1089_Duplicate_Zeros_5.png)

{% capture notice-2 %}

Complexity Analysis

- Time Complexity: O(N), where N is the number of elements in the array. We iterate through the array twice, once to find the number of possible duplicates and once to copy the elements. In the worst case scenario, we would iterate the entire array.
- Space Complexity: O(1). We do not use any extra space besides the original array itself, so the space complexity is constant.
  {% endcapture %}

<div class="notice--info">{{ notice-2 | markdownify }}</div>

```
using System;

namespace duplicate_zeros
{
  class Program
  {
    static void Main(string[] args)
    {
      int[] arr = { 1, 0, 2, 3, 0, 4, 5, 0 };
      DuplicateZeros(arr);
      Console.WriteLine(string.Join(", ", arr)); // Output: 1, 0, 0, 2, 3, 0, 0, 4
    }

    static void DuplicateZeros(int[] arr)
    {
      // Create a copy of the original array
      int[] copyArr = new int[arr.Length];
      Array.Copy(arr, copyArr, arr.Length);

      int j = 0;

      // Iterate through the original array
      for (int i = 0; i < arr.Length; i++)
      {
        // If the current element is zero, insert two zeros into the new array
        if (copyArr[j] == 0)
        {
          arr[i] = 0;
          if (i < arr.Length - 1)
          {
              arr[i + 1] = 0;
          }
          i++;
        }
        // If the current element is not zero, copy it to the new array
        else
        {
          arr[i] = copyArr[j];
        }
        j++;
      }
    }
  }
}
```

<br>

# Explanation

## Main Method

```
static void Main(string[] args)
{
  int[] arr = { 1, 0, 2, 3, 0, 4, 5, 0 };
  DuplicateZeros(arr);
  Console.WriteLine(string.Join(", ", arr)); // Output: 1, 0, 0, 2, 3, 0, 0, 4
}
```

- int[] arr = { 1, 0, 2, 3, 0, 4, 5, 0 };
  : - This line declares and initializes an integer array called "arr" with the given values.
- DuplicateZeros(arr);
  : - This line calls the DuplicateZeros method, passing in the "arr" array as an argument.
- Console.WriteLine(string.Join(", ", arr));
  : - This line outputs the contents of the "arr" array to the console, separated by commas.

## DuplicateZeros Method

```
static void DuplicateZeros(int[] arr)
{
  // Create a copy of the original array
  int[] copyArr = new int[arr.Length];
  Array.Copy(arr, copyArr, arr.Length);

  int j = 0;

  // Iterate through the original array
  for (int i = 0; i < arr.Length; i++)
  {
    // If the current element is zero, insert two zeros into the new array
    if (copyArr[j] == 0)
    {
      arr[i] = 0;
      if (i < arr.Length - 1)
      {
          arr[i + 1] = 0;
      }
      i++;
    }
    // If the current element is not zero, copy it to the new array
    else
    {
      arr[i] = copyArr[j];
    }
    j++;
  }
}
```

- static void DuplicateZeros(int[] arr)
  : - This line declares a new static method called "DuplicateZeros" that takes an integer array called "arr" as a parameter.
- int[] copyArr = new int[arr.Length];
  : - This line declares and initializes a new integer array called "copyArr" with the same length as the "arr" array.
- Array.Copy(arr, copyArr, arr.Length);
  : - This line copies the contents of the "arr" array to the "copyArr" array.
- int j = 0;
  : - This line declares and initializes an integer variable called "j" to zero.
- for (int i = 0; i < arr.Length; i++)
  : - This line starts a loop that will iterate over each element in the "arr" array.
- if (copyArr[j] == 0)
  : - This line checks if the current element in the "copyArr" array is equal to zero.
- arr[i] = 0;
  : - This line sets the current element in the "arr" array to zero.
- if (i < arr.Length - 1)
  : - This line checks if there is another element in the "arr" array after the current element.
- arr[i + 1] = 0;
  : - This line sets the next element in the "arr" array to zero.
- i++;
  : - This line increments the loop counter by one, skipping over the next element in the "arr" array.
- arr[i] = copyArr[j];
  : - This line sets the current element in the "arr" array to the current element in the "copyArr" array.
- j++;
  : - This line increments the index of the "copyArr" array that is being accessed.

<br>

# For better understanding

## Array.Copy(arr, copyArr, arr.Length);

This line of code creates a copy of the original array arr and stores it in a new array copyArr. It uses the static Copy method of the Array class, which takes three arguments: the source array (arr), the destination array (copyArr), and the length of the array to be copied (arr.Length in this case).

The Copy method copies the elements of the source array to the destination array, starting from index 0 and ending at the specified length. After this line of code executes, copyArr will have the same elements as arr, in the same order.

This line of code is used in the DuplicateZeros method to create a copy of the original array, so that the original array can be modified without affecting the copy. This is necessary because the method inserts additional zeros into the array, which changes its length and can cause errors if the original array is modified directly.

<br>

---

<br>

    üñãÔ∏è This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts üòÜ

[Back to Top](#){: .btn .btn--primary }{: .align-right}
