---
title: "[Arrays] Valid Mountain Array"

categories:
  - Arrays
tags:
  - [Mountain Array]

toc: true
toc_sticky: true

date: 2023-04-25
last_modified_at: 2023-04-25
---

<!-- {% capture notice-2 %}

ğŸ“‹ This is the tech-news archives to help me keep track of what I am interested in!

- Reference tech news link: <https://thenextweb.com/news/blockchain-development-tech-career>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div> -->

ğŸ“‹ This is my note-taking from what I learned in LeetCode!
{: .notice--danger}

<br>

# Problem

[Problem Link](https://leetcode.com/explore/learn/card/fun-with-arrays/527/searching-for-items-in-an-array/3251/)

Given an array of integers arr, return true if and only if it is a valid mountain array.

Recall that arr is a mountain array if and only if:

- arr.length >= 3
- There exists some i with 0 < i < arr.length - 1 such that:
  : - arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
  : - arr[i] > arr[i + 1] > ... > arr[arr.length - 1]

![Image](https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png)

Example 1:

- Input: arr = [2,1]
- Output: false

Example 2:

- Input: arr = [3,5,5]
- Output: false

Example 3:

- Input: arr = [0,3,2,1]
- Output: true

Constraints:

- 1 <= arr.length <= 10^4
- 0 <= arr[i] <= 10^4

Hint #1:

It's very easy to keep track of a monotonically increasing or decreasing ordering of elements. You just need to be able to determine the start of the valley in the mountain and from that point onwards, it should be a valley i.e. no mini-hills after that. Use this information in regards to the values in the array and you will be able to come up with a straightforward solution.

<br>

# Solution

[Solution Link](https://leetcode.com/problems/valid-mountain-array/editorial/)

## Approach 1: One Pass

If we walk along the mountain from left to right, we have to move strictly up, then strictly down.

Algorithm:

1. Let's walk up from left to right until we can't: that has to be the peak.
2. We should ensure the peak is not the first or last element.
3. Then, we walk down.
4. If we reach the end, the array is valid, otherwise its not.

```
def validMountainArray(arr: list[int]) -> bool:
    N = len(arr)
    i = 0

    # walk up
    while i + 1 < N and arr[i] < arr[i + 1]:
        i += 1

    # peak can't be first or last
    if i == 0 or i == N - 1:
        return False

    # walk down
    while i + 1 < N and arr[i] > arr[i + 1]:
        i += 1

    return i == N - 1

arr = [2, 3, 5, 7, 8, 6, 4]
result = validMountainArray(arr)
print(result)  # Output: True
```

> ì½”ë“œ ì„¤ëª…
>
> - ë¨¼ì € ì¸ë±ìŠ¤ 0ë¶€í„° ì‹œì‘í•˜ê³  í˜„ì¬ ìš”ì†Œë‘ ë‹¤ìŒ ìš”ì†Œì˜ ê°’ì„ ë¹„êµí•´ì„œ ì‚°ì„ ì˜¤ë¥´ëŠ” ë¶€ë¶„ì„ ì°¾ìŠµë‹ˆë‹¤.
> - ê·¼ë° ì‚°ê¼­ëŒ€ê¸° ë¶€ë¶„ì´ ì²«ë²ˆì§¸ ì¸ë±ìŠ¤ì´ê±°ë‚˜ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë©´ ì‚° ëª¨ì–‘ì´ ë  ìˆ˜ ì—†ìœ¼ë‹ˆê¹Œ, ì´ëŸ´ ê²½ìš°ì—” false ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
> - ê·¸ëŸ° ë‹¤ìŒì—ëŠ” ë˜ í˜„ì¬ ìš”ì†Œë‘ ë‹¤ìŒ ìš”ì†Œì˜ ê°’ì„ ë¹„êµí•´ì„œ ì‚°ì„ ë‚´ë ¤ê°€ëŠ” ë¶€ë¶„ì„ ì°¾ê³  ë§ì„ ê²½ìš°, true ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

Complexity Analysis

- Time Complexity: O(n), where N is the length of A.
- Space Complexity: O(1).

<br>

---

<br>

    ğŸ–‹ï¸ This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts ğŸ˜†

[Back to Top](#){: .btn .btn--primary }{: .align-right}
