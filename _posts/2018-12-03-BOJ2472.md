---
title:  "백준2472 체인점"
date:   2018-12-03 03:12:00
categories:
- KOI
tags:
- KOI
- Segment-Tree
- Dijkstra
---

### 문제 링크
* http://icpc.me/2472

### 문제 출처
* 2010 KOI 전국 본선 중등부3, 고등부2

### 사용 알고리즘
* Segment Tree
* Dijkstra

### 풀이
<a href = "https://justicehui.github.io/boi/2018/12/02/BOJ2336/">이 문제</a>에 <a href = "https://justicehui.github.io/medium-algorithm/2018/03/28/Dijkstra/">Dijkstra 알고리즘</a>을 섞어서 풀면 됩니다.

다만, 구현량이 꽤 많고 복잡하니 실수 하지 않도록 주의하시는 것을 권장합니다.

### 전체 코드
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long lld;

struct Info{
    int x, y, z, i;
    Info(){ x = 0, y = 0, z = 0, i = 0; }
    bool operator < (const Info &rhs) const{
        if(x == rhs.x){
            if (y == rhs.y) return z > rhs.z;
            return y > rhs.y;
        }
        return x < rhs.x;
    }
} A[100001];

struct SegmentTree{
    int tree[400010];
    const int INF = 1<<29;
    SegmentTree(){
        for (int i=0; i<400010; i++) tree[i] = INF;
    }
    int update(int node, int begin, int end, int index, int val){
        if (index < begin || end < index) return tree[node];
        if (begin == end) return tree[node] = val;
        int mid = (begin + end) >> 1;
        int v1 = update(node*2, begin, mid, index, val);
        int v2 = update(node*2+1, mid+1, end, index, val);
        return tree[node] = min(v1, v2);
    }
    int query(int node, int begin, int end, int left, int right){
        if (right < begin || end < left) return INF;
        if (left <= begin && end <= right) return tree[node];
        int mid = (begin + end) >> 1;
        int v1 = query(node*2, begin, mid, left, right);
        int v2 = query(node*2+1, mid+1, end, left, right);
        return min(v1, v2);
    }
} seg;

struct Edge{
    int to; lld w;
    Edge(int to_, lld w_){ to = to_; w = w_; }
};

struct Node{
    int u; lld d;
    Node(int u_, lld d_){ u = u_; d = d_; }
    bool operator < (const Node &other) const{
        return d > other.d;
    }
};

vector<lld> D, E, F;
int N, M, T;
int X, Y, Z;
vector<lld> U, V, W;
vector<Edge> adj[100001];
const lld llINF = 1LL<<60;
bool ans[100001];

void dijkstra(int start, vector<lld> &dist){
    dist.resize(N+1);
    dist[0] = 0;
    for (int i=1; i<=N; i++) dist[i] = llINF;
    dist[start] = 0;
    priority_queue<Node> pq;
    pq.push(Node(start, 0));
    while (!pq.empty()){
        int u = pq.top().u;
        lld dist_u = pq.top().d;
        pq.pop();
        if (dist[u] < dist_u) continue;
        for (unsigned int i=0; i<adj[u].size(); i++){
            int v = adj[u][i].to;
            lld dist_v = dist_u + adj[u][i].w;
            if (dist_v < dist[v]){
                dist[v] = dist_v;
                pq.push(Node(v, dist_v));
            }
        }
    }
}

inline int getIndex(vector<lld> &vec, lld val){
    return lower_bound(vec.begin(), vec.end(), val) - vec.begin();
}

void solve(){
    sort(A+1, A+N+1);
    for (int i=1; i<=N; i++){
        if (seg.query(1, 1, N, 1, A[i].y-1) >= A[i].z) ans[A[i].i] = 1;
        seg.update(1, 1, N, A[i].y, min(A[i].z, seg.query(1, 1, N, A[i].y, A[i].y)));
    }
}

void query(){
    cin >> T;
    while (T--){
        int n;
        cin >> n;
        cout << (ans[n] ? "YES" : "NO") << '\n';
    }
}

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    cin >> N;
    cin >> X >> Y >> Z;
    cin >> M;
    for (int num = 0; num < M; num++){
        int u, v; lld w;
        cin >> u >> v >> w;
        adj[u].push_back(Edge(v, 1LL*w));
        adj[v].push_back(Edge(u, 1LL*w));
    }

    dijkstra(X, U);
    dijkstra(Y, V);
    dijkstra(Z, W);
    for (int i=1; i<=N; i++){
        D.push_back(U[i]);
        E.push_back(V[i]);
        F.push_back(W[i]);
    }
    sort(D.begin(), D.end());
    sort(E.begin(), E.end());
    sort(F.begin(), F.end());
    unique(D.begin(), D.end());
    unique(E.begin(), E.end());
    unique(F.begin(), F.end());
    for (int i=1; i<=N; i++){
        A[i].x = 1+getIndex(D, U[i]);
        A[i].y = 1+getIndex(E, V[i]);
        A[i].z = 1+getIndex(F, W[i]);
        A[i].i = i;
    }

    solve();
    query();
}
```
