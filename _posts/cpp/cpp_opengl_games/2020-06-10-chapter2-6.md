---
title:  "[C++] 2.6 ì‹±ê¸€í†¤ íŒ¨í„´ Singleton Pattern" 

categories:
  - C++ games
tags:
  - [Programming, Cpp, OpenGL, Graphics, Design Pattern]

toc: true
toc_sticky: true

date: 2020-06-10
last_modified_at: 2020-06-10
---

ì¸í”„ëŸ°ì— ìˆëŠ” í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ **í™ì •ëª¨ì˜ ê²Œì„ ë§Œë“¤ê¸° ì—°ìŠµ ë¬¸ì œ íŒ¨í‚¤ì§€** ê°•ì˜ë¥¼ ë“£ê³  ì •ë¦¬í•œ í•„ê¸°ì…ë‹ˆë‹¤.ğŸ˜€   
[ğŸŒœ ê³µë¶€ì— ì‚¬ìš©ëœ í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ ì½”ë“œë“¤ ë³´ëŸ¬ê°€ê¸°](https://github.com/jmhong-simulation/GameDevPracticePackage)   
[ğŸŒœ [í™ì •ëª¨ì˜ ê²Œì„ ë§Œë“¤ê¸° ì—°ìŠµ ë¬¸ì œ íŒ¨í‚¤ì§€] ê°•ì˜ ë“¤ìœ¼ëŸ¬ ê°€ê¸°!](https://www.inflearn.com/course/c-2)
{: .notice--warning}

<br>

# Chapter 2. ê°ì²´ ì§€í–¥ìœ¼ë¡œ ê°€ëŠ” ê¸¸ : ì‹±ê¸€í†¤ íŒ¨í„´

## ğŸ”” ì‹±ê¸€í†¤ íŒ¨í„´ì´ë€?
- ì–´ë–¤ í´ë˜ìŠ¤ì˜ ê°ì²´ê°€ í”„ë¡œê·¸ë¨ ì „ì²´ì—ì„œ ë‹¨ í•˜ë‚˜ë§Œ ë§Œë“¤ì–´ì§€ë„ë¡ í•˜ëŠ” ê²ƒ.
  - <u>ì˜¤ì§ í•œê°œì˜ ì¸ìŠ¤í„´ìŠ¤ë§Œ</u>ì„ ê°–ë„ë¡ ë³´ì¥.
- ê·¸ë˜í”½ìŠ¤ ì—”ì§„ì´ë‚˜ ì‚¬ìš´ë“œ ì—”ì§„ì— ì¢…ì¢… ì‚¬ìš© ëœë‹¤.

<br>

## ğŸ“œSoundEngine.h ì„¤ëª…

```cpp
#pragma once

#include "fmod.hpp"
#include <iostream>
#include <map>
#include <string>

namespace jm
{
	class SoundEngine
	{
	private:
		FMOD::System  *system = nullptr;
		//FMOD::Channel *channel = nullptr;
		std::map<std::string, FMOD::Sound*> sound_map;  
		std::map<FMOD::Sound*, FMOD::Channel*> channel_map;
																								
		FMOD_RESULT   result;
		unsigned int  version;
		void          *extradriverdata = nullptr;

	public:
		SoundEngine()     
		{
			using namespace std;

			result = FMOD::System_Create(&system);   // ì‹œìŠ¤í…œ ìƒì„±
			if (result != FMOD_OK) {
				cout << "FMOD::System_Create() fail" << endl;
				exit(-1);
			}

			result = system->getVersion(&version);  // ì‹œìŠ¤í…œ ë²„ì „ í™•ì¸
			if (result != FMOD_OK) {
				cout << "getVersion() fail" << endl;
				exit(-1);
			}
			else printf("FMOD version %08x\n", version); 

			result = system->init(32, FMOD_INIT_NORMAL, extradriverdata);  // ì‹œìŠ¤í…œ ì´ˆê¸°í™”
			if (result != FMOD_OK) {
				cout << "system->init() fail" << endl;
				exit(-1);
			}
		}

	public:
		~SoundEngine()  //  ì†Œë©¸ì
		{
			system->release();  // ì‹œìŠ¤í…œ ë¦´ë¦¬ì¦ˆ 
		}

		void createSound(const std::string & filename, const std::string & sound_name, const bool & use_loop)
		{
			sound_map[sound_name] = nullptr; 

			auto & sound_ptr = sound_map[sound_name];  

			const int loop_flag = use_loop ? FMOD_LOOP_NORMAL : FMOD_LOOP_OFF;

			result = system->createSound(filename.c_str(), loop_flag, 0, &sound_ptr); 
			
			if (result != FMOD_OK) {
				std::cout << "system->createSound() fail" << std::endl;
				exit(-1);
			}
		}
	  
		void playSound(const std::string & sound_name)
		{
			if (sound_map.count(sound_name) <= 0) {
				std::cout << sound_name << " isn't initialized." << std::endl;
				exit(-1);
			}

			const auto & sound_ptr = sound_map[sound_name];
			auto & channel_ptr = channel_map[sound_ptr];  
 
			bool is_playing = false;  
			result = channel_ptr->isPlaying(&is_playing);
			if (is_playing) return; 

			result = system->playSound(sound_ptr, 0, false, &channel_ptr);  

			if (result != FMOD_OK) {
				std::cout << "system->playSound() fail" << std::endl;
				exit(-1);
			}
		}
	
		void stopSound(const std::string & sound_name)
		{
			if (sound_map.count(sound_name) <= 0) {
				std::cout << sound_name << " isn't initialized." << std::endl;
				exit(-1);
			}

			const auto & sound_ptr = sound_map[sound_name]; 
			auto & channel_ptr = channel_map[sound_ptr]; 

			bool is_playing = false; 
			result = channel_ptr->isPlaying(&is_playing); 
			if (is_playing == false) return; 

			result = channel_ptr->stop(); 

			if (result != FMOD_OK) {
				std::cout << "system->playSound() fail" << std::endl;
				exit(-1);
			}
		}
	};
}
```

> êµìˆ˜ë‹˜ì´ ì‚¬ìš´ë“œ ì—”ì§„ì— ëŒ€í•œ ì´í•´ë¥¼ ë•ê¸° ìœ„í•´ ë§Œë“œì‹  ê²ƒì´ê¸° ë•Œë¬¸ì— ê°„ë‹¨í•¨ ê²Œì„ ì œì‘ì—” ê´œì°®ì§€ë§Œ ì‹¤ë¬´ì—” ë¹„íš¨ìœ¨ì ì¸ ì½”ë“œì„

- ë©¤ë²„
  - *FMOD::System  *system*
    - ì‹œìŠ¤í…œ 
  - *map\<std::string, FMOD::Sound*> sound_map*
    - ì‚¬ìš´ë“œ ì´ë¦„ê³¼ ì‚¬ìš´ë“œ í¬ì¸í„°ë¥¼ ë§µí•‘í•˜ì—¬ ë‹´ê³  ìˆëŠ” ë³€ìˆ˜ 
      - Key ğŸ‘‰ ì‚¬ìš´ë“œ ì´ë¦„ *(string)*
      - Value ğŸ‘‰ ì‚¬ìš´ë“œ í¬ì¸í„° *(FMOD::Sound \*)*
  - *map\<FMOD::Sound*, FMOD::Channel*> channel_map;*
    - ì‚¬ìš´ë“œ í¬ì¸í„°ì™€ ì±„ë„ í¬ì¸í„°ë¥¼ ë§µí•‘í•˜ì—¬ ë‹´ê³  ìˆëŠ” ë³€ìˆ˜
      - Key ğŸ‘‰ ì‚¬ìš´ë“œ ì´ë¦„ *(FMOD::Sound \*)*
      - Value ğŸ‘‰ ì‚¬ìš´ë“œ í¬ì¸í„° *(FMOD::Channel \*)*
    - ì›ë˜ëŠ” í•œ ì±„ë„ì— ì—¬ëŸ¬ ì‚¬ìš´ë“œê°€ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ”ë° 1ê°œì˜ ì‚¬ìš´ë“œ ë‹¹ 1ê°œì˜ ì±„ë„ì— ë§µí•‘ë˜ì–´ ìˆëŠ” ì´ ë¶€ë¶„ ë•Œë¬¸ì— ë¹„íš¨ìœ¨ì ì¸ ì½”ë“œë¼ê³  ë§ì”€í•˜ì‹  ê²ƒ. 
- ìƒì„±ì
  - ì‹œìŠ¤í…œ ìƒì„±
  - ì‹œìŠ¤í…œ ë²„ì „ í™•ì¸
  - ì‹œìŠ¤í…œ ì´ˆê¸°í™”
- í•¨ìˆ˜
  - *createSound(filename, sound_name, use_loop)*
    - <u>ì‚¬ìš´ë“œë¥¼ ìƒì„±</u>í•œë‹¤.
    - ë§¤ê°œë³€ìˆ˜
      - filename
        - stringìœ¼ë¡œ ì‹¤ì œ íŒŒì¼ ì´ë¦„ ë°›ê¸°  *ex) bomb.wav*
      - sound_name
        - ì‚¬ìš´ë“œ ì´ë¦„
        - stringìœ¼ë¡œ ê·¸ íŒŒì¼ì„ ë‹´ê³  ìˆëŠ” ì‚¬ìš´ë“œê°€ ì–´ë–¤ ì´ë¦„ì¸ì§€ ë°›ê¸° (íŒŒì¼ ì´ë¦„ ë§ê³ )
        - ì–˜ë‘ ì‚¬ìš´ë“œ í¬ì¸í„°ë¥¼ ë§µí•‘ ì‹œí‚¬ ê²ƒ. *map\<std::string, FMOD::Sound*> sound_map*
        - *ex)* createSound("drumloop.wav", "background_music", true); ë¼ë©´ "drumloop.wav" íŒŒì¼ì„ ì´ì œë¶€í„° "background_music"ë¼ëŠ” ì‚¬ìš´ë“œ ì´ë¦„ìœ¼ë¡œ ë¶€ë¥´ê² ë‹¨ ì˜ë¯¸.
      - use_loop
        - ì´ ì‚¬ìš´ë“œê°€ ë¬´í•œë°˜ë³µ ë  ê²ƒì¸ê°€ë¥¼ ì„¤ì •í•˜ëŠ” í”Œë˜ê·¸
        - *FMOD_LOOP_NORMAL*, *FMOD_LOOP_OFF* ë‘˜ ì¤‘ í•˜ë‚˜ë‹¤.
    - ì„¤ëª…
      - sound_map[sound_name] = nullptr;
        - ì‚¬ìš´ë“œ ì´ë¦„ì„ Keyê°’ìœ¼ë¡œ ë„£ìœ¼ë©´ ë‚˜ì˜¤ëŠ” ì‚¬ìš´ë“œ í¬ì¸í„° Value ê°’ì„ nullptrë¡œ ì´ˆê¸°í™”
      - auto & sound_ptr = sound_map[sound_name];
        - `sound_ptr`ì€ ì‚¬ìš´ë“œ ì´ë¦„ì„ Keyê°’ìœ¼ë¡œ ë„£ìœ¼ë©´ ë‚˜ì˜¤ëŠ” ì‚¬ìš´ë“œ í¬ì¸í„° Value ê°’ì„ ì°¸ì¡°í•œë‹¤.
        - `sound_ptr`ì€ ê³§ í•´ë‹¹ ì‚¬ìš´ë“œ ì´ë¦„ì˜ ì‚¬ìš´ë“œ í¬ì¸í„°ê°€ ëœë‹¤.
      - result = system->createSound(filename.c_str(), loop_flag, 0, &sound_ptr);
        - ì‹œìŠ¤í…œì´ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ì€ ì‚¬ìš´ë“œ íŒŒì¼ë¡œ ì‚¬ìš´ë“œë¥¼ ë§Œë“¤ê³  ê·¸ ì£¼ì†Œë¥¼ `sound_ptr`ì— ë‹´ëŠ”ë‹¤.
        - ì´ì œ `sound_ptr`ë¡œ ì‘ì—… ê°€ëŠ¥
  - *playSound(sound_name)*
    - <u>ì‚¬ìš´ë“œë¥¼ ì¬ìƒ</u>í•œë‹¤.
      - const auto & sound_ptr = <u>sound_map</u>[sound_name];
        - sound_nameì„ sound_ptr ê³¼ ë§¤í•‘
        - *map\<std::string, FMOD::Sound*> sound_map*
      - auto & channel_ptr = <u>channel_map</u>[sound_ptr];
        - sound_ptrê³¼ channel_pttrì„ ë§¤í•‘
        - *map\<FMOD::Sound*, FMOD::Channel*> channel_map;*
      - bool is_playing = false;
        - ì´ë¯¸ ì¬ìƒì¤‘ì´ë¼ë©´ ì¶”ê°€ì ìœ¼ë¡œ ì¬ìƒí•  í•„ìš”ê°€ ì—†ìŒ
      - result = channel_ptr->isPlaying(&is_playing);
        - ì´ë¯¸ ì¬ìƒ ì¤‘ì´ë¼ë©´ is_playing ê°’ì„ trueë¡œ ë°”ê¿”ì£¼ëŠ” í•¨ìˆ˜.
      - if (is_playing) return; 
        - ì´ë¯¸ ì¬ìƒ ì¤‘ì´ë¼ë©´ ì‚¬ìš´ë“œë¥¼ ì¬ìƒí•˜ì§€ ì•Šê³  ì¢…ë£Œ
      - result = system->playSound(sound_ptr, 0, false, &channel_ptr);
        - ì´ë¯¸ ì¬ìƒì¤‘ì´ ì•„ë‹ˆë¼ë©´ systemì˜ playSound í†µí•´ ì •ìƒ ì¬ìƒ !
  - *stopSound(sound_name)*
    - <u>ì‚¬ìš´ë“œë¥¼ ì •ì§€</u>í•œë‹¤.
    - ê³¼ì •ì€ *playSound(sound_name)*ì™€ ë¹„ìŠ·
      - ì¬ìƒ ì¤‘ì´ ì•„ë‹ˆë¼ë©´ ì •ì§€í•  í•„ìš”ê°€ ì—†ìŒ
      - ì¬ìƒ ì¤‘ì¼ ë•Œë§Œ ì •ì§€

<br>

## ğŸ”” ì‹±ê¸€í†¤ ìœ ë¬´ ë¹„êµí•˜ê¸°

### ì‚¬ìš´ë“œ ì—”ì§„ì„ ê°ì²´ë¡œ ìƒì„±í•˜ì—¬ ì‚¬ìš©í•œ ê²½ìš° (ì‹±ê¸€í†¤X)
```cpp
SoundEngine sound_engine;
```

ì‚¬ìš´ë“œ ì—”ì§„ì„ ì‚¬ìš©í•˜ë ¤ê³  í•  ë•Œ SoundEngineì„ ***ê°ì²´*** ë¡œ ì°ì–´ë‚´ ì‚¬ìš©í•œ ê²½ìš°. 

- #include "SoundEngine.h" 
- SoundEngine sound_engine;
  - âœ¨âœ¨ <u>ì‚¬ìš´ë“œ ì—”ì§„ì„ ê°ì²´ë¥¼ ìƒì„±í•¨</u> âœ¨âœ¨`
    - ì‚¬ìš´ë“œ ì—”ì§„ì˜ í•¨ìˆ˜ë“¤ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ! (ì‚¬ìš´ë“œ ì¬ìƒ ë° ì •ì§€)
    - ì´ ë¶€ë¶„ì´ ì‹±ê¸€í†¤ê³¼ì˜ ì°¨ì´ì ì´ë‹¤.
- sound_engine.playSound("background_music");
  - "drumloop.wav"ì´ ë¬´í•œë£¨í”„ë¡œ ì¬ìƒë  ê²ƒ.


### ì‚¬ìš´ë“œ ì—”ì§„ì„ ì‹±ê¸€í†¤ìœ¼ë¡œ ì‚¬ìš©í•œ ê²½ìš°

#### ì‹±ê¸€í†¤ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ 

1. ì‚¬ìš´ë“œ ì—”ì§„ì€ ì—¬ëŸ¬ê°€ì§€ ë§ì€ í´ë˜ìŠ¤, ê°ì²´ì—ì„œ ë§ì´ ì‚¬ìš©ëœë‹¤.
  - ì‚¬ìš´ë“œ ê¸°ëŠ¥ì„ ì“°ëŠ” ê°ì²´ë§ˆë‹¤ ê³„ì† ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´ë¥¼ ìƒì„±í•´ë‚´ê³  ë§¤ê°œë³€ìˆ˜ë¡œ ë„˜ê¸°ê³  í•˜ëŠ” ê²ƒ ë„ˆë¬´ ë‚­ë¹„.
2. ì‚¬ìš´ë“œ ì—”ì§„ì€ ê°ì²´ê°€ ì—¬ëŸ¬ê°œì¼ í•„ìš”ê°€ ì—†ë‹¤. ë‹¨ í•˜ë‚˜ë©´ ëœë‹¤. 
  - ì‚¬ìš´ë“œ ì—”ì§„ì˜ ê¸°ëŠ¥ë“¤ë§Œ ê°€ì ¸ë‹¤ ì“°ë©´ ëœë‹¤.
  - ì‚¬ìš´ë“œ ì—”ì§„ì˜ `map` ì— ì €ì¥ë˜ì–´ìˆëŠ” ì‚¬ìš´ë“œë“¤ <u>êµ³ì´ ë‹¤ ê°ì²´ë¡œ ì°ì–´ë‚¼ í•„ìš” ì—†ì´ ê¸°ì¡´ì— ë§Œë“¤ì–´ì§„ ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´ë¥¼ ê³µìœ í•˜ëŠ”ê²Œ ë” íš¨ìœ¨ì ì´ë‹¤.</u>

> ë”°ë¼ì„œ ì‚¬ìš´ë“œ ì—”ì§„ì´ 1ï¸âƒ£ê°ì²´ ìƒì„± ì—†ì´ ì‚¬ìš©ë  ìˆ˜ ìˆê²Œë” í•œë‹¤. 2ï¸âƒ£ì‹œìš´ë“œ ì—”ì§„ ê°ì²´ ë”± í•˜ë‚˜ë¥¼ ì—¬ëŸ¬êµ°ë°ì„œ ê³µìœ í•  ìˆ˜ ìˆê²Œ í•œë‹¤. ì´ì™€ ê°™ì€ ë””ìì¸ íŒ¨í„´ì„ `ì‹±ê¸€í†¤`ì´ë¼ê³  í•œë‹¤. 

1. âœ¨ì‚¬ìš´ë“œ ì—”ì§„ í´ë˜ìŠ¤ì—ì„œ <u>ìê¸° ìì‹ (ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´)</u>ì„ `static` ë³€ìˆ˜ì— ë„£ì–´ë‘ë©´ ëœë‹¤. 
2. âœ¨ê·¸ë¦¬ê³  ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´ëŠ” <u>ë”± 1ê°œë§Œ ìƒì„±ë  ìˆ˜ ìˆê²Œ</u> ì—¬ëŸ¬ ì¥ì¹˜ë¥¼ í†µí•˜ì—¬ ì œì–´í•œë‹¤.
  - ìƒì„±ìë¥¼ privateìœ¼ë¡œ í•˜ì—¬ ê°ì²´ë¡œ ì°ì–´ë‚´ëŠ” ê²ƒì„ ë§‰ëŠ”ë‹¤.
  - `static`ë³€ìˆ˜ì— ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´ë¥¼ ë„£ì–´ì¤„ ë•Œ ë³€ìˆ˜ ê°’ì´ nullì¼ë•Œë§Œ ë„£ëŠ”ë‹¤. 

#### static ë©¤ë²„ ë³€ìˆ˜ íŠ¹ì§•
1. static ë©¤ë²„ ë³€ìˆ˜ì˜ ê°’ì„ <u>ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ë“¤ì´ ê³µìœ </u>í•  ìˆ˜ ìˆë‹¤.
2. ë”± í•œë²ˆë§Œ ìƒì„±ëœë‹¤.
3. ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì—†ì´ë„ <u>í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ì ‘ê·¼</u>í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.  
4. <u>ì´ˆê¸°í™”ëŠ” ë°˜ë“œì‹œ í´ë˜ìŠ¤ ë°–ì—ì„œ</u> í•´ì¤€ë‹¤. 
  - ê³µìœ ë˜ëŠ” ë³€ìˆ˜ì´ê¸° ë•Œë¬¸ì— ê°ì²´ ìƒì„±ì‹œë§ˆë‹¤ ë³€ìˆ˜ê°€ ì¤‘ë³µ ì„ ì–¸ ë˜ëŠ”ê²ƒì„ ë°©ì§€ í•˜ê¸° ìœ„í•´
  - ì´ˆê¸°í™”ëŠ” ë³´í†µ cpp íŒŒì¼ì—ì„œ <u>ë”°ë¡œ ì´ˆê¸°í™” 1íšŒ í•´ì£¼ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ì„œ</u> í•´ì¤€ë‹¤.

#### static ë©¤ë²„ í•¨ìˆ˜ íŠ¹ì§•
1. ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì—†ì´ë„ í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ì ‘ê·¼í•˜ì—¬ ì‚¬ìš© ê°€ëŠ¥
2. static ë³€ìˆ˜ë¥¼ ë¦¬í„´í•  ìˆ˜ ìˆë‹¤.

#### ğŸ“œSoundEngine_Singleton.h

- *static SoundEngine_Singleton \* <u>instance</u>*
  - ì´ `instance` ë³€ìˆ˜ì— ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ë¥¼ ë„£ì–´ë‘˜ ê²ƒ.
    - ë„£ì–´ë‘” ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ëŠ” ê³µìœ ëœë‹¤.
  - `static`ì´ë¯€ë¡œ ì™¸ë¶€ì—ì„œ "SoundEngine_Singleton.instance" ì´ë ‡ê²Œ í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.
  - privateì´ê¸° ë•Œë¬¸ì— Getterí•¨ìˆ˜ë¡œë§Œ ì „ë‹¬ë°›ì„ ìˆ˜ ìˆë‹¤.
- *static SoundEngine_Singleton \* <u>getInstance()</u>;*
  - `instance` ë³€ìˆ˜ì— ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ë¥¼ ë„£ì–´ì¤€ë‹¤.
    - ë”± í•œë²ˆë§Œ ë„£ì„ ìˆ˜ ìˆë„ë¡ í•œë‹¤.
  - `instance`ì˜ Getterí•¨ìˆ˜ë¡œì„œ `instance`ì„ ë¦¬í„´í•œë‹¤.
    - ì¦‰ ëª¨ë‘ê°€ ê³µìœ í•˜ëŠ” ë‹¨ í•˜ë‚˜ì˜ ì‚¬ìš´ë“œê°ì²´ì˜ í¬ì¸í„°ë¥¼ ë¦¬í„´í•´ì£¼ëŠ” ê²ƒì´ë‹¤.
  - ì™¸ë¶€ì—ì„œ ì´ í•¨ìˆ˜ë¥¼ í†µí•´ `instance`ì„ ì „ë‹¬ë°›ì•„ì•¼ í•˜ë¯€ë¡œ public
- ìƒì„±ìëŠ” privateì´ë‹¤
  - ì™¸ë¶€ì—ì„œ ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ ë§ˆêµ¬ ì°ì–´ë‚´ì§€ ëª»í•˜ë„ë¡
    - ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ê°€ ë‹¨ í•˜ë‚˜ë§Œ ì¡´ì¬í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì¥ì¹˜1ï¸âƒ£

```cpp
#pragma once

#include "fmod.hpp"
#include <iostream>
#include <map>
#include <string>

namespace jm
{
	class SoundEngine_Singleton
	{
	private:
		FMOD::System  *system = nullptr;
		std::map<std::string, FMOD::Sound*> sound_map;
		std::map<FMOD::Sound*, FMOD::Channel*> channel_map;
		
		FMOD_RESULT   result;
		unsigned int  version;
		void          *extradriverdata = nullptr;

		static SoundEngine_Singleton * instance;  

	public:
		static SoundEngine_Singleton * getInstance(); 

	private:
		SoundEngine_Singleton()     
		{
			using namespace std;

			result = FMOD::System_Create(&system);
			if (result != FMOD_OK) {
				cout << "FMOD::System_Create() fail" << endl;
				exit(-1);
			}

			result = system->getVersion(&version);
			if (result != FMOD_OK) {
				cout << "getVersion() fail" << endl;
				exit(-1);
			}
			else printf("FMOD version %08x\n", version);

			result = system->init(32, FMOD_INIT_NORMAL, extradriverdata);
			if (result != FMOD_OK) {
				cout << "system->init() fail" << endl;
				exit(-1);
			}
		}

	public:
		~SoundEngine_Singleton()
		{
			system->release();
		}

		void createSound(const std::string & filename, const std::string & sound_name, const bool & use_loop)
		{
			sound_map[sound_name] = nullptr;

			auto & sound_ptr = sound_map[sound_name];

			const int loop_flag = use_loop ? FMOD_LOOP_NORMAL : FMOD_LOOP_OFF;

			result = system->createSound(filename.c_str(), loop_flag, 0, &sound_ptr);
			
			if (result != FMOD_OK) {
				std::cout << "system->createSound() fail" << std::endl;
				exit(-1);
			}
		}

		void playSound(const std::string & sound_name)
		{
			if (sound_map.count(sound_name) <= 0) {
				std::cout << sound_name << " isn't initialized." << std::endl;
				exit(-1);
			}

			const auto & sound_ptr = sound_map[sound_name];
			auto & channel_ptr = channel_map[sound_ptr];

			bool is_playing = false;
			result = channel_ptr->isPlaying(&is_playing);

			if (is_playing) return; // don't play if this is already playing

			result = system->playSound(sound_ptr, 0, false, &channel_ptr);

			if (result != FMOD_OK) {
				std::cout << "system->playSound() fail" << std::endl;
				exit(-1);
			}
		}

		void stopSound(const std::string & sound_name)
		{
			if (sound_map.count(sound_name) <= 0) {
				std::cout << sound_name << " isn't initialized." << std::endl;
				exit(-1);
			}

			const auto & sound_ptr = sound_map[sound_name];
			auto & channel_ptr = channel_map[sound_ptr];

			bool is_playing = false;
			result = channel_ptr->isPlaying(&is_playing);

			if (is_playing == false) return; // don't stop playing if this is not playing

			result = channel_ptr->stop();

			if (result != FMOD_OK) {
				std::cout << "system->playSound() fail" << std::endl;
				exit(-1);
			}
		}
	};
}
```

#### ğŸ“œSoundEngine_Singleton.cpp
- *static SoundEngine_Singleton \* <u>getInstance()</u>;* ë°”ë”” êµ¬í˜„
  - if (instance == nullptr)
    - ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ê°€ ë‹¨ í•˜ë‚˜ë§Œ ì¡´ì¬í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì¥ì¹˜2ï¸âƒ£
    - ì´ ì¡°ê±´ ë•ë¶„ì— *instance = new SoundEngine_Singleton();* ëŠ” ë”± í•œë²ˆë§Œ ì‹¤í–‰ëœë‹¤.
  - `instance`ì— ìœ ì¼ë¬´ì´í•˜ë©° ëª¨ë‘ê°€ ê³µìœ í•  ìˆ˜ ìˆëŠ” ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ë¥¼ ë„£ì–´ì¤€ë‹¤.
  - ê·¸ë¦¬ê³  `instance`ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ ë¦¬í„´í•´ì¤€ë‹¤. 

```cpp
#include "SoundEngine_Singleton.h"

namespace jm
{
	SoundEngine_Singleton * SoundEngine_Singleton::instance = nullptr; 

	SoundEngine_Singleton * SoundEngine_Singleton::getInstance() 
	{
		if (instance == nullptr)  
		{
			instance = new SoundEngine_Singleton();  
		}
		return instance;
	}
}
```

#### ğŸ“œTankExample.h
```cpp
auto & sound_engine = *SoundEngine_Singleton::getInstance();  
```
- ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´ë¥¼ ìƒì„±í•  í•„ìš”ê°€ ì—†ë‹¤. ê·¸ëƒ¥ ë©”ëª¨ë¦¬ ê³µìœ í•˜ê¸° ìœ„í•´ ê°€ì ¸ì˜¤ë©´ ë¨.
  - ì‹±ê¸€í†¤ì¸ ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ì˜ ì£¼ì†Œë¥¼ ë°›ì•„ì™€ ê°„ì ‘ì°¸ì¡°(*) í•œë‹¤.
  - ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´.
  - sound_engineì´ ì´ë¥¼ ì°¸ì¡°í•œë‹¤. 

```cpp
#pragma once

#include "Game2D.h"
#include "MyBullet.h"
#include "MyTank.h"
// #include "SoundEngine.h"
#include "SoundEngine_Singleton.h"

namespace jm
{
	class TankExample : public Game2D
	{
	public:
		MyTank tank;

		MyBullet *bullet = nullptr;
	
	public:
		TankExample()
			: Game2D("This is my digital canvas!", 1024, 768, false, 2)
		{
			auto & sound_engine = *SoundEngine_Singleton::getInstance();  

			sound_engine.createSound("drumloop.wav", "background_music", true);
			sound_engine.createSound("truck_idle_off_02.wav", "tank_move", true);
			sound_engine.createSound("cannon1.wav", "cannon", false);
			sound_engine.createSound("missile.mp3", "missile", false);

			sound_engine.playSound("background_music");
		}

		~TankExample()
		{
			if(bullet != nullptr) delete bullet;
		}

		void update() override
		{
			//auto & sound_engine = *SoundEngine_Singleton::getInstance();

			// move tank
			bool is_moving = false;

			if (isKeyPressed(GLFW_KEY_LEFT)) {
				tank.moveLeft(getTimeStep());
				is_moving = true;
			}

			if (isKeyPressed(GLFW_KEY_RIGHT)) {
				tank.moveRight(getTimeStep());
				is_moving = true;
			}

			if (isKeyPressed(GLFW_KEY_UP)) {
				tank.moveUp(getTimeStep());
				is_moving = true;
			}

			if (isKeyPressed(GLFW_KEY_DOWN)) {
				tank.moveDown(getTimeStep());
				is_moving = true;
			}

			if(is_moving)
				sound_engine.playSound("tank_move");
			else
				sound_engine.stopSound("tank_move");

			// shoot a cannon ball
			if (isKeyPressedAndReleased(GLFW_KEY_SPACE))
			{
				if (bullet != nullptr) delete bullet;

				bullet = new MyBullet;
				bullet->center = tank.center;
				bullet->center.x += 0.2f;
				bullet->center.y += 0.1f;
				bullet->velocity = vec2(2.0f, 0.0f);

				sound_engine.stopSound("cannon");
				sound_engine.playSound("cannon");				
			}

			if (bullet != nullptr) bullet->update(getTimeStep());

			// rendering
			tank.draw();
			if (bullet != nullptr) bullet->draw();
		}
	};
}
```

#### ğŸ“œMyBullet.h

- ì´ì•Œì´ ë‚ ì•„ê°ˆ ë•Œë§ˆë‹¤ ì‚¬ìš´ë“œë¥¼ ì¬ìƒì‹œí‚¤ê³  ì‹¶ë‹¤ë©´
  - ì‹±ê¸€í†¤ì„ ì•ˆì“´ë‹¤ë©´
    - ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ë¥¼ ìƒì„±í•´ì£¼ëŠ” ê²ƒì€ ì»´í“¨í„° ì‚¬ìš´ë“œ ì¹´ë“œì—ê²Œ ë„ˆë¬´ ë¶€ë‹´ ë˜ëŠ” ì¼
      - ì´ì•Œì€ ì—„ì²­ ìƒì„±ë˜ê¸° ë•Œë¬¸ì— ê·¸ë•Œë§ˆë‹¤ ê²Œì† ì‚¬ìš´ë“œì—”ì§„ ê°ì²´ê°€ ë˜ ìƒê¸°ê³  ë˜ ìƒê¸°ê³  í—¤ì• íˆë‹ˆê¹Œ.
    - ê·¸ë˜ì„œ ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³  MyBullet ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” TankExampleë¡œë¶€í„° ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´ë¥¼ íŒŒë¼ë¯¸í„°ë¡œ ë°›ì•„ì˜¨ë‹¤.
      - *bullet = new myBullet(sound_engine)* ì´ë ‡ê²Œ.
      - ì—¬ê¸°ì €ê¸° ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´ë¥¼ ê³„ì† íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬í•˜ê³  ë‹¤ë…€ì•¼í•´ì„œ ë¶ˆí¸.
  - ì‹±ê¸€í†¤ì„ ì“´ë‹¤ë©´ 
    - `ì‚¬ìš´ë“œ ì—”ì§„ ê°ì²´ ìƒì„± í˜¹ì€ íŒŒë¼ë¯¸í„° ì „ë‹¬` í•„ìš” ì—†ì´ ê·¸ëƒ¥ ê°„ë‹¨í•˜ê²Œ *bullet = new myBullet;* ë§Œ í•´ì£¼ì–´ë„ ëœë‹¤.
    - ê°ì²´ ìƒì„± í•„ìš” ì—†ì´ ë°”ë¡œ `*SoundEngine_Singleton::getInstance();` ë¡œ ë°›ì•„ì˜¤ë©´ ë˜ê¸° ë•Œë¬¸ì—.

```cpp
#pragma once

#include "Game2D.h"
#include "SoundEngine.h"
#include "SoundEngine_Singleton.h"

namespace jm
{
	class MyBullet
	{
	public:
		vec2 center = vec2(0.0f, 0.0f);
		vec2 velocity = vec2(0.0f, 0.0f);
			
		MyBullet()
		{
			SoundEngine_Singleton::getInstance()->playSound("missile"); 
		}

		~MyBullet()
		{
			SoundEngine_Singleton::getInstance()->stopSound("missile"); 
		}

		void draw()
		{
			beginTransformation();
			translate(center);
			drawFilledRegularConvexPolygon(Colors::yellow, 0.02f, 8);
			drawWiredRegularConvexPolygon(Colors::gray, 0.02f, 8);
			endTransformation();
		}

		void update(const float& dt)
		{
			center += velocity * dt;
		}
	};

}
```

***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}