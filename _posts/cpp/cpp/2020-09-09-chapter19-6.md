---
title:  "C++ Chapter 19.6 : ë©€í‹° ìŠ¤ë ˆë”© ì˜ˆì œ (ë²¡í„° ë‚´ì )" 

categories:
  - Cpp
tags:
  - [Programming, Cpp]

toc: true
toc_sticky: true

date: 2020-09-09
last_modified_at: 2020-09-09
---

ì¸í”„ëŸ°ì— ìˆëŠ” í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ **í™ì •ëª¨ì˜ ë”°ë¼ í•˜ë©° ë°°ìš°ëŠ” C++** ê°•ì˜ë¥¼ ë“£ê³  ì •ë¦¬í•œ í•„ê¸°ì…ë‹ˆë‹¤. ğŸ˜€    
[ğŸŒœ [í™ì •ëª¨ì˜ ë”°ë¼ í•˜ë©° ë°°ìš°ëŠ” C++]ê°•ì˜ ë“¤ìœ¼ëŸ¬ ê°€ê¸°!](https://www.inflearn.com/course/following-c-plus)
{: .notice--warning}

<br> 

# chapter 19. ëª¨ë˜ C++ í•„ìˆ˜ ìš”ì†Œë“¤

# ë©€í‹° ìŠ¤ë ˆë”© ì˜ˆì œ (ë²¡í„° ë‚´ì )

## ğŸ”” ë²¡í„° ë‚´ì (Dot Product)ì´ë€

\\[\vec{A}\cdot\vec{B} = x_A{\cdot}x_B + y_A{\cdot}y_B \\]

- ë‘ ë²¡í„°ì˜ ì„±ë¶„ë¼ë¦¬ ê³±í•´ì„œ ë”í•œ ìŠ¤ì¹¼ë¼ ê°’
- ìˆ˜í•™ì ìœ¼ë¡œëŠ” *A dot B* ìœ¼ë¡œ í‘œí˜„í•œë‹¤. 
- `ë²¡í„° ë‚´ì `ì˜ ì›ë¦¬ì™€ ê°œë… ì°¸ê³ 
  - [ë‘ ê³µì˜ ì¶©ëŒ : ë²¡í„° ë‚´ì ](https://ansohxxn.github.io/c++%20games/chapter3-2-2/)

<br>

## ğŸ”” ë²¡í„° ë‚´ì ì„ ê³„ì‚° í•˜ëŠ” ì½”ë“œ

7 ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ë²¡í„° ë‚´ì ì„ ê³„ì‚°í•´ë³´ê³  ê°ê°ì˜ ë°©ë²•ì´ ì–¼ë§ˆë‚˜ íš¨ìœ¨ì ì¸ì§€ ì‹¤í–‰ ì‹œê°„ì„ ì¬ë³¼ ê²ƒì´ë‹¤.

### ì „ì²´ ì½”ë“œì™€ ë¹„êµ

```cpp
#include <iostream>
#include <chrono>
#include <mutex>	
#include <utility>
#include <vector>	
#include <atomic>
#include <numeric>		// std::inner_product
#include <random>
#include <execution>	// parallel execution
#include <future>
#include <thread>

using namespace std;

mutex mtx;

void dotProductNaive(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

void dotProductLock(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	//cout << "Thread Start" << endl;
	for (unsigned int i = start; i < end; ++i)
	{
		std::scoped_lock lock(mtx);
		sum += (v0[i] * v1[i]);
	}
	//cout << "Thread End" << endl;
}

void dotProductAtomic(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, atomic<unsigned long long> & sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

auto dotProductFuture(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end)
{
	int sum = 0;
	for (unsigned int i = start; i < end; ++i)
		sum += (v0[i] * v1[i]);
	return sum;
}


int main()
{
	const long long numData = 100'000'000;
	const unsigned int numThread = 4;
	// thread ê°œìˆ˜ ëŠ˜ë¦°ë‹¤ê³  degree of multithreadingì´ ë†’ì•„ì§€ì§€ëŠ” ì•ŠìŒ

	vector<int> vec0, vec1;
	vec0.reserve(numData);
	vec1.reserve(numData);

	std::random_device seed;
	std::mt19937_64 makerand(seed());
	std::uniform_int_distribution<> range(1, 10);

	for (long long i = 0; i < numData; ++i)
	{
		vec0.push_back(range(makerand));
		vec1.push_back(range(makerand));
	}

	cout << "ì‹¤í—˜ 1ë²ˆ - std::inner_product\n";
	{
		const auto sta = std::chrono::steady_clock::now();		// ì‹œê°„ ì¸¡ì • ì‹œì‘
		const auto sum = std::inner_product(vec0.begin(), vec0.end(), vec1.begin(), 0ull);
		// ë‘ ë²¡í„°ì˜ ê°œìˆ˜ê°€ ê°™ë‹¤ê³  ê°€ì •í•˜ë¯€ë¡œ vec1ì€ beginë§Œ ìˆì–´ë„ ë˜ë©° ullì€ unsigned long longì˜ ì•½ì
		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;		

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 2ë²ˆ - Naive\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		unsigned long long sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductNaive, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 3ë²ˆ - Lockguard\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		unsigned long long sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductLock, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 4ë²ˆ - Atomic\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		atomic<unsigned long long> sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductAtomic, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 5ë²ˆ - Future\n";
	{
		const auto sta = std::chrono::steady_clock::now();

		unsigned long long sum = 0;

		vector<std::future<int>> futures;
		futures.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			futures[t] = std::async(dotProductFuture, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread);
		for (unsigned int t = 0; t < numThread; ++t)
			sum += futures[t].get();
		
		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}
	// TODO : Futureì˜ divide and conquer ë°©ì‹ì€ threadì—ì„œë„ êµ¬í˜„í•´ë³´ì.
	// async ëŒ€ì‹ ì— threadì™€ promiseë¥¼ ì‚¬ìš©í•´ì„œ futureì„ ì‚¬ìš©í•´ë³´ì.
	
  cout << "ì‹¤í—˜ 6ë²ˆ - promise\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		vector<std::promise<int>> prom;
		vector<std::future<int>> future;
		vector<std::thread> threads;
		prom.resize(numThread);
		future.resize(numThread);
		threads.resize(numThread);
		
		unsigned long long sum(0);
		unsigned numPerThread = numData / numThread;
		for (unsigned i = 0; i < numThread; ++i)
		{
			future[i] = prom[i].get_future();
			unsigned long long tempSum(0);
			threads[i] = std::thread([&](std::promise<int>&& prom)
				{
					std::scoped_lock lock2(mtx);
					
					for (unsigned int j = 0; j < numPerThread; ++j)
						tempSum += (vec0[j] * vec1[j]);
					prom.set_value(tempSum);
				}, std::move(prom[i]));
			threads[i].join();
		}
		for (unsigned int t = 0; t < numThread; ++t)
			sum += future[t].get();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 7ë²ˆ - std::transform_reduce\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		const auto sum = std::transform_reduce(std::execution::par, vec0.begin(), vec0.end(), vec1.begin(), 0ull);
		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}
}
```
```
ğŸ’ì¶œë ¥ğŸ’

ì‹¤í—˜ 1ë²ˆ - std::inner_product
ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = 0.068767
ê²°ê³¼ê°’ = 3025113384

ì‹¤í—˜ 2ë²ˆ - Naive
ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = 0.04685
ê²°ê³¼ê°’ = 889569211

ì‹¤í—˜ 3ë²ˆ - Lockguard
ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = 2.15617
ê²°ê³¼ê°’ = 3025113384

ì‹¤í—˜ 4ë²ˆ - Atomic
ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = 1.31186
ê²°ê³¼ê°’ = 3025113384

ì‹¤í—˜ 5ë²ˆ - Future
ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = 0.0189238
ê²°ê³¼ê°’ = 3025113384

ì‹¤í—˜ 6ë²ˆ - promise
ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = 0.0189238
ê²°ê³¼ê°’ = 3025113384

ì‹¤í—˜ 7ë²ˆ - std::transform_reduce
ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = 0.014745
ê²°ê³¼ê°’ = 3025113384
```

- 1ï¸âƒ£std::inner_product *â­•, ë¹ ë¦„*
- 2ï¸âƒ£ ìˆœì§„í•œ ë©€í‹° ì“°ë ˆë”© *âŒ, ë¹ ë¦„*
  - ë ˆì´ìŠ¤ ì»¨ë””ì…˜ìœ¼ë¡œ ê°’ì´ ë¶€ì •í™•í•˜ê²Œ ë‚˜ì˜¨ë‹¤.
- 3ï¸âƒ£ Lock guard *â­•, ëŠë¦¼*
  - `lock`, `unlock` ê³¼ì • ë•Œë¬¸ì— ëŠë¦¬ë‹¤.
- 4ï¸âƒ£ atomic *â­•, ëŠë¦¼*
  - `atomic`ì˜ ì—°ì‚°ì€ ëŠë¦° í¸ì´ë‹¤.
- 5ï¸âƒ£ Task-based parallelism (std::async) *â­•, ë¹ ë¦„*
- 6ï¸âƒ£ Task-based parallelism (std::thread, std::promise) *â­•, ë¹ ë¦„*
- 7ï¸âƒ£ std::transform_reduce *â­•, ë¹ ë¦„*

<br>

### main í•¨ìˆ˜

```cpp
using namespace std;

mutex mtx;

int main()
{
	const long long numData = 100'000'000;
	const unsigned int numThread = 4;

	vector<int> vec0, vec1;
	vec0.reserve(numData);
	vec1.reserve(numData);

	std::random_device seed;
	std::mt19937_64 makerand(seed());
	std::uniform_int_distribution<> range(1, 10);

	for (long long i = 0; i < numData; ++i)
	{
		vec0.push_back(range(makerand));
		vec1.push_back(range(makerand));
	}
```

- `mtx`
  - mutex ê°ì²´ë¡œ ì „ì—­ ë³€ìˆ˜ë¡œ ì„ ì–¸ ë˜ì—ˆë‹¤.
- `numData`
    - ë²¡í„° í¬ê¸°
    - 1ì–µê°œ !
- `numThread`
    - ìŠ¤ë ˆë“œ ê°œìˆ˜ë¥¼ 4 ê°œë¡œ ì§€ì •í–ˆë‹¤.
    - cf) ìŠ¤ë ˆë“œë¥¼ ë§ì´ ì“´ë‹¤ê³  ë©€í‹°ìŠ¤ë ˆë”© íš¨ìœ¨ì´ ë†’ì•„ì§€ëŠ”ê±´ ì•„ë‹ˆë‹¤
- `vec0`, `vec1`
    - ë‘ ë²¡í„° ì»¨í…Œì´ë„ˆ
    - ê°ê° reserve í•¨ìˆ˜ë¥¼ í†µí•´ `numData` (1ì–µ) í¬ê¸°ë¥¼ ê°€ì§„ ë²¡í„°ë¡œ ë§Œë“¤ì—ˆë‹¤.
- `seed`
    - ëœë¤ë„˜ë²„ ìƒì„± ì‹œë“œ
- std::mt19937_64 makerand(seed());
    - ëœë¤ ë„˜ë²„ ìƒì„±ê¸°
- std::uniform_int_distribution<> range(1, 10);
    - 1~10 ë²”ìœ„ ì¤‘ ëœë¤ ë„˜ë²„
- forë¬¸
  - ë²¡í„° í¬ê¸°ì•ˆ 1ì–µë²ˆ ë§Œí¼ forë¬¸ì„ ëŒë©° **ë‘ ë²¡í„°ì— ê°ê° 1~10 ì¤‘ ëœë¤í•œ ìˆ«ìë¥¼ ì›ì†Œë¡œ ì‚½ì…í•œë‹¤.**

<br>

### ë°©ë²• 1ï¸âƒ£ std::inner_product 

> #include \<numeric>

- `std::inner_product`ì€ ë‘ ë²¡í„°ì˜ ë‚´ì ê°’ì„ ë¦¬í„´í•´ì£¼ëŠ” í•¨ìˆ˜ë‹¤.

```cpp
  const auto sum = std::inner_product(vec0.begin(), vec0.end(), vec1.begin(), 0ull);
```

- `sum`ì— ë²¡í„° ë‚´ì ì˜ ê²°ê³¼ë¥¼ ë‹´ìŒ
- `vec1`ì€ `end()` ì—†ì´ `begin()` ë§Œ ìˆì–´ë„ ëœë‹¤.
    - ë²¡í„° ë‚´ì ì„ êµ¬í•  ë• ë‘ ë²¡í„°ì˜ ì„±ë¶„ ê°œìˆ˜ê°€ ê°™ë‹¤ê³  ê°€ì •í•˜ë¯€ë¡œ.
- `0ull`
    - 0ì„ unsigned long long ìœ¼ë¡œ í‘œê¸°
        - ë§ˆì¹˜ 16ì§„ìˆ˜ë©´ 0xë¼ í•˜ëŠ”ê²ƒê³¼ ê°™ìŒ
    - `sum`ì´ unsigned long long int íƒ€ì…ì´ ë˜ê²Œë”.
        - ê·¸ëƒ¥ 0ì´ë¼ê³  í•˜ë©´ sumì€ unsigned long long int ê°€ ì•„ë‹Œ ê·¸ëƒ¥ intê°€ ë¨.

<br>

### ë°©ë²• 2ï¸âƒ£ ìˆœì§„í•œ ë©€í‹° ì“°ë ˆë”© 

```cpp
void dotProductNaive(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

...

unsigned long long sum = 0;

vector<std::thread> threads;
threads.resize(numThread);

const unsigned int numPerThread = numData / numThread;

for (unsigned int t = 0; t < numThread; ++t)
	threads[t] = std::thread(dotProductNaive, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread, std::ref(sum));

for (unsigned int t = 0; t < numThread; ++t)
	threads[t].join();
```

- `threads`
  - ìŠ¤ë ˆë“œë“¤ì„ ë‹´ëŠ” vector
  - ë²¡í„°ì˜ ì‚¬ì´ì¦ˆë¥¼ `numThread`, ì¦‰ 4 ê°œ ë§Œí¼ ëŠ˜ë ¸ë‹¤.
- `numPerThread`
  - 1 ê°œì˜ ìŠ¤ë ˆë“œ ë‹¹ ì‘ì—…í•  ë°ì´í„° ê°œìˆ˜
  - ëª¨ë“  ìŠ¤ë ˆë“œì˜ ì‘ì—… ìˆ˜ê°€ ëª¨ë‘ ê°™ë‹¤ê³  ê°€ì •. (ë‚˜ë¨¸ì§€ê°€ 0ì¸ ê²½ìš°ë¥¼ ê°€ì •)
    - `numData` ê°’ì´ 1 ì–µì´ë‹ˆ í•œ ìŠ¤ë ˆë“œ ë‹¹ 2500 ë§Œê°œì”©ì˜ ë°ì´í„°ë¥¼ ë³‘ë ¬ ì²˜ë¦¬ í•˜ëŠ” ì…ˆì´ë‹¤. 
- ì²«ë²ˆì§¸ forë¬¸ ğŸ‘‰ 4 ë²ˆ ëˆë‹¤.
  - ìŠ¤ë ˆë“œ ë§ˆë‹¤ ë²¡í„° ë‚´ì ì„ êµ¬í•˜ëŠ” ì‘ì—…ì„ ë¶€ì—¬
    - í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§ˆë‹¤ 2500ë§Œê°œ(`numPerThread`)ì˜ ë°ì´í„°ì˜ ë²¡í„° ë‚´ì ì„ êµ¬í•˜ê³  ê²°ê³¼ë¥¼ `sum`ì— ë‹´ëŠ”ë‹¤. 
      - ì²«ë²ˆì§¸ ì¸ìˆ˜ëŠ” í•¨ìˆ˜ `doProductNaive`. ë‚˜ë¨¸ì§€ ì¸ìë“¤ì€ í•¨ìˆ˜ì— í•„ìš”í•œ ì¸ìë“¤.
        - ì‹œì‘ ë²”ìœ„ t * numPerThread, ë ë²”ìœ„ (t + 1) * numPerThread
- ë‘ë²ˆì§¸ forë¬¸
  - ë²¡í„°ì˜ ìŠ¤ë ˆë“œë“¤ì´ ì‘ì—…ì´ ëë‚˜ê¸°ë¥¼ ëŒ€ê¸° 

> ì´ ë°©ë²•ì€ **ë ˆì´ìŠ¤ ì»¨ë””ì…˜**ì´ ë°œìƒí•˜ê¸° ë•Œë¬¸ì— ë²¡í„° ë‚´ì ì˜ ê²°ê³¼ê°€ ë¶€ì •í™•í•˜ê²Œ ë‚˜ì˜¨ë‹¤.

- ëª¨ë“  ìŠ¤ë ˆë“œê°€ `sum` ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•˜ê¸° ë•Œë¬¸ì— ë°œìƒí•œë‹¤. 

<br>

### ë°©ë²• 3ï¸âƒ£ Lock guard 

```cpp
void dotProductLock(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		std::scoped_lock lock(mtx);
		sum += (v0[i] * v1[i]);
	}
}

...

		unsigned long long sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;

		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductLock, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread, std::ref(sum));

		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();
```

> `sum`ê°’ì„ ê°€ì§€ê³  ì—°ì‚°ì„ í•˜ê³  ê·¸ ê²°ê³¼ë¥¼ `sum`ì— ë®ì–´ ì”Œìš°ëŠ” ê³¼ì •ì„ í•œ ìŠ¤ë ˆë“œê°€ ì‘ì—… ì¤‘ì¼ë• ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì ‘ê·¼í•˜ì§€ ëª»í•˜ë„ë¡ lock í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì„ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```cpp
std::scoped_lock lock(mtx);  // scoped_lock ì€ unlock ì´ í•„ìš” ì—†ë‹¤. C++ 17 ë¶€í„° ê°€ëŠ¥
sum += (v0[i] * v1[i]);
```

- ì´ì œ ë²¡í„° ë‚´ì ì˜ ê°’ì€ ì •í™•í•˜ê²Œ ë‚˜ì˜¤ì§€ë§Œ êµ‰ì¥íˆ ëŠë¦¬ë‹¤. ë¬´ë ¤ 2 ì´ˆë¥¼ ë„˜ê¸´ë‹¤ ! 
  - lock ì„ 1 ì–µë²ˆ ê±¸ì–´ì£¼ì–´ì•¼ í•˜ê³  í•œ ìŠ¤ë ˆë“œê°€ ì‘ì—…ì„ í•˜ê³  ìˆì„ ë• ë‹¤ë¥¸ ìŠ¤ë ˆë“œë“¤ì´ ê¸°ë‹¤ë ¤ì•¼ í•˜ê¸° ë•Œë¬¸ì—..
  - ë„ˆë¬´ ëŠë ¤ì„œ ë©€í‹° ìŠ¤ë ˆë”© í•˜ëŠ” ë³´ëŒì´ ì—†ë‹¤. 
    - ë¬¼ë¡  ê²½ìš°ì— ë”°ë¼ ë‹¤ë¥´ê¸´ í•˜ì§€ë§Œ ì´ ê²½ìš°ì—” ê·¸ë ‡ë‹¤.
- `scoped_lock`ì„ forë¬¸ ë°”ê¹¥ì—ë‹¤ ë†“ìœ¼ë©´ ë¹¨ë¼ì§€ì§€ë§Œ ì´ê±´ ë¹„ë™ê¸° ì‘ì—…ì´ ì•„ë‹ˆë¼ ê·¸ëƒ¥ ë™ê¸°ì ìœ¼ë¡œ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ”ê±°ë‚˜ ë§ˆì°¬ê°€ì§€ë‹¤. ë³‘ë ¬ ì²˜ë¦¬ê°€ ì•„ë‹˜.

<br>

### ë°©ë²• 4ï¸âƒ£ atomic

```cpp

void dotProductAtomic(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, atomic<unsigned long long> & sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

...

		const unsigned int numPerThread = numData / numThread;

		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductLock, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread, std::ref(sum));

		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();
```

- ë²¡í„° ë‚´ì  ê²°ê³¼ë¥¼ ë‹´ì„ `sum`ì„ `atomic<unsigned long long>` íƒ€ì…ìœ¼ë¡œ ë°›ê³  ìˆë‹¤. 
  - ë©”ëª¨ë¦¬ ê°’ì„ CPUë¡œ ê°€ì ¸ì˜¤ê³ , CPUì—ì„œ ì—°ì‚°ì„ í•˜ê³ , ë‹¤ì‹œ ì—°ì‚° ê²°ê³¼ë¥¼ ë©”ëª¨ë¦¬ì— ë®ì–´ ì”Œìš°ëŠ” ì´ 3 ë‹¨ê³„ì˜ ê³¼ì •ì„ í•˜ë‚˜ë¡œ ë¬¶ì–´ì¤€ë‹¤.
  - ì´ 3ë‹¨ê³„ì˜ ê³¼ì • ë„ì¤‘ì—” ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì ‘ê·¼í•˜ì§€ ëª»í•˜ë„ë¡!
- ê²°ê³¼ëŠ” ì •í™•í•˜ë‚˜ Lock Guard ì²˜ëŸ¼ ëŠë¦¬ë‹¤.
  - `atomic` ì—°ì‚°ì´ ì¼ë°˜ ì—°ì‚°ë³´ë‹¤ ëŠë¦¬ê¸° ë•Œë¬¸ì—.

<br>

### ë°©ë²• 5ï¸âƒ£ Task-based parallelism (std::async)

```cpp
auto dotProductFuture(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end)
{
	int sum = 0;
	for (unsigned int i = start; i < end; ++i)
		sum += (v0[i] * v1[i]);
	return sum;
}

...

		unsigned long long sum = 0;

		vector<std::future<int>> futures;
		futures.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			futures[t] = std::async(dotProductFuture, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread);

		for (unsigned int t = 0; t < numThread; ++t)
			sum += futures[t].get();
```

- `futures`
  - `std::future` ê°ì²´ë“¤ì´ ë“¤ì–´ìˆëŠ” ë²¡í„°
- `std::async`ì„ í†µí•´ `doProductFuture` ì—°ì‚° ê²°ê³¼ë¥¼ `futures[t]` ì›ì†Œì— ë°›ëŠ”ë‹¤.
  - `doProductFuture` í•¨ìˆ˜
    - ìœ„ ì˜ˆì œë“¤ê³¼ ë‹¤ë¥´ê²Œ `sum`ì´ `doProductFuture`ì˜ ì¸ìë¡œ ë“¤ì–´ê°€ì§€ ì•ŠëŠ”ë‹¤. 
    - ìœ„ ì˜ˆì œì˜ ë‹¤ë¥¸ í•¨ìˆ˜ë“¤ê³¼ ë‹¤ë¥´ê²Œ `void`ê°€ ì•„ë‹Œ ë¦¬í„´ íƒ€ì…ì´ ìˆëŠ” í•¨ìˆ˜ë¡œ ì„¤ì •í–ˆë‹¤ë‹¤. ì´ë¥¼ `async`ì—ì„œ ë°›ì•„ `future`ê°ì²´ì— ë¦¬í„´í•  ìˆ˜ ìˆë„ë¡! ë¡œì»¬ `sum`ì„ ë¦¬í„´í•œë‹¤.
      - ìŠ¤ë ˆë“œëŠ” ì—°ì‚° ê²°ê³¼ë¥¼ ì§ì ‘ ë°›ì§€ ëª»í•˜ê¸° ë•Œë¬¸ì— void í•¨ìˆ˜ì™€ ë”ë¶ˆì–´ ë˜ ì¡°ì‘í•  ë³€ìˆ˜ë„ ë ˆí¼ëŸ°ìŠ¤ë¡œ í•¨ê»˜ ë„˜ê²¨ ì£¼ì—ˆì–´ì•¼ í–ˆìŒ
- `futures[t]`ì— ì—°ì‚° ê²°ê³¼ë¥¼ ë°›ê¸° ì „ê¹Œì§„ `futures[t].get` ì¶œë ¥ì´ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤. 
  - *sum += futures[t].get();*
    - `thread`ëŠ” ë ˆí¼ëŸ°ìŠ¤ë¡œ sumì„ ë„˜ê²¨ì„œ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ `+=` í–ˆìœ¼ë‹ˆ ìµœì¢…ì ìœ¼ë¡œ ë˜ ì·¨í•©í•  ì¼ì´ ì—†ì—ˆë‹¤. ëŒ€ì‹  `join`ìœ¼ë¡œ ê° ìŠ¤ë ˆë“œê°€ ì¼ì´ ëë‚˜ê¸¸ ê¸°ë‹¤ë¦¬ëŠ” ê³¼ì •ì´ í•„ìš”í–ˆìŒ
      - threadëŠ” ë‹¤ë£¨ëŠ” sumì´ global í•œ ë³€ìˆ˜ì˜€ê¸° ë•Œë¬¸ì— ì´ë¥¼ ë ˆí¼ëŸ°ìŠ¤ë¡œ ë„˜ê²¼ë‹¤.
      - ê·¸ëŸ¬ë‹ˆ ìŠ¤ë ˆë“œë“¤ì´ sumì„ ë™ì‹œì— ê±´ë“œë ¤ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì´ ì¼ì–´ë‚  ìš°ë ¤ê°€ ìˆì—ˆìŒ
    - `async`ì€ ë¡œì»¬ sumì„ ë¦¬í„´í•˜ê¸° ë•Œë¬¸ì— futures.get() ì„ í†µí•´ ë¦¬í„´ ë°›ì€ ê°’ì„ `sum +=` ì·¨í•©í•´ì£¼ì–´ì•¼ í•œë‹¤.
      - **ë¡œì»¬ sumì´ê¸°ì—** <u>í•¨ìˆ˜ ì‹¤í–‰ë§ˆë‹¤ ê°ê° ë‹¤ë¥¸ ë³„ê°œì˜ sumì´ë‹ˆê¹Œ ì„œë¡œ ì˜í–¥ì„ ì¤„ ì¼ì´ ì—†ë‹¤. ì¦‰ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì´ ì¼ì–´ë‚  ì¼ì´ ì—†ìŒ!</u>  
- ì˜¤íˆë ¤ Naive í•˜ê²Œ ë©€í‹° ìŠ¤ë ˆë”© í–ˆë˜ 2ï¸âƒ£ ë°©ë²•ë³´ë‹¤ ì—°ì‚°ì´ ë” ë¹¨ëë‹¤.
        

<br>

### ë°©ë²• 6ï¸âƒ£ Task-based parallelism (std::thread, std::promise)

```cpp
		vector<std::promise<int>> prom;
		vector<std::future<int>> future;
		vector<std::thread> threads;
		prom.resize(numThread);
		future.resize(numThread);
		threads.resize(numThread);
		
		unsigned long long sum(0);
		unsigned numPerThread = numData / numThread;

		for (unsigned i = 0; i < numThread; ++i)
		{
			future[i] = prom[i].get_future();  // prom ì—ì„œ future ê°€ì ¸ì™€ ì €ì¥
			unsigned long long tempSum(0);

			threads[i] = std::thread([&](std::promise<int>&& prom)
			{
					std::scoped_lock lock2(mtx);
					
					for (unsigned int j = 0; j < numPerThread; ++j)
						tempSum += (vec0[j] * vec1[j]);

					prom.set_value(tempSum);

			}, std::move(prom[i]));

			threads[i].join();
		}

		for (unsigned int t = 0; t < numThread; ++t)
			sum += future[t].get();
```

5ï¸âƒ£ì™€ ê°™ë‹¤. ë‹¤ë§Œ `async`ì„ `thread`ë¡œ ë°”ê¾¸ê³  `promise`ë¡œ `future`ì— ì—°ì‚° ê²°ê³¼ë¥¼ ë°›ë„ë¡ ì„¤ì •í•œ ê²ƒ ë¿!

- vector 3ê°œ í•„ìš”
  ```cpp
  vector<std::promise<int>> prom;
  vector<std::future<int>> future;
  vector<std::thread> threads;
  ```
- ì²« ë²ˆì§¸ for ë¬¸
  - future ê°ì²´ì— ì•½ì†í•œ promiseë“¤ì„ ë„˜ê¸°ê¸°ë¡œ ì•½ì†í•œë‹¤. 
    - `future[i] = prom[i].get_future();`
  - ì•„ë˜ì™€ ê°™ì€ ê¸°ëŠ¥ì„ í•˜ëŠ” ëŒë‹¤í•¨ìˆ˜ë¥¼ ìŠ¤ë ˆë“œì—ê²Œ ë¶€ì—¬í•˜ê³  ë§¤ê°œ ë³€ìˆ˜ì¸ `prom`ì´ `prom[i]`ì„ R-valueë¡œì„œ ì°¸ì¡°í•˜ê¸° ë•Œë¬¸ì— ì´ ì—°ì‚° ê²°ê³¼ë¥¼ `future`ë¡œ ì €ì¥í•˜ê²Œ í•œë‹¤.
    ```cpp
    std::scoped_lock lock2(mtx);
					
		for (unsigned int j = 0; j < numPerThread; ++j)
				tempSum += (vec0[j] * vec1[j]);
				prom.set_value(tempSum);
    ```
- ë‘ ë²ˆì§¸ for ë¬¸ 
  - `futures[t]`ì— ì—°ì‚° ê²°ê³¼ë¥¼ ë°›ê¸° ì „ê¹Œì§„ `futures[t].get` ì¶œë ¥ì´ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤. 

<br>

### ë°©ë²• 7ï¸âƒ£ std::transform_reduce

> #include \<numeric>

```cpp
const auto sum = std::transform_reduce(std::execution::par, vec0.begin(), vec0.end(), vec1.begin(), 0ull);
```

- `std::transform_reduce`
  - ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ì§€ì›í•´ì£¼ëŠ” C++ í‘œì¤€ í•¨ìˆ˜ì´ë‹¤.
  - `inner_product`ì˜ ë°œì „í˜•ìœ¼ë¡œ ë³‘ë ¬ ì²˜ë¦¬ë¡œ ë²¡í„° ë‚´ì ì„ ê³„ì‚°í•œë‹¤.
- `inner_product`ë³´ë‹¤ ì¸ìˆ˜ê°€ í•˜ë‚˜ ë” í•„ìš”í•˜ë‹¤.
  - `std::execution::par`
    - ë³‘ë ¬ì²˜ë¦¬ë¡œ ëŒë ¤ë‹¬ë¼.
    - ë§ˆì¹˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒ ì²˜ëŸ¼
  - `std::execution::seq`
    - ë³‘ë ¬ì²˜ë¦¬ ë§ê³  ìˆœì°¨ì ìœ¼ë¡œ, ë™ê¸°ì ìœ¼ë¡œ ëŒë ¤ë‹¬ë¼.

<br>

## ğŸ”” ì°¸ê³ 

- [ì½”ë“œëŠ” ì´ ë¸”ë¡œê·¸ë¥¼ ì°¸ê³ í•˜ì˜€ë‹¤.](https://blog.naver.com/leeinje66/221580959555)

***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}
